\documentclass[10pt,titlepage]{article}
\usepackage[utf8]{inputenc}
\usepackage{a4,a4wide,german}
\usepackage{wrapfig}
\usepackage{epsfig}

\usepackage{hyperref}

\newcounter{referencecounter}

\newcommand{\includefile}{INCLUDEFILE}
\newcommand{\classname}{}

\sloppy
\makeatletter{}\hyphenation
{
Teil-sze-ne 
Teil-sze-nen-be-reich 
Teil-sze-nen-be-rei-che 
Mo-dell-ob-jekt
Mo-dell-ob-jek-te
Pro-jek-tions-zen-trum
Bild-ebe-ne
La-ge-re-kon-struk-tion
Re-kon-struk-tion
ge-ring-en
Grup-pen-ei-gen-schaf-ten
Bild-ebe-ne
sig-nal-theo-re-ti-sche
} 
\textheight 23cm \textwidth 16cm \topmargin -0.6in
\pagestyle{headings}

\makeatletter{}\newcommand\lt{\textless}
\newcommand\gt{\textgreater}
\newcommand\cb[1]{\textless{}#1\textgreater}

\def\esc{\cb{ESC}}
\def\enter{\cb{ENTER}}

\def\vector#1{vector\cb{#1}}
\def\cvector#1{const vector\cb{#1} \&}

\newcommand{\nextlabel}[3]{
  \stepcounter{referencecounter}
  \glossary{#1;#2;#3;\arabic{referencecounter}}
  \hypertarget{reflabel\arabic{referencecounter}}{}
}

\newcommand{\nsection}[2]{\section{#1}
  \label{#2}
  \hypertarget{SECTION:#2}{}
    \renewcommand{\includefile}{}
  \nextlabel{SECTION}{#2}{#1}
}

\newcommand{\subtitle}[1]{{\noindent\bf#1}}
\newcommand{\proc}[3]{
  \vspace*{0.5cm}
  \par\noindent#1 \hypertarget{#2}{{\bf #2}}{\small (#3)}\hspace{0.5cm} \includefile 
  \nextlabel{#1}{#2}{#3} \\
}

\newcommand{\proch}[4]{
    \renewcommand{\includefile}{\hspace*{\fill} ({\it \#include~\cb{#4}})}
  \vspace*{0.5cm}
  \par\noindent#1 \hypertarget{#2}{{\bf #2}}{\small (#3)} \includefile 
  \nextlabel{#1}{#2}{#3} \\
}

\newcommand{\procf}[3]{
  #1 \hypertarget{#2}{{\bf #2}}{\small (#3)}
  \nextlabel{#1}{#2}{#3} \\
}

\newcommand{\ctor}[4][]{
\renewcommand{\classname}{#2}
\proch{#1}{#2::#2}{#3}{#4}
}

\newcommand{\ctorf}[2]{
\renewcommand{\classname}{#1}
\procf{}{#1::#1}{#2}
}

\newcommand{\method}[3]{
\proc{#1}{\classname::#2}{#3}
}

\newcommand{\methodf}[3]{
\procf{#1}{\classname::#2}{#3}
}

\newcommand{\descr}[1]{\nopagebreak
  \vspace*{-0.6cm}
  \begin{quote}
        #1
  \end{quote}
}

\newcommand{\seealso}[1]{
  \vspace{0.1cm}
  Siehe auch: \hyperlink{#1}{#1}
}

\newcommand{\seealsonext}[1]{
  \hyperlink{#1}{#1}
}

\def\see#1{$\to$ #1}
\def\bsee#1{#1}


\newcommand{\class}[1]{{\bf \bsee{#1}}}

\newcommand{\seebaseclass}[1]{Siehe auch die geerbten Variablen 
und Methoden der Basisklasse \class{#1}}


\def\functionlistentry#1#2#3#4#5#6{\noindent #1 {\bf #2}(#3) \dotfill #6\\}

\def\letterref#1{}
\def\letterlabel#1{\vspace{0.5cm}\centerline{\Large #1}}
\def\letterlabelend#1{}

\def\begprogr{\par\noindent\begin{minipage}{\textwidth}\medskip\hrule\medskip}

\def\endprogr{\nopagebreak\hrule\end{minipage}\par\medskip\noindent}

\makeglossary
 

\setlength{\parskip}{1.0ex plus 0.5ex minus 0.5ex}
\setlength{\parindent}{0em}

\begin{document}

\title{Handbuch ICE}
\author{{\bf Wolfgang Ortmann} und andere\\
Friedrich-Schiller-Universität Jena, Institut für Informatik}
\date{C++-Bibliothek zur Bildanalyse\\
1992..2014}
\maketitle


\makeatletter{}
\nsection{Einführung}{introduction}

ICE ist eine C-Bibliothek mit Werkzeugen für die Bildanalyse. Durch 
ein weitgehend hardware- und betriebssystemunabhängiges
Konzept der Bildverwaltung und Visualisierung ist eine Verwendung
unter Unix/X-Window und MS-Windows möglich. 

Als Compiler muß ein C++-Compiler verwendet werden. Erprobt wurde der 
Einsatz von GNU-C++ (unter Linux und Windows). 

Bilddaten sind Datenstrukturen im Hauptspeicher. Es können gleichzeitig
beliebig viele unterschiedlich große Bilder verwaltet werden. 
Für die Darstellung der Bilddaten werden Funktionen des Frameworks {\bf wxWidgets}
verwendet.

Die Funktionsprototypen der ICE-Funktionen und die benötigten Datenstrukturen
sind in dem Headerfile {\em image.h} zusammengefaßt. Damit kann nach Einschluss 
einer Datei die gesamte Funktionalität von ICE verwendet werden. Vor allem 
in größeren Projekten sollte jedoch dem Einschließen der Einzel-Headerfiles 
der Vorzug gegeben werden, da das Bilden des Projekts dadurch schneller erfolgt.

Funktionen geben bei Fehlern bei Abarbeitung (z.B. durch falsche Parameter) 
normalerweise eine Fehlermeldung aus. Die Abarbeitung des Programms kann dann
interaktiv abgebrochen oder, falls dies sinnvoll ist, fortgesetzt werden. Um 
eine Fehlerbehandlung durch das Anwenderprogramm zu ermöglichen, kann diese 
Form der Fehlermeldung durch spezielle Funktionen (\see{OffMessage}) ein- und 
ausgeschaltet werden.

Das folgende Beispielprogramm soll die Verwendung der grundlegenden
ICE-Funktionen demonstrieren.

\begprogr
\begin{verbatim}
/* Erzeugung eines Graukeiles und Binarisierung */
#include <stdio.h>
#include <image.h>               /* ICE-Headerfile */
void main(void)
{
  const int sx = 800;            /* Bildgroesse in x-Richtung */
  const int sy = 600;            /* Bildgroesse in y-Richtung */
  const int maxv = 255;          /* maximal einzutragender Datenwert */
  Image img;                     /* Deklaration eines Bildes */
  int thr = 100;                 /* Schwellwert für Binarisierung */

  OpenAlpha("ICE Text Window");  /* Textfenster öffen */
  SetAttribute(0,7,0,0);         /* Attribute setzen */
  ClearAlpha();                  /* initialisieren */

  img=NewImg(sx, sy, maxv)       /* Bild anfordern */
  Show(ON, img);                 /* Bild zur Darstellung anmelden */
  Printf("Graukeil\n");          /* Ausgabe in Alphanumerikfenster */
                                 /* Graukeil erzeugen */
  for(int y = 0; y < img->ysize; y++)
    for(int x = 0; x < img->xsize; x++)
      PutVal(img,x,y,x);         /* Grauwert schreiben */
  GetChar();                     /* Tastendruck in Text- oder Bildfenster abwarten */

  Printf("Binarisierung mit Schwellwert   for(int y = 0; y < img->ysize; y++)
    for(int x = 0; x < img->xsize; x++)
      {
        int val = GetVal(img,x,y); /* Grauwert lesen */
        if (val < thr) 
          PutVal(img,x,y,0);
        else 
          PutVal(img,x,y,img->maxval);
  }
  GetChar();                     /* Tastendruck in Text- oder Bildfenster abwarten */
  FreeImg(img);                  /* Freigabe des Bildes */ 
}
\end{verbatim}
\endprogr

 
\newpage
\makeatletter{}\nsection{Datenstrukturen für Bilder}{Images}

Bilder werden mit Hilfe von Instanzen der Bild-Klassen \class{Image}, 
\class{ColorImage} und \class{Image3d} verwaltet. Sie speichern 
die Bildinformation
in Form von Grauwerten: Der Wert 0 entspricht hier ``weiß'' 
beziehungsweise hoher Intensität und der Maximalwert 
entspricht ``schwarz''.

Bilder können visualisiert werden. Dabei werden die Bilder einmal zur 
Visualisierung angemeldet (\see{Show}) und werden ab diesem Zeitpunkt 
auf dem Bildschirm dargestellt. Alle Änderungen im Bild sind sofort
sichtbar.

Die Bildklassen selbst stellen eine {\bf Referenz} auf die eigentlichen 
Bilddaten dar. Sie haben Eigenschaften ähnlich einem Zeiger (''Smart Pointer''). 
In den meisten Fällen kann man diese Referenz aber als ''das Bild'' ansehen, 
mit dem man am Ende arbeitet. Es gibt jedoch einige Besonderheiten zu beachten:
\begin{itemize}
\item Alle Konstruktoren erzeugen kein neues Bild, sondern zunächst nur eine 
Referenz. 
\item Der Standard-Konstruktor erzeugt zunächst ein ''ungültiges''
Bild (\see{Image::isValid}). Vor der Verwendung muss noch das 
eigentliche Bild initialisiert werden (\see{NewImg}, \see{Image::create} ).
\item Der Kopierkonstruktor und damit auch Parameterübergaben über den Wert 
erzeugen {\bf kein} neues Bild, sondern nur eine neue Referenz auf das 
Ursprungsbild. Es handelt sich also um das gleiche Bild. Das gilt auch für den 
Zuweisungsoperator.
\item Bilder, genauer gesagt die Referenzen,  werden als konstant 
betrachtet, solange sich nicht die Bildgröße oder der Grauwertumfang 
ändert. Bilder werden deshalb an Funktionen meist als konstante Referenz 
übergeben (\verb+const Image &image+), auch wenn sich der Inhalt des Bildes
ändert.
\item Zum Anlegen von Bildern gibt es Methoden (\see{Image::create}) 
und Funktionen (\see{NewImg}), ebenso zum Kopieren bestehender Bilder 
(\see{CopyImg}, \see{Image::copy}).
\item Es ist möglich, Bilder explizit freizugeben (mittels \see{FreeImg}), 
im Normalfall erfolgt eine Freigabe implizit mit dem Ungültigwerden 
der Variable. 
\end{itemize}

Die Klasse \class{Image} dient zur Behandlung von Grauwertbildern. Der 
Wert eines Pixels wird hier durch einen ganzzahligen Wert repräsentiert. 

Zur Behandlung von Farbbildern ist die Klasse \class{ColorImage}
zu verwenden, die in 3 Bildern der Klasse \class{Image} die Farbauszüge 
Rot, Grün und Blau verwaltet.

3D-Bilder können mit der Template-Klasse class{Image3d} angelegt werden.
Es handelt sich um eine Sequenz von Bildern.

\subsection{Die Klasse Image}
\label{Image}
\hypertarget{Image}{}

Die Klasse \class{Image} stellt ein zweidimensionales Grauwert-Bild dar. 
Sie speichert die Bildinformation in Form von Grauwerten: Der 
Wert 0 entspricht hier ''weiß'' und der Maximalwert 
entspricht ''schwarz''.

Die Grauwerte neu angelegter Bilder werden standardmäßig 
nicht initialisiert, so dass ihr Wert unbestimmt ist (\see{ClearImg}, \see{Image::set}).

\subsection{Die Klasse ColorImage}
\label{ColorImage}
\hypertarget{ColorImage}{}

Die Klasse \class{ColorImage} stellt ein zweidimensinales Farbbild dar. Die Farben
werden in den drei ''Kanälen'' rot, grün und blau gespeichert. Die ''Kanäle'' selbst 
sind Bilder der Klasse \class{Image}, auf die auch einzeln zugegriffen werden kann.
Der Zugriff auf Farbbildpunkte arbeitet mit Werten vom Typ \class{ColorValue}, dessen
Komponenten die {\bf Intensitäten} in der Kanälen rot, grün und blau darstellen.

\subsection{Organisation und Verwaltung}
\subsubsection{Image}
\proch{}{Image::Image}{}{ImageC.h}
\descr{Standard-Konstruktor. Das so erzeugte Bild ist zunächst ungültig
  \see{Image::isValid}.}

\proch{}{Image::Image}{const Image \&img}{ImageC.h}
\descr{Kopier-Konstruktor. Erzeugt eine weitere {\bf Referenz} auf das
  übergebene Bild.}

\proch{void}{Image::create}{int xsize,int ysize,int maxval,const string \&title=''''}{ImageC.h}
\procf{void}{Image::create}{const Image \&img,const string \&title=''''}
\descr{Falls das Bild bereits initialisiert ist, wird zunächst das bestehende 
Bild freigegeben.
Es wird dann ein neues Bild der Größe $xsize$ * $ysize$ angelegt. 
Der Maximalwert der zu speichernden Grauwerte beträgt $maxval$.
Das Bild erhält den durch $title$ gegebenen Namen, der zum Beispiel bei der Darstellung
verwendet wird.
In der zweiten Form werden die Daten des Bildes $img$ als 
Vorlage verwendet. Der Bildinhalt wird nicht kopiert.}

\proch{void}{Image::copy}{const Image \&src}{ImageC.h}
\descr{Falls das Bild bereits initialisiert ist, wird zunächst das bestehende 
Bild freigegeben. Ein neues Bild wird dann als Kopie des übergebenen Bildes erzeugt.}

\proch{static Image}{Image::createImage}{int sizeX, int sizeY, int maxValue, const std::string \&title = ''''}{ImageC.h}
\descr{Legt ein neues Bild der Größe $sizeX$ * $sizeY$ mit dem
maximalen Grauwert $maxValue$ an und gibt ein {\bf Image} zurück.
Das Bild erhält den durch $title$ gegebenen Namen, der zum Beispiel bei der Darstellung
verwendet wird.
}
Dies ist eine statische Methode und kann in der Form \verb+Image image=Image::createImage(1280,720,255);+
verwendet werden. (''named constructor'')

\proch{static Image}{createImage}{const Image \&src, bool copy, const std::string \&title = ''''}{ImageC.h}
\descr{Legt ein neues Bild der Größe mit den Parametern von $src$ an und gibt ein {\bf Image} zurück.
Das Bild erhält den durch $title$ gegebenen Namen, der zum Beispiel bei der Darstellung
verwendet wird.
}
Dies ist eine statische Methode und kann in der Form verb+Image image2=Image::createImage(image);
verwendet werden. (''named constructor'')

\proch{Image}{NewImg}{int xsize,int ysize,int maxval,const string \&title=''''}{ImageC.h}
\procf{Image}{NewImg}{const Image \&img,int copy=false,const string \&title=''''}
\descr{
Es wird ein neues Bild angelegt und als Funktionswert zurückgegeben.
Die Größe wird durch $xsize$ und $ysize$ bestimmt, der maximale Grauwert 
ist $maxval$. Das Bild erhält den durch $title$ gegebenen Namen, der zum Beispiel bei der Darstellung
verwendet wird.
Bei Aufruf mit einem vorhandenen Bild $img$ wird dessen Größe
als Vorlage gewählt. Ist $copy=true$, so wird auch der Bildinhalt ins neue
Bild kopiert.
}

\proch{int}{FreeImg}{Image \&img}{ImageC.h}
\descr{
Das Bild $img$ wird gelöscht und der dynamische Speicher freigegeben. Das Bild wird damit
ungültig (\see{Image::isValid}):
}

\proch{bool}{Image::isValid}{}{ImageC.h}
\descr{
Gibt $true$ zurück, wenn Image ein gültiges Bild ist.
}

\proc{bool}{IsImg}{const Image \&img}
\descr{
Die Funktion gibt $true$ zurück, wenn $img$ ein gültiges Bild ist (\see{Image::isValid}).
}
\subsubsection{ColorImage}
\proch{}{ColorImage::ColorImage}{}{ColorImage.h}
\descr{Standard-Konstruktor. Das so erzeugte Farbbild ist zunächst ungültig
  \see{ColorImage::isValid}.}

\proch{}{ColorImage::ColorImage}{const ColorImage \&img}{ColorImage.h}
\descr{Kopier-Konstruktor. Erzeugt eine weitere {\bf Referenz} auf das
  übergebene Farbbild.}

\proch{void}{ColorImage::create}{int xsize,int ysize,int maxval,const string \&title=''''}{ColorImage.h}
\procf{void}{ColorImage::create}{const ColorImage \&img,const string \&title=''''}
\descr{Falls das Farbbild bereits initialisiert ist, wird zunächst das bestehende 
Farbbild freigegeben.
Es wird dann ein neues Farbbild der Größe $xsize$ * $ysize$ angelegt. 
Der Maximalwert der zu speichernden Werte pro Farbkanal beträgt $maxval$.
Das Farbbild erhält den durch $title$ gegebenen Namen, der zum Beispiel bei der Darstellung
verwendet wird.
In der zweiten Form werden die Daten des Farbbildes $img$ als 
Vorlage verwendet. Der Bildinhalt wird nicht kopiert.}

\proch{void}{ColorImage::copy}{const ColorImage \&src}{ColorImage.h}
\descr{Falls das Farbbild bereits initialisiert ist, wird zunächst das bestehende 
Farbbild freigegeben. Ein neues Farbbild wird dann als Kopie des übergebenen Farbbildes erzeugt.}

\proch{static ColorImage}{ColorImage::createColorImage}{int sizeX, int sizeY, int maxValue, const std::string \&title = ''''}{ColorImage.h}
\descr{Legt ein neues Farbbild der Größe $sizeX$ * $sizeY$ mit einem maximalen Wert $maxValue$ 
in den Farbkanälen an und gibt ein {\bf ColorImage} zurück.
Das Farbbild erhält den durch $title$ gegebenen Namen, der zum Beispiel bei der Darstellung
verwendet wird.
}
Dies ist eine statische Methode und kann in der Form \verb+ColorImage image=ColorImage::createColorImage(1280,720,255);+
verwendet werden. (''named constructor'')

\proch{static ColorImage}{ColorImage::createColorImage}{const ColorImage \&src, bool copy, const std::string \&title = ''''}{ColorImage.h}
\descr{Legt ein neues Farbbild der Größe mit den Parametern von $src$ an und gibt ein {\bf ColorImage} zurück.
Das Farbbild erhält den durch $title$ gegebenen Namen, der zum Beispiel bei der Darstellung
verwendet wird.
}
Dies ist eine statische Methode und kann in der Form verb+ColorImage image2=ColorImage::createColorImage(image);
verwendet werden. (''named constructor'')

\proch{ColorImage}{NewImg}{int xsize,int ysize,int maxval,const string \&title=''''}{ColorImage.h}
\procf{ColorImage}{NewImg}{const ColorImage \&img,int copy=false,const string \&title=''''}
\descr{
Es wird ein neues Farbbild angelegt und als Funktionswert zurückgegeben.
Die Größe wird durch $xsize$ und $ysize$ bestimmt, der maximale Wert in den Farbkanälen
ist $maxval$. Das Farbbild erhält den durch $title$ gegebenen Namen, der zum Beispiel bei der Darstellung
verwendet wird.
Bei Aufruf mit einem vorhandenen Farbbild $img$ wird dessen Größe
als Vorlage gewählt. Ist $copy=true$, so wird auch der Bildinhalt ins neue
Farbbild kopiert.
}

\proch{int}{FreeImg}{ColorImage \&img}{ColorImage.h}
\descr{
Das Farbbild $img$ wird gelöscht und der dynamische Speicher freigegeben. Das Farbbild wird damit
ungültig (\see{ColorImage::isValid}):
}

\proch{bool}{ColorImage::isValid}{}{ColorImage.h}
\descr{
Gibt $true$ zurück, wenn ColorImage ein gültiges Farbbild ist.
}

\proc{bool}{IsImg}{const ColorImage \&img}
\descr{
Die Funktion gibt $true$ zurück, wenn $img$ ein gültiges Farbbild ist (\see{ColorImage::isValid}).
}

\proch{Image}{ColorImage::redImage}{void}{ColorImage.h}
\procf{Image}{ColorImage::greenImage}{void}
\procf{Image}{ColorImage::blueImage}{void}
\descr{
Liefert die Teilbilder vom Typ \see{Image} (Farbauszüge) zurück. 
Damit können die Funktionen für Bilder vom Typ \see{Image} auf die einzelnen 
Farbauszüge angewendet werden.
Bei der Bearbeitung der Teilbilder muß garantiert werden, dass diese 
immer die gleiche Größe behalten, sonst wird das Farbbild ungültig.
}

\subsection{Teilbilder - SubImages}
\hypertarget{SubImages}{}

In ICE wird die Idee einer ''Region of interest'' durch Teilbilder (SubImages)
realisiert. Durch den \hyperlink{SubImageConstructor}{SubImage-Konstruktor} wird
eine Referenz vom Typ $Image$ erzeugt, die auf ein rechteckiges Teilbild des
gegebenen Bildes weist. Teilbilder verhalten sich in fast jeder Hinsicht wie
andere Bilder, insbesondere kann auch von Teilbildern wieder ein Teilbild
angelegt werden. Werden jetzt irgendwelche Operationen auf dieses
(Teil-)Bild angewendet, so wirken sie sich auf diesen rechteckigen Teilbereich
des Ausgangsbildes aus. 

\hypertarget{SubImageConstructor}{}
\proch{}{Image::Image}{const Image \&img,const Window \&w,const string \&title=''''}{ImageC.h}
\descr{Legt eine neue Referenz auf die Bilddaten des Bildes $img$ an, welches
  dem durch $w$ gegebenem {\bf Teilbild} entspricht. Das Bild erhält den durch
  $title$ gegebenen Namen. Ein solches Teilbild verhält sich in (fast) 
  allen Belangen wie ein normales Bild, es wird jedoch immer ein Teilbild 
  des Bildes $img$ verarbeitet.}

\proch{Image}{Image::operator()}{const Window \&w}{ImageC.h}
\descr{Erzeugt ein Teilbild von Image}

\proch{}{ColorImage::ColorImage}{const ColorImage \&img,const Window \&w,const string \&title=''''}{ColorImage.h}
\descr{Legt eine neue Referenz auf die Bilddaten des Farbbildes $img$ an, welches
  dem durch $w$ gegebenem {\bf Teilbild} entspricht. Das Bild erhält den durch
  $title$ gegebenen Namen. Ein solches Teilbild verhält sich in (fast) 
  allen Belangen wie ein normales Bild, es wird jedoch immer ein Teilbild 
  des Bildes $img$ verarbeitet.}

\proch{ColorImage}{ColorImage::operator()}{const Window \&w}{ImageC.h}
\descr{Erzeugt ein Teilbild von Image}

Dadurch können beliebige mit Bildern arbeitende Funktionen auch auf Teilbilder 
angewendet werden:
\begin{verbatim} 
 Image img = ReadImg("test.jpg");
 Image subimg(img, Window(10,10,200,150));        // SubImage anlegen
 ClearImg(subimg);                                // Funktion auf Teilbereich anwenden
 SetImg(img(Window(200,100,300,200)),img.maxval); // SubImage mit operator() erzeugt
\end{verbatim}

\subsection{Bildpunktzugriff}

Der Zugriff auf einzelne Pixel von Bildern erfolgt mit Hilfe der Methoden
\see{Image::setPixel} und \see{Image::getPixel} oder mittels der
Funktionen \see{PutVal} und \see{GetVal}. \\
Die Unchecked-Varianten der Methoden erlauben einen 
beschleunigten Zugriff ohne Testung der übergebenen Parameter.
Diese sollten nur in gut getesteten Programmen zur Anwendung kommen.
Bei hohen Anforderungen an die Laufzeit des Programmes kann der 
\hyperref{direct_pixel_access}{}{}{low level-Bildpunktzugriff} verwendet werden.

\subsubsection{Methoden}

\proch{int}{Image::getPixel}{int x,int y}{ImageC.h}
\procf{int}{Image::getPixel}{IPoint p}
\descr{Abfrage des Grauwertes an der Stelle (x,y) oder p des Bildes. }

\proch{ColorValue}{ColorImage::getPixel}{int x,int y}{ColorImage.h}
\procf{ColorValue}{ColorImage::getPixel}{IPoint p}
\descr{Abfrage des Farbwertes an der Stelle (x,y) oder p des Bildes. }

\proch{int}{Image::getPixelUnchecked}{int x,int y}{ImageC.h}
\procf{int}{Image::getPixelUnchecked}{IPoint p}
\descr{Abfrage des Grauwertes an der Stelle (x,y) oder p des Bildes. 
Es erfolgt keine Testung, ob die übergebenen Koordinaten innerhalb des Bildes liegen.
}

\proch{ColorValue}{ColorImage::getPixelUnchecked}{int x,int y}{ColorImage.h}
\procf{ColorValue}{ColorImage::getPixelUnchecked}{IPoint p}
\descr{Abfrage des Farbwertes an der Stelle (x,y) oder p des Bildes.
Es erfolgt keine Testung, ob die übergebenen Koordinaten innerhalb des Bildes liegen.
}

\proch{int}{Image::getIntensity}{int x,int y}{ImageC.h}
\procf{int}{Image::getIntensity}{IPoint p}
\descr{Abfrage der Intensität an der Stelle (x,y) oder p des Bildes.}

\proch{int}{Image::getIntensityUnchecked}{int x,int y}{ImageC.h}
\procf{int}{Image::getIntensityUnchecked}{IPoint p}
\descr{Abfrage der Intensität an der Stelle (x,y) oder p des Bildes.
Es erfolgt keine Testung, ob die übergebenen Koordinaten innerhalb des Bildes liegen.
}

Das Ergebnis der Abfrage der Intensität ist äquivalent zu \verb+img.maxval - img.getPixel(x,y)+.

\proch{void}{Image::setPixel}{int x,int y,int value}{ImageC.h}
\procf{void}{Image::setPixel}{IPoint p,int value}
\descr{Setzt den Grauwert an der Stelle (x,y) oder p des Bildes auf den Wert $value$. }

\proch{void}{ColorImage::setPixel}{int x,int y,ColorValue cv}{ColorImage.h}
\procf{void}{ColorImage::setPixel}{IPoint p,ColorValue cv}
\descr{Setzt den Farbwert an der Stelle (x,y) oder p des Farbbildes auf den Wert $cv$. }

\proch{void}{Image::setPixelUnchecked}{int x,int y,int value}{ImageC.h}
\procf{void}{Image::setPixelUnchecked}{IPoint p,int value}
\descr{Setzt den Grauwert an der Stelle (x,y) oder p des Bildes auf den Wert $value$.
Es erfolgt keine Testung der übergebenen Koordinaten und des Wertes.
}

\proch{void}{ColorImage::setPixelUnchecked}{int x,int y,ColorValue cv}{ColorImage.h}
\procf{void}{ColorImage::setPixelUnchecked}{IPoint p,ColorValue cv}
\descr{Setzt den Farbwert an der Stelle (x,y) oder p des Farbbildes auf den Wert $cv$. 
Es erfolgt keine Testung der übergebenen Koordinaten und des Wertes.
}

\proch{int}{Image::setIntensity}{int x,int y,int value}{ImageC.h}
\procf{int}{Image::setIntensity}{IPoint p,int value}
\descr{Setzt die Intensität an der Stelle (x,y) oder p des Bildes auf 
den Wert $value$.}

\proch{int}{Image::setIntensityUnchecked}{int x,int y,int value}{ImageC.h}
\procf{int}{Image::setIntensityUnchecked}{IPoint p,int value}
\descr{Setzt die Intensität an der Stelle (x,y) oder p des Bildes auf den Wert
$value$. Es erfolgt keine Testung, ob die übergebenen Koordinaten und der 
Intensitäts-Wert zulässig sind.
}

Das Setzen der Intensität eines Pixels ist äquivalent zu zum Setzen des 
Grauwertes auf \verb+img.maxval - value+.

Die Methoden {\bf inside} sind nützlich, um festzustellen, ob die Kordinaten eines 
Punktes oder Fensters im Inneren eines Bildes liegen.

\proc{bool}{Image::inside}{const IPoint p}
\procf{bool}{Image::inside}{int x,int y}
\procf{bool}{Image::inside}{const Window \&w}
\procf{bool}{ColorImage::inside}{const IPoint p}
\procf{bool}{ColorImage::inside}{int x,int y}
\procf{bool}{ColorImage::inside}{const Window \&w}
\descr{Die Methoden testen ob ein gegebener Punkt beziehungsweise das gegebene
  Fenster (\class{Window}) im Bereich der Bildkoordinaten des Bildes liegt.
}

\subsubsection{Funktionen}

\proch{void}{PutVal}{\bsee{Image} \&img,int x,int y,int val}{base.h}
\descr{
Der Bildpunkt (x,y) im Bild $img$ wird mit dem Wert $val$ beschrieben. Es
muß $0\le val\le img \to maxval$ gelten.
}

\proc{int}{GetVal}{const \bsee{Image} \&img,int x,int y}
\descr{Der Wert des Bildpunktes $(x,y)$ des Bildes $img$ wird als Funktionswert
bereitgestellt.
}

\proc{int}{GetVal}{const \bsee{Image} \&img,double x,double y,mode=DEFAULT}
\descr{Es wird ein Wert der Grauwertfunktion des Bildes $img$ für den 
Punkt (x,y) bereitgestellt. Der Wert berechnet sich in Abhängigkeit von
$mode$:
\begin{itemize}
\item $mode=DEFAULT$: Der Wert des nächsten Pixels wird genutzt, 
\item $mode=INTERPOL$: Der Wert wird durch bilineare Interpolation aus den 4
  benachbarten Pixeln berechnet.
\end{itemize}
}

\proch{void}{PutVal}{\bsee{Image} \& img,const \bsee{IPoint} \&p,int val}{base.h}
\descr{Setzt das Pixel im Punkt $p$ auf den Wert $val$.}

\proch{int}{GetVal}{const \bsee{Image} img,const \bsee{IPoint} \&p}{base.h}
\descr{Liest den Wert des Pixels im Punkt $p$.}

\proch{double}{GetInterpolVal}{Image img,double x,double y}{base.h}
\procf{bool}{GetInterpolVal}{Image img,double x,double y,double \&val}
\descr{Für die Gleitkomma-Koordinaten $(x,y)$ wird durch bilineare Interpolation 
der Grauwerte der vier nächstliegenden Bildpunkte aus dem Bild $img$ ein
Grauwert berechnet.\\
In der zweiten Aufrufform gibt die Funktion zurück, ob die Koordinaten 
innerhalb des Bildes lagen. Der interpolierte Grauwert wird
hier auf $val$ zurückgegeben.}

\subsection{Schleifen in Bildern}

Sollen Operationen in einem Bild über alle Pixel erfolgen, so müssen 
in einer Schleife alle Koordinatenwerte durchlaufen werden. 
Wenn irgend möglich sollte dafür ein zeilenweises Durchlaufen gewählt 
werden, da dann die Caches des Computers effizienter arbeiten können 
und die Abarbeitung deutlich schneller erfolgt. 

Dies wird oft in der Form zweier Schleifen erfolgen:

\begprogr
\begin{verbatim}
Image img;
... 
for (int y=0; y < img.ysize; ++y) // äußere Schleife y
  for (int x=0; x < img.xsize; ++x) // innere Schleife x
    {
      PutVal(img,x,y,(x+y)     }
\end{verbatim}
\endprogr

Eine iterator-ähnliche Methode zum Durchlaufen aller Bildpunkte
verwendet die Klasse \class{Walker}.

\subsection{Bildpunktzugriff auf low level-Ebene}
\hypertarget{direct_pixel_access}{}
Um einen schnelleren Zugriff auf die Bilddaten in zeitkritischen Anwendungen
zu ermöglichen, kann ein Zeiger auf die internen Datenstrukturen abgefragt
und direkt auf die Daten im Speicher zugegriffen werden. Dabei gibt es
folgende Einschränkungen:
\begin{itemize}
\item Der Zugriff ist abhängig vom konkreten Typ des Bildes. Dieser Typ kann
  mit der Methode \verb+Image->ImageType()+ abgefragt werden. Als Typ-Wert wird 
  einer der Werte von 1 bis 3 zurückgegeben, woraus sich der zu verwendende
  Pixel-Datentyp ergibt.\\
\begin{tabular}{|l|l|l|} \hline
Bildtyp&Pixeltyp&C++-Datentyp\\
\verb+Image->ImageType()+ & & \\ \hline
1&PixelType1&unsigned char\\
2&PixelType2&unsigned short int\\
3&PixelType3&int\\ \hline
\end{tabular}\\
Die Angabe des zugrundeliegenden C++-Datentyps dient nur der Information 
und kann sich jederzeit ändern.
\item Es erfolgt keinerlei Testung der Parameter des Zugriffs.
\item Die Visualisierung der geänderten Daten muss durch
  Image-$>$needRefresh() explizit veranlasst werden.
\end{itemize}

\proch{int}{Image-$>$ImageType}{}{ImageC.h}
\descr{Gibt den Type des Bildes zurück.}

\proch{void*}{Image-$>$getDataPointer}{}{ImageC.h}
\descr{Gibt einen Zeiger T** auf die Bilddaten zurück. Dabei ist T der
  Pixeltyp, der in Abhängigkeit vom Bildtyp explizit zu casten ist.
  Der Zeiger zeigt auf ein Feld von Zeigern auf die Bildzeile. Die Bildzeile selbst
  ist ein C-array vom Pixel-Typ $T$.}

Ein Beispiel-Programmfragment:
\begprogr
\begin{verbatim}
Image img;
... 
if (img->ImageType()==1) // Spezialbehandlung für diesen Typ
{
  PixelType1** imgdata = (PixelType1**)img->getDataPtr();
  for (int y=0; y < img.ysize; ++y) // äußere Schleife y
    for (int x=0; x < img.xsize; ++x) // innere Schleife x
    {
      imgdata[y][x] = 1;
    }
  img->needRefresh();
}
else // alle anderen Bildtypen
{
  for (int y=0; y < img.ysize; ++y) // äußere Schleife y
    for (int x=0; x < img.xsize; ++x) // innere Schleife x
    {
      PutVal(img,x,y,1);
    }
}
\end{verbatim}
\endprogr

\subsection{Bildbearbeitung}
Operatoren über Bilder vom Typ \class{Image} verknüpfen ein oder zwei Bilder und
legen das Ergebnis im Zielbild ab. Alle Bilder, insbesondere auch das Zielbild
müssen gültige (mit \see{NewImg} angelegte) Bilder sein.
Die Bildgrößen aller Bilder müssen entsprechend übereinstimmen.

Die Beschreibung der Operatoren findet sich für alle Bildrepräsentationen im
Abschnitt \see{Bildbearbeitung}.

\subsection{3D-Bilder - die Klasse Image3D}
\hypertarget{Image3d}{}

Die Klasse \class{Image3d} repräsentiert 3D-Bildern. Das sind dreidimensionale 
Voxel-Bilder, wie sie beispielsweise bei der Computer-Tomografie oder 
Magnet-Resonanz-Tomografie entstehen.
{\bf Image3d}-Objekte stellen eine Sequenz von 2D-Bildern \class{Image} dar, 
die Scheiben des 3D-Bildes in XY-Richtung darstellen. Bei 3D-Bildern der Klasse
{\bf Image3d} kann die Auflösung in alle 3 Richtungen getrennt festgelegt 
werden, was beim Zugriff mittels {\bf GetValueD} berücksichtigt wird.
\subsubsection{Konstruktoren}
\proch{}{Image3d}{int xs, int ys, int zs, int maxval = 255,
  double xscale = 1.0, double yscale = 1.0, double zscale = 1.0}{image3d.h}
\descr{Erzeugt ein 3D-Bild der Klasse {\bf Image3d}. Die Ausdehnungen in 
X-, Y- und Z-Richtung in Voxeln wird durch $xs$, $ys$ und $zs$ festgelegt.
$maxval$ gibt den maximalen Grauwert an, der in Voxeln gespeichert werden kann.
$xscale$, $yscale$ und $zscale$ beschreiben die physische Größe des Voxels.}

\proch{}{Image3d}{const std::string \&filemask,
  double xscale = 1.0, double yscale = 1.0, double zscale = 1.0}{image3d.h}
\descr{Erzeugt ein 3D-Bild aus Bilddateien. Aus den Bilddateien wird die Größe ermittelt,
das 3D-Bild angelegt und die Bilder werden eingelesen. Die Datei-Maske muss die zu ladenden Bilder 
beschreiben. Die Reihenfolge der Bilder ist alphabetisch.
$xscale$, $yscale$ und $zscale$ beschreiben die physische Größe des Voxels.}

\proch{}{Image3d}{const Image3d \&src, bool copydata = true}{image3d.h}
\descr{Kopierkonstruktor. Bei Angabe von $copydate$ als $false$ wird nur das 3D-Bild
gleicher Größe angelegt, aber der Bildinhalt nicht kopiert.}

\proch{}{Image3d}{const Image3d \&src, Window3d w}{image3d.h}
\descr{Konstruktor eines 3D-Teilbildes, welches die Daten des Originalbildes $src$
referenziert. Änderungen des Teilbildes ändern den entsprechend Bildauschnitt des 
Origionalbildes $src$.}
 
\subsection{Bilder mit Gleitkommawerten}
\label{ImageD}
\hypertarget{Image3d}{}
Für einige Aufgaben, z.B. im Zusammenhang mit Fouriertransformationen, reicht
der Grauwertumfang der Integer-Bilder \class{Image} nicht aus. Analog zur 
Datenstruktur Image gibt es eine Datenstruktur \class{ImageD} mit Grauwerten 
vom Typ {\em double} eingeführt. Diese Bilder können nicht direkt visualisiert
werden, es stehen jedoch Funktionen zur Konvertierung in Integer-Bilder und
umgekehrt zur Verfügung (\see{ConvImgDImg}). Zusätzlich zum maximalen 
Wert $maxval$ wird in Gleitkomma-Bildern der minimale Wert $minval$ 
gespeichert. Abweichend von den Integer-Bildtypen haben diese Werte 
jedoch nur einen informativen Character. Sie stellen keine Begerenzung 
des Wertebereiches dar und es erfolgt bei Zuweisungen keine Testung auf eine 
Einhaltung des gegebenen Bereichs.

\proch{ImageD}{NewImgD}{int xsize,int ysize,double minval=0.0,double maxval=0.0}{based.h}
\procf{ImageD}{NewImgD}{ImageD img,bool copy=false}
\procf{ImageD}{NewImgD}{const Image \&img,bool copy=false}
\descr{
Es wird ein neues Gleitkommabild angelegt und als Funktionswert zurückgegeben.
Neben der Möglichkeit der expliziten Angabe der Größe kann auch ein anderes 
Bild (\class{Image}) oder Gleitkommabild als Muster vorgegeben werden. Wenn der 
zusätzliche Parameter $copy$ = true ist, wird der Inhalt der Vorlage ins neue 
Bild kopiert. Im Fehlerfall wird der NULL-Pointer zurückgegeben.
}

\proch{void}{PutValD}{ImageD img,int x,int y,double val}{macro.h}
\descr{
Der Bildpunkt $(x,y)$ im Bild $img$ wird mit dem Wert $val$ beschrieben. 
Es wird keine Kontrolle des Wertebereiches vorgenommen. 
}

\proc{double}{GetValD}{ImageD img,int x,int y}
\descr{
Es wird der Datenwert des Bildpunktes $(x,y)$ des Bildes $img$ als
Funktionswert bereitgestellt.
}

\proch{void}{PutValue}{ImageD img,IPoint p,double val}{based.h}
\descr{
Der Bildpunkt $p$ im Bild $img$ wird mit dem Wert $val$ beschrieben. 
Es wird keine Kontrolle des Wertebereiches vorgenommen. 
}

\proc{double}{GetValue}{ImageD img,IPoint p}
\descr{
  Es wird der Datenwert des Bildpunktes $p$ des Bildes $img$ als
Funktionswert bereitgestellt.
}

\proch{int}{UpdateLimitImgD}{ImageD img}{based.h}
\descr{
In dem Gleitkommabild $img$ werden die Werte für den minimalen und maximalen Grauwert
anhand der vorhandenen Werte des Bildes aktualisiert.
}

\proc{int}{ConvImgDImg}{ImageD imgs,Image imgd,int modus=ADAPTIVE,int sign=UNSIGNED}
\descr{
Das Gleitkommabild $imgs$ wird in ein Integer-Bild $imgd$ konvertiert. 
Die Parameter $modus$ und $sign$ steuern, welcher Zahlenbereich des 
Gleitkomma-Bildes dem Grauwert-Umfang des Integer-Bildes entspricht:
\begin{tabular}{|l||c|c|} \hline
$modus$ & $UNSIGNED$ & $SIGNED$ \\ \hline \hline
RAW & $[0,imgd->maxval]$ & $[-\frac{imgd->maxval}{2},\frac{imgd->maxval}{2}]$ \\ \hline
ADAPTIVE & \multicolumn{2}{c}{$[imgs->minval,imgs->maxval]$} \\ \hline
NORMALIZED & $[0,4]$ & $[-2,2]$ \\ \hline
\end{tabular}\\
Werte außerhalb des jeweiligen Wertebereichs werden auf den Maximal- bzw.
Minimal-Wert begrenzt. Ist $modus=ADAPTIVE$ wird der Wertebereich des
Gleitkommabildes neu ermittelt, der Parameter $sign$ wird hier ignoriert.
}

\proc{int}{ConvImgImgD}{const Image \&imgs,ImageD imgd,int modus=RAW,int sign=UNSIGNED}
\descr{
Das Integer-Bild $imgs$ wird in ein Gleitkommabild $imgd$ konvertiert.
Der Grauwert-Bereich des Quellbildes $[0,imgs->maxval]$ wird in Abhängigkeit
von $modus$ und $sign$ in die folgenden Gleitkomma-Zahlenbereiche 
transformiert:
\begin{tabular}{|l||c|c|} \hline
$modus$ & $UNSIGNED$ & $SIGNED$ \\ \hline \hline
RAW & $[0,imgs->maxval]$ & $[-\frac{imgs->maxval}{2},\frac{imgs->maxval}{2}-1]$ \\ \hline
NORMALIZED & $[0,4]$ & $[-2,2]$ \\ \hline
\end{tabular}
}

\proc{int}{FreeImgD}{ImageD img}
\descr{
Das Gleitkommabild $img$ wird gelöscht und der dynamische Speicher freigegeben.
}

 
\newpage
\makeatletter{}\nsection{Visualisierung von Bildern und interaktive Auswahl}{Visualisierung}

\subsection{Displaysteuerung}

Die darzustellenden Bilder müssen mit der Funktion \see{Show} zur 
Visualisierung angemeldet werden. Sie werden dann in einem Fenster 
dargestellt. Bilder können als einfaches Grauwertbild, 
als Grauwertbild mit Overlays und als Echtfarbbilder dargestellt
werden. Veränderungen der Bilder werden im Normalfall simultan dargestellt.

Die Bilddarstellung wird durch einen gesonderten Prozess realisiert. Die
Aktualisierung erfolgt in kurzen Abständen, gesteuert durch einen Zeitgeber.
Falls diese Abstände - z.B. für Interaktionen - zu groß sind, kann
mit der Funktion \see{ForceUpdate} ein sofortiges Update erzwungen werden.

\proch{int}{Show}{int mode,Image img,const string \& title=''''}{visual.h}
\procf{int}{Show}{int mode,Image img1,Image img2,const string \& title=''''}
\procf{int}{Show}{int mode,Image img1,Image img2,Image img3,const string \&title=''''}
\descr{
  Es werden Bilder vom Type \class{Image} für die Visualisierung angemeldet.
  Die Zahl der Parameter ist abhängig vom gewünschten Darstellungs-Modus ab. 
  Wenn mehrere Bilder übergeben werden, müssen diese jeweils die gleiche 
  Größe haben. Der Parameter $title$ gibt den Titel des zugehörigen Fensters
  an. Wird $title$ nicht angegeben, wird der Name des ersten Bildes verwendet.
  Der Modus $mode$ kann eine der folgenden Konstanten sein:\\
  \begin{tabular}{|c|l|} \hline
    ON & 
    \begin{minipage}{0.6\textwidth}
      Das Bild $img1$ wird als einfaches Grauwertbild dargestellt.
    \end{minipage} \\ \hline
    \begin{minipage}{0.2\textwidth}
      OVERLAY, OVERLAY1, OVERLAY2, OVERLAY3 
    \end{minipage}
    & 
    \begin{minipage}{0.6\textwidth}
      Das Bild $img1$ wird als Grauwertbild dargestellt, das Bild $img2$ als
      Overlaybild, d.h, dort, wo im Bild $img2$ der Wert Null steht, ist der
      Grauwert des Bildes $img1$ sichtbar, ansonsten die zum Wert aus $img2$
      gehörende Farbe. In der Reihenfolge OVERLAY, OVERLAY1, OVERLAY2, OVERLAY3
      steigt die Durchsichtigkeit des Overlays, so das das Grauwertbild unter
      den Markierungen erkannt werden kann.
    \end{minipage} \\ \hline
    \_RGB & 
    \begin{minipage}{0.6\textwidth}
      Es wird ein Farbbild dargestellt, wobei die Bilder $img1$, $img2$ 
      und $img3$ als Rot-, Grün- und Blauauszug interpretiert werden.
    \end{minipage} \\ \hline
    OFF &
    \begin{minipage}{0.6\textwidth}
      Das Bild $img1$ und die zugehörigen Overlaybilder bzw. Farbauszüge werden von
      der Visualisierung abgemeldet. 
    \end{minipage} \\ \hline
  \end{tabular} 
}

\proch{int}{Show}{const ColorImage \& img, int mode=ON}{visual/ColorImage\_vis.h}
\descr{
Das Farbbild $img$ wird zur Visualisierung als Farbbild angemeldet ($mode=ON$) 
oder abgemeldet ($mode=OFF$).
}

\proch{int}{Zoom}{Image img,int val,int x,int y}{visual/visual.h}
\procf{int}{Zoom}{Image img}
\descr{Die Göße der Darstellung des Bildes $img$ wird geändert.
Wenn $val$ größer als Null ist, wird jeder Bildpunkt in $val$-facher 
Größe dargestellt. Wenn $val$ kleiner als Null ist, wird nur jeder 
$val$-te Bildpunkt dargestellt wird. 
}

\proch{int}{Cursor}{int mode,Image img,int x,int y}{visual/visual.h}
\descr{
Die Kursorkoordinaten für das Bild $img$ werden gesetzt und die Visualisierung
des Kursors kann ein- und ausgeschaltet werden. Der Kursor wird generell nur
dann sichtbar, wenn das Bild zur Darstellung angemeldet und die Darstellung
eingeschaltet ist. Der Modus kann durch Konstanten mit der folgenden Bedeutung
festgelegt werden.
\begin{tabular}{|c|l|} \hline
SET&
\begin{minipage}[t]{0.6\textwidth}
Der Kursor wird an der Stelle $(x,y)$ dargestellt. Ein evtl. vorher an anderer
Stelle des Bildes gesetzter Kursor wird vorher gelöscht.
\end{minipage}\\ \hline
OFF&
\begin{minipage}[t]{0.6\textwidth}
Der Kursor wird gelöscht, wobei aber die Koordinaten intern erhalten bleiben,
so daß der Kursor mit ON an gleicher Stelle wieder gesetzt werden kann.
\end{minipage}\\ \hline
ON&
\begin{minipage}[t]{0.6\textwidth}
Der Kursor wird dargestellt, wobei die intern verwalteten Koordinaten
verwendet werden.
\end{minipage}\\ \hline
\end{tabular}
}

\subsection{Farbtabellen}

Die Darstellung der Werte von Grauwert- und Overlaybildern kann durch
Farbtabellen beeinflußt werden. Für die Darstellung von Grauwerten werden
standardmäßig die verfügbaren Intensitätswerte den Werten von Null bis zum
größten zulässigen Grauwert linear zugeordnet. Wenn gleichzeitig Bilder mit
unterschiedlichem maximalem Grauwert dargestellt werden, kann das dazu führen,
daß die Bilder mit dem kleineren Grauwertumfang flau dargestellt werden.

Für die Overlaydarstellung sind den Werten 1\dots 8 die Farben rot, grün,
blau, gelb, rosa, cyan, purpur und braun zugeordnet. Bei höheren Werten
wiederholen sich diese Farben zyklisch. Die letzten drei Einträge der
Overlay-Farbtabelle legen die Farben für die Umrandung der Bilder und 
den Kursor fest.

\proch{int}{SetGreyColor}{int val,int red,int green,int blue}{visual/visual.h}
\descr{
Dem Grauwert $val$ wird ein Farbwert mit den Intensitäten $red$, $green$ und
$blue$ zugeordnet, die zwischen 0 und 255 liegen können.
}
\proch{int}{SetGreyLUT}{int val1,int val2}{visual/visual.h}
\descr{
Die verfügbaren Intensitäten werden linear den Grauwerten zwischen val1 und
val2 zugeordnet. Die unterhalb bzw. oberhalb dieses Intervalls liegenden
Grauwerte werden weiß bzw. schwarz dargestellt.
}
\proch{int}{SetOverlayColor}{int val,int red,int green,int blue}{visual/visual.h}
\descr{
Dem Overlay-Wert $val$ wird ein Farbwert mit den Intensitäten $red$, $green$ und
$blue$ zugeordnet, die zwischen 0 und 255 liegen können.
}

\subsection{Informationsabfrage zur Visualisierung}

Einige Eigenschaften der Bilddarstellung können in Abhängigkeit von der
Hardware und vom Betriebssystem unterschiedlich realisiert sein. Zur
Unterstützung einer portablen Programmierung werden durch die Funktion
InfVis() einige Information zur Bilddarstellung bereitgestellt.

\proch{int}{InfVis}{int code}{visual/visual.h}
\descr{
Es können Informationen zur Bilddarstellung abgefragt werden, die als
Funktionswert zurückgegeben werden. Als $code$
können die folgenden vordefinierten Konstanten verwendet werden:
}
\begin{quote}
\begin{tabular}{ll}
MAXX&
\begin{minipage}[t]{9cm}
x-Ausdehnung des Grafikbildschirms bzw. des Grafikfensters
\end{minipage}\\
MAXY&
\begin{minipage}[t]{9cm}
y-Ausdehnung des Grafikbildschirms bzw. des Grafikfensters
\end{minipage}\\
TABLE\_LEN&
\begin{minipage}[t]{9cm}
Anzahl der zur Verfügung stehenden Farbtabelleneinträge
\end{minipage}\\
REAL\_TIME\_COLOR&
\begin{minipage}[t]{9cm}
TRUE, wenn die Farbtabellen in Echzeit modifiziert werden können, sonst FALSE.
\end{minipage}\\
REAL\_TIME\_ZOOM&
\begin{minipage}[t]{9cm}
TRUE, wenn die Zoomfunktionen in Echzeit ausgeführt werden, sonst FALSE.
\end{minipage}\\
VIRTUAL\_X&
\begin{minipage}[t]{9cm}
Aktuelle x-Ausdehnung des virtuellen Bildspeichers.
\end{minipage}\\
VIRTUAL\_Y&
\begin{minipage}[t]{9cm}
Aktuelle y-Ausdehnung des virtuellen Bildspeichers.
\end{minipage}\\
IMAGES&
\begin{minipage}[t]{9cm}
Anzahl der zur Visualisierung angemeldeten Bilder. Bilder mit Overlay und
Echtfarbbilder werden jeweils als ein Bild gezählt.
\end{minipage}\\
\end{tabular}
\end{quote}

\subsection{Interaktive Auswahlfunktionen}

\proch{int}{Mouse}{Image img,int *x,int *y}{visual/mouse.h}
\procf{int}{Mouse}{Image img,int \&x,int \&y}
\descr{
Auf $x$ und $y$ werden die entsprechend den Mausbewegungen veränderten
Koordinaten eingetragen. Die Window-Systemen sind die Koordinaten an die
Position des System-Mauszeigers gekoppelt. Der Rückgabewert ergibt sich aus
einer ODER-Verknüpfung der Werte für die folgenden Mausereignisse:
}
\begin{quote}
\begin{tabular}{ll}
M\_LEFT\_DOWN&\begin{minipage}[t]{9cm}linke Maustaste ist gedrückt\end{minipage}\\
M\_RIGHT\_DOWN&\begin{minipage}[t]{9cm}rechte Maustaste ist gedrückt\end{minipage}\\
M\_MIDDLE\_DOWN&\begin{minipage}[t]{9cm}mittlere Maustaste ist gedrückt\end{minipage}\\
M\_LEFT\_PRESSED&\begin{minipage}[t]{9cm}linke Maustaste wurde seit der letzten
Abfrage gedrückt\end{minipage}\\
M\_RIGHT\_PRESSED&\begin{minipage}[t]{9cm}rechte Maustaste wurde seit der letzten
Abfrage gedrückt\end{minipage}\\
M\_MIDDLE\_PRESSED&\begin{minipage}[t]{9cm}mittlere Maustaste wurde seit der
letzten Abfrage gedrückt\end{minipage}\\
M\_LEFT\_RELEASED&\begin{minipage}[t]{9cm}linke Maustaste wurde seit der letzten
Abfrage losgelassen\end{minipage}\\
M\_RIGHT\_RELEASED&\begin{minipage}[t]{9cm}rechte Maustaste wurde seit der letzten
Abfrage losgelassen\end{minipage}\\
M\_MIDDLE\_RELEASED&\begin{minipage}[t]{9cm}mittlere Maustaste wurde seit der
letzten Abfrage losgelassen\end{minipage}\\
M\_MOVED&\begin{minipage}[t]{9cm}Maus wurde seit der letzten Abfrage bewegt\end{minipage}\\
\end{tabular}
\end{quote}

Die Funktionen zur interaktiven Auswahl eines Punktes werden wie folgt
bedient:\\
Im Bild $img$ wird bei eingeschalteter Visualisierung ein Kursor eingeblendet,
der mit der Maus bewegt werden kann. Bei $mode=1$ werden in einer Textzeile 
jeweils die aktuellen Koordinaten und der aktuelle Grauwert ausgegeben. 
Für $mode$=DEFAULT erfolgt keine Einblendung der Koordinaten. 
Durch Drücken der linken Maustaste oder \enter wird die Funktion beendet und 
der aktuelle Punkt ausgewählt. Wenn die rechte Maustaste gedrückt wird oder 
\esc, erfolgt ebenfalls ein Abbruch der Funktion.
Durch Drücken der Leertaste wird der sichtbare Bereich so verschoben, dass 
die aktuelle Kursorposition in der Mitte des Darstellungsfesters liegt. Durch
Drücken der ``+''-Taste bzw. der ``-''-Taste kann zusätzlich die Vergrößerung
eingestellt werden. Drücken von ``.'' stellt eine Vergrößerung ein, die das
gesamte Bild sichtbar macht.

\proch{int}{SelPoint}{int mode,const Image \&img,int p[2]}{visual/pointsel.h}
\descr{
Auswahl eines Punktes im Bild $img$ und Rückgabe der Koordinaten in $p$.
Der Rückgabewert ist der selektierte Grauwert oder -1 bei Abbruch mit rechter
Maustaste beziehungsweise \esc.
}

\proch{IPoint}{SelPoint}{int mode,const Image \&img}{visual/pointsel.h}
\procf{IPoint}{SelPoint}{int mode,const Image \&img,int \&rc}
\procf{Point}{SelPoint}{const Image \&img,int \&rc}
\procf{Point}{SelPoint}{const Image \&img}
\descr{
Auswahl eines Punktes im Bild $img$ und Rückgabe als \see{Point}. 
$rc$ enthält nach der Rückkehr den Grauwert an der ausgewählte Stelle oder -1
bei Abbruch mit rechter Maustaste oder \esc.
}

\proch{IVector}{SelVector}{int mode,const Image \&img,int \&rc}{visual/pointsel.h}
\procf{IVector}{SelVector}{int mode,const Image \&img}
\procf{IVector}{SelVector}{const Image \&img,int \&rc}
\procf{IVector}{SelVector}{const Image \&img}
\descr{
Auswahl eines Punktes im Bild $img$ und Rückgabe als \see{IVector}. 
$rc$ enthält nach der Rückkehr den Grauwert an der ausgewählte Stelle oder -1
bei Abbruch mit rechter Maustaste oder \esc.
}

\proch{int}{SelectWindow}{const Image \&img,int mode}{pointsel.h}
\descr{
In dem Bild $img$ wird bei eingeschalteter Visualisierung interaktiv mit der
Maus oder den Kursortasten ein Fenster festgelegt. Bei $mode$=0 kann das
vorher gesetzte Fenster lediglich verschoben werden, die Größe wird nicht
verändert. Mit $mode$=1 wird zunächst die linke obere Ecke angeklickt und dann
das Fenster ``aufgezogen''. Durch Drücken der rechten Maustaste oder \esc
wird die Funktion abgebrochen und das vorherige Fenster wieder gesetzt. Der
Rückgabewert ist in diesem Fall -1, sonst 0. Das folgende Programmbeispiel
demonstriert die Verwendung der Funktion.
}
\begprogr\begin{verbatim}
// Interaktive Fensterauswahl 
#include <stdio.h>
#include <image.h>
void main(void)
{
  int x,y;
  OpenAlpha("ICE Text Server");      // Textfenster
  SetAttribute(0,7,0,0);             // Attribute setzen
  ClearAlpha();                      // initialisieren 
  Image img=NewImg(768,512,255);     // Bilder anfordern
  Image imgo=NewImg(768,512,255);
  ClearImg(imgo);
  for (int y=0;y<img.ysize;y++)
    for (int x=0;x<img.xsize;x++)
      {
        PutVal(img,x,y,x&255);
        if (x & 8) PutVal(imgo,x,y,1);
      }  
  Show(OVERLAY, img, imgo);          // Bilddarstellung
  Display(ON);
  Printf("Linke obere Ecke anklicken und Fenster aufziehen\n");
  SelectWindow(img,1);               // Fenster "aufziehen" 
  Printf("Fenster verschieben                             \n");
  SelectWindow(img,0);               // Fenster verschieben
  Display(OFF);
}
\end{verbatim}\endprogr

 
\newpage
\makeatletter{}\nsection{Ein- und Ausgabe von Bilddaten}{imageio}

\subsection{Bild-Dateien}

Bilder können von Bildfiles in verschiedenen Formaten eingelesen und 
auch in diesen Formaten ausgegeben werden. Das Format
des Bildfiles wird anhand des Dateinamen erkannt:
\begin{itemize}
\item Hat die Datei die Standard-Namens-Endung (extension) für dieses 
Format, so wird dieser Typ angenommen.
\item Wenn die Datei eine andere Namens-Endung besitzt, kann der Typ
der Datei durch einen durch Doppelpunkt abgetrennten Vorsatz vor
dem Dateinamen angegeben werden.\\
\end{itemize}
Beispiel: Bei Angabe von $TIFF:test.jpg$ behandelt ICE die Datei als
Bild im TIF-Format, auch wenn die Erweiterung etwas anderes nahelegt.

\begin{tabular}{|l|c|c|c|c|} \hline
 Typ & Prefix & Extension & Grauwert & Farbe \\ \hline \hline
TIFF & TIF: & .tif & Ja & Nein \\ 
 & TIFF: & .tiff & & \\ \hline
JPEG & JPG: & .jpg & Ja & Ja \\ 
 & JPEG: & .jpeg & & \\ \hline
PCX & PCX: & .pcx & Ja & Nein \\ \hline
Targa & TGA: & .tga & Ja & Ja \\ \hline
Windows-Bitmap & BMP: & .bmp & Ja & Ja \\ \hline
Portable Bitmap & PBM: &  & Ja & Ja \\ \hline
 & PPM: & .ppm & Ja & Ja \\ \hline
 & PGM: & .pgm & Ja & Ja \\ \hline
Photoshop & PSD: & .psd & Ja & Ja \\ \hline
\end{tabular}

Beim Lesen von Bildern im Portablen Bitmap-Format (PBM) kann als weitere
Besonderheit direkt die Ausgabe eines Programmes eingelesen werden. Damit wird
es möglich, Programme wie $convert$ (ImageMagick) oder $dcraw$ zum Einlesen von
Fremdformaten zu verwenden:
\begin{verbatim}
ReadImg("PGM:|convert ente.ras PPM:-",img);
\end{verbatim}
Das pipe-Symbol '|' als erstes Zeichen des Dateinamen kennzeichnet den Aufruf
eines Programmes, hier $convert$. Der Aufruf von {\bf convert} mit
\verb+convert ente.ras PPM:-+ bewirkt die Konvertierung der Datei 
{\bf ente.ras} in eine portable Bitmap und deren Ausgabe auf der 
Standard-Ausgabe. ReadImg liest diese Ausgabe in das Bild img ein.
Dies kann auch dazu verwendet werden, mittels $scanimage$ (sane) Bilder von
Scannern einzulesen.
Eine weitere spezielle Möglichkeit ist das Einlesen eines Bildes von der
Standardeingabe. Dazu ist als Filename ''-'' einzugeben:
\begin{verbatim}
ReadImg("PGM:-",img);
\end{verbatim}
Ein Programm {\bf myprog}, welches auf diese Art ein Bild einliest, kann mit
\verb+convert ente.ras PPM:- | myprog+ aufgerufen werden.

\proch{Image}{ReadImg}{const string \&filename,Image \&img,int flag=IB\_SCALE}{picio.h}
\descr{
Von dem Bildfile $file$ wird ein Grauwert-Bild in $img$ eingelesen.
Überschreitet die Bildgröße in der Datei die Größe des Bildes $img$, so
wird je nach dem Wert von $flag$ das eingelesene Bild ganzzahlig skaliert
($flag=IB\_SCALE$) oder auf die Größe von $img$ beschnitten ($flag=IB\_CROP$).
Wenn die Grauwertbereiche nicht übereinstimmen, wird eine lineare 
Skalierung vorgenommen. Wird als Parameter $img$ ein ungültiges Bild
übergeben, so wird ein Bild in der passenden Größe angelegt.
}

\proc{int}{WriteImg}{const Image \&img,const string \&filename}
\descr{
Das Grauwertbild $img$ wird in die Datei $filename$ geschrieben.
}

\proc{int}{ReadImg}{const string \&file,Image \&imgr,Image \&imgg,Image \&imgb,
int flag=IB\_SCALE}
\descr{
Von dem Bildfile $file$ wird ein Farbbild eingelesen und die
Farbauszüge Rot, Grün und Blau werden in die Bilder $imgr$, $imgg$ und
$imgb$ eingetragen. Die Bilder $imgr$, $imgg$ und $imgb$ müssen die
gleiche Größe besitzen.  Überschreitet die Bildgröße in der Datei 
die Größe der Bilder $imgr$, $imgg$ und $imgb$, so
wird je nach dem Wert von $flag$ das eingelesene Bild ganzzahlig skaliert
($flag=IB_SCALE$) oder auf die notwendige Größe beschnitten ($flag=IB_CROP$).
Wenn die Grauwertbereiche nicht übereinstimmen, wird eine lineare 
Skalierung vorgenommen. Wenn statt der Bilder $imgr$, $imgg$ und $imgb$ 
der Null-Pointer übergeben wird, wird ein Bild in der passenden Größe 
angelegt.
}
\proc{int}{WriteImg}{const Image \&ir,const Image \&ig,const Image \&ib,const string \&filename}
\descr{
Das durch die Farbauszüge in den Bildern $ir$, $ig$ und $ib$ übergebene
Farbbild wird in die Datei $filename$ ausgeschrieben.
}

\proc{int}{InfImgFile}{const string \&filename, int \&xsize, int \&ysize, 
  int \&maxval,int \&nr}
\procf{int}{InfImgFile}{const string \&filename, int \&xsize, int \&ysize, 
  int \&maxval}
\descr{
  Die Informationen zum Bildfile $filename$ werden ermittelt. Zurückgegeben
  werden die Bildgröße ($xsize$,$ysize$), der Grauwertumfang ($maxval$) und 
  die Zahl der Teilbilder bzw. Farbebenen ($nr$).
}

\subsection{Video-Dateien}
\label{VideoFile}
\hypertarget{VideoFile}
Bildsequenzen können aus Video-Dateien gelesen und in Video-Dateien 
geschrieben werden. Voraussetzung dafür ist die Installation der 
Bibliothek \verb+libffmpeg+.

Video-Dateien können nur streng sequentiell gelesen und geschrieben
werden. Dazu muss ein \class{VideoFile} angelegt werden. Dabei kann 
bereits beim Anlegen der Name angegeben werden und die Entscheidung 
über Lesen oder Schreiben gefällt werden. Wenn dies nicht hier 
erfolgt, muss die Datei später mit \bsee{VideoFile::open} geöffnet werden. 

Danach kann fortlaufend aus der Datei gelesen werden
(\bsee{VideoFile::Read}) oder in die Datei geschrieben werden 
(\bsee{VideoFile::Write}). 
Die Datei wird im Destruktor von \class{VideoFile} automatisch geschlossen.

Das Setzen von Parametern mit \bsee{VideoFile::setPara}
und \bsee{VideoFile::setCPara} ist nur vor dem ersten Schreiben möglich.

\proch{}{VideoFile::VideoFile}{}{videoio.h}
\descr{Standard-Konstruktor. Die Datei muss mit \bsee{VideoFile::open} 
geöffnet werden.}

\proc{}{VideoFile::VideoFile}{const string \&fn,ios\_base::openmode mode =
  ios\_base::in}
\descr{
Konstruktor, der den Dateinamen und die Schreib-Lese-Richtung
festlegt: Lesen - ios\_base::in, Schreiben - ios\_base::out. 
}

\proc{int}{VideoFile::open}{const string \&fn,ios\_base::openmode mode =
  ios\_base::in}
\descr{Legt den Dateinamen und die Schreib-Lese-Richtung fest: Lesen -
  ios\_base::in, Schreiben - ios\_base::out. }

\proc{void}{VideoFile::getPara}{int \&xs,int \&ys,int \&mv,int \&fps}
\descr{Fragt die Parameter Bildgröße (x,y), maximaler Grauwert und
  Bildfrequenz (fps) einer Video-Datei ab. Die Werte sind bei einer 
  zu lesenden Datei nach dem Öffnen gültig.}

\proc{void}{VideoFile::setPara}{int xs,int ys,int mv,int fps,int bitrate=0}
\descr{Legt die Parameter einer zu schreibenden Video-Datei fest. Dies muss
  vor dem ersten Schreibvorgang mit \bsee{VideoFile::Write} erfolgen. Die 
Bildgröße $x*y$ muss exakt der Größe der zu schreibenden Bilder entsprechen.
Als maximaler Grauwert ist z.Z. nur der Wert 255 möglich. Die Bitrate 
$bitrate$ (Bit pro Sekunde) kann auch mit dem Wert 0 vorgegeben werden. Dann 
wird ein geeigneter Wert aus Bildgröße und Framerate $fps$ ermittelt. }

\proc{void}{VideoFile::setCPara}{const string \&p}
\descr{Definiert optional für Ausgabe-Dateien einen Kompressionstyp.
Die zu verwendenden Kürzel entsprechen der Codec-Kennung in der 
libffmpeg oder dem MIME-Type der Dateien. Wird dies nicht gesetzt, wird 
der Dateityp aus der Datei-Erweiterung ermittelt.}

\proc{bool}{VideoFile::Read}{Image \&img,int ch=3}
\procf{bool}{VideoFile::Read}{Image \&ir,Image \&ig,Image \&ib}
\procf{bool}{VideoFile::Read}{ColorImage \&irgb}
\descr{Liest ein Bild aus einer Video-Datei. Die Methode gibt bei Erfolg
den Wert {\bf true} zurück.\\
Beim Lesen eines Grauwertbildes kann mittels des Parameters $ch$ entschieden 
werden, welcher Kanal in das Bild $img$ geschrieben wird.\\
\begin{tabular}{ll}
ch = 0 & Rot \\
ch = 1 & Grün \\
ch = 2 & Blau \\
ch = 3 & Grauwert aus R, G und B\\
\end{tabular}
}

\proc{bool}{VideoFile::Write}{const Image \&img}
\procf{bool}{VideoFile::Write}{const Image \&ir,const Image \&ig,const Image \&ib}
\procf{bool}{VideoFile::Write}{const ImageRGB \&irgb}
\descr{Schreibt ein Bild in eine Video-Datei.}

Im folgendem Beispiel wird eine Video-Datei ''kopiert'': Wegen der Dekodierung
beim Lesen und neuen Kodierung beim Schreiben ist dies keine echte Kopie.
\begprogr
\begin{verbatim}
void Copy(const string &infilename, const string &outfilename)
{
 VideoFile in(infilename,ios_base::in);
 VideoFile out(outfilename,ios_base::out);

 int xs, ys, mv, fps;
 in.getPara(xs, ys, mv, fps); // Parameter der Quelldatei abfragen

 out.setPara(xs, ys, mv, fps); // Parameter der Zieldatei setzen

 ColorImage rgb;

 while (in.Read(rgb))
 {
     out.Write(rgb);
 }
// Schließen der Dateien erfolgt im Destruktor 
// von in und out
}
\end{verbatim}
\endprogr

\subsection{Datei-Eingabe-Puffer (Template)}

Die Templates \verb+ReadImageCache+ und \verb+ReadColorImageCache+ 
ermöglichen die Pufferung der Eingabe aus einer Quelle, die Bilder 
sequentiell liest (typisch für \bsee{VideoFile}).
Der Puffer ermöglicht in begrenztem Umfang, in der Eingabedatei 
vorwärts und rückwärts zu gehen.

Die Templates erfordern als Template-Parameter eine Klasse, die eine 
Methode zum sequentiellen Lesen von Bildern besitzt.

\begin{tabular}{ll}
\verb+ReadImageCache<T>+&\verb+Read(const Image &img)+ \\
\verb+ReadColorImageCache<T>+&\verb+Read(const Image &imgr,const Image &imgg,const Image &imgb)+ \\
\end{tabular}

\proch{}{ReadImageCache$<$T$>$::ReadImageCache}{T \&tr,int xsize,int ysize,int maxval,int csize}{readcache.h}
\procf{}{ReadColorImageCache$<$T$>$::ReadColorImageCache}{T \&tr,int xsize,int ysize,int maxval,int csize}
\descr{Legt einen ReadImageCache an. Es müssen die Quelle $tr$ für das Lesen, die Parameter der
zu lesenden Bilder $xsize$, $ysize$, $maxval$ und die Cache-Größe $csize$ angegeben werden.
Die Quelle muss für die Lebensdauer des Caches existieren.}

\proc{bool}{ReadImageCache$<$T$>$::Read}{const Image \&img,int frame=ReadImagCache$<$T$>$::next}
\procf{bool}{ReadColorImageCache$<$T$>$::Read}{const ColorImage \&img,int frame}
\procf{bool}{ReadColorImageCache$<$T$>$::Read}{const Image \&imgr,const Image \&imgg,const Image \&imgb,int frame}
\descr{Liest den Frame $frame$ ein. Der Rückgabewert signalisiert, ob das 
Einlesen efolgreich war.
Die Framenummer ist eine nichtnegative Zahl, die die Nummer des Frames 
in der Quelle darstellt. Die speziellen Werte ReadImageCache$<$T$>$::next 
und ReadImageCache$<$T$>$::prev spezifizieren den nächsten 
beziehungsweise vorigen Frame (bezogen auf die vorherige Lese-Operation).}

\proc{int}{ReadImageCache$<$T$>$::FrameNumber}{}
\proc{int}{ReadColorImageCache$<$T$>$::FrameNumber}{}
\descr{Liefert die Nummer des zuletzt erfolgreich gelesenen Frames.}

\proc{int}{ReadImageCache$<$T$>$::getError}{}
\proc{int}{ReadColorImageCache$<$T$>$::getError}{}
\descr{Gibt das Ergebnis des letzten Lesevorganges an.}
\begin{tabular}{ll}
Fehlerwert&Bedeutung\\
\verb+ReadImageCache<T>::no_error+&Kein Fehler \\
\verb+ReadImageCache<T>::before+&Lesen vor Anfang des Puffers \\
\verb+ReadImageCache<T>::past_eof+&Lesen nach Dateiende \\
\end{tabular}

\begprogr
\begin{verbatim}
...
  VideoFile vi("test.mpg",ios::in);

  int xs,ys,mv,fps;
  vi.getPara(xs,ys,mv,fps);

  ReadImageCache cvi(vi,xs,ys,mv,300);

  Image img=NewImg(xs,ys,mv);
  Show(ON,img);

  cvi.Read(img); // ersten Frame lesen
  int c;
  while ((c=GetChar())!='x')
    {
      switch(c)
        {
        case 'n': vi.Read(img, cvi.next); break;
        case 'p': vi.Read(img, cvi.prev); break;
        }
      Printf("Aktueller Frame:     }
...
\end{verbatim}
\endprogr

\subsection{Gepufferte Video-Dateien}
\label{VideoFileCached}
\hypertarget{VideoFileCached}{}
Gepufferte Video-Dateien lockern die Beschränkung der Video-Dateien 
({\see{VideoFile}) auf rein sequentiellen Zugriff. 
Im Rahmen der Größe des Puffers ist es in einer gepufferten Video-Datei 
auch möglich, rückwärts zu gehen. Gepufferte Video-Dateien können nur 
gelesen werden.

\proch{}{VideoFileCached::VideoFileCached}{const string \&fn,int buffersize}{videoio.h}
\descr{Konstruktor, der den Dateinamen und die Puffergröße festlegt und die 
Video-Datei öffnet. Die Puffergröße ist die Zahl der gespeicherten 
Bilder/Frames. Diese bestimmt, wieweit in der Datei rückwärts gegangen werden kann.}

\proc{void}{VideoFileCached::getPara}{int \&xs,int \&ys,int \&mv,int \&fps}
\descr{Fragt die Parameter Bildgröße (x,y), maximaler Grauwert und
  Bildfrequenz (fps) einer gepufferten Video-Datei ab.}

\proc{bool}{VideoFileCached::Read}{Image \&ir,Image \&ig,Image \&ib,int frame=VideoFileCached::next}{videoio.h}
\procf{bool}{VideoFileCached::Read}{ColorImage \&img,int frame=VideoFileCached::next}
\procf{bool}{VideoFileCached::Read}{ImageRGB \&img,int frame=VideoFileCached::next}
\descr{Liest ein Bild aus einer Video-Datei. Die Methode gibt bei Erfolg den Wert {\bf true} zurück.
Die Framenummer ist eine nichtnegative Zahl, die die Nummer des Frames 
in der Videodatei darstellt. Die speziellen Werte 
VideoFileCached::next und VideoFileCached::prev spezifizieren den nächsten 
beziehungsweise vorigen Frame (bezogen auf die vorherige Lese-Operation).}

\proc{int}{VideoFileCached::FrameNumber}{}
\descr{Liefert die Nummer des zuletzt erfolgreich gelesenen Frames.}

\proc{int}{VideoFileCached::getError}{}
\descr{Gibt das Ergebnis des letzten Lesevorganges an.}
\begin{tabular}{ll}
Fehlerwert&Bedeutung\\
\verb+ReadImageCache<T>::no_error+&Kein Fehler \\
\verb+ReadImageCache<T>::before+&Lesen vor Anfang des Puffers \\
\verb+ReadImageCache<T>::past_eof+&Lesen nach Dateiende \\
\end{tabular}

Beispiel:
\begprogr
\begin{verbatim}
...
  VideoFileCached vi("test.mpg",100);
  int xs,ys,mv,fps;
  vi.getPara(xs,ys,mv,fps);
  Image ri=NewImg(xs,ys,mv);
  Image gi=NewImg(xs,ys,mv);
  Image bi=NewImg(xs,ys,mv);
  Show(_RGB,ri,gi,bi);
  vi.Read(ri,gi,bi); // ersten Frame lesen
  int c;
  while ((c=GetChar())!='x')
    {
      switch(c)
        {
        case 'n': vi.Read(ri, gi, bi, vi.next); break;
        case 'p': vi.Read(ri, gi, bi, vi.prev); break;
        }
      Printf("Aktueller Frame:     }
...
\end{verbatim}
\endprogr

\subsection{Bildaufnahme}

Wenn entsprechende Hardware vorhanden ist, können Bilder digitalisiert
(abgetastet) werden. Die auf dem jeweiligen Rechner vorhandenen
Eingabemöglichkeit werden als Kanäle konfiguriert und beim Funktionsaufruf 
durch eine Kanalnummer unterschieden.

\proch{void}{ScanWindow}{int ch,int x1,int y1,int x2,int y2}{scan.h}
\descr{
Für den Kanal $ch$ wird ein Ausschnitt für die Bildabtastung festgelegt. 
Die Koordinaten $(x1,y1)$ und $(x2,y2)$ geben die linke obere und die rechte 
untere Ecke des festzulegenden Bildausschnitts an. Der Bildauschnitt bezieht 
sich immer auf die Bildgröße des Eingabe-Gerätes.
}

\proc{int}{ScanImg}{int ch,Image \&pi,int interactive=TRUE}
\descr{
Es wird ein Bild vom Kanal $ch$ abgetastet. Bei $interactive$=TRUE wird vor 
dem eigentlichen Abtasten auf eine Bestätigung durch Tastendruck gewartet, 
so daß z.B. die Kameraeinstellung noch korrigiert werden kann. Bei 
$mode$=FALSE wird sofort abgetastet.
}

\proc{int}{ScanImg}{int ch,Image \&pr,Image \&pg,Image \&pb,int interactive=TRUE}
\descr{
Es wird ein Farb-Bild vom Kanal $ch$ abgetastet und die Farbauszüge in den
Bildern $pr$, $pg$ und $pb$ abgespeichert. Bei $interactive$=TRUE wird vor 
dem eigentlichen Abtasten auf eine Bestätigung durch Tastendruck gewartet, 
so daß z.B. die Kameraeinstellung noch korrigiert werden kann. 
Bei $mode$=FALSE wird sofort abgetastet.
}

\proc{int}{ScanInfo}{int ch,int \&xm,int \&ym,int \&maxval,int \&channels,
            int \&flags,string \&descr}
\descr{
Es werden grundlegende Informationen über den Kanal $ch$ bereitgestellt.
\begin{itemize}
\item xm,ym,maxval - Größe und maximaler Grauwert des abgetasteten Bildes
\item channels - Zahl aller Kanäle (ist unabhängig vom angegebenen Kanal)
\item flags - Eigenschaften des Kanals
\item descr - textuelle Beschreibung des Kanals
\end{itemize}
Die Werte für Bildgröße und maximalen Grauwert können den Wert -1 zurückgeben,
wenn der Treiber vor dem eigentlichen Scan-Vorgang keine Information darüber
besitzt.\\
Folgende Bit-Werte werden (wenn vorhanden) in der Variable $flag$ ODER-verknüpft:
\begin{tabular}{|l|c|c|} \hline
 SC\_SCAN & 1 & Es können Bilder aufgenommen werden \\  \hline
 SC\_RGB & 2 & Es können Farb-Bilder aufgenommen werden \\ \hline
 SC\_PREVIEW & 4 & Es gibt eine Vorschau-Funktion \\ \hline
 SC\_DIALOG & 8 & Es gibt einen interaktiven Einstellungs-Dialog \\ \hline
 SC\_EXTDATA & 16 & Es können Parameter eingestellt werden \\ \hline
\end{tabular} \\
{\it Es sollten nur die symbolischen Konstanten der ersten Spalte verwendet werden,
die konkreten Werte in der zweiten Spalte dienen nur der Information und können sich ändern.}
}

\subsubsection{Konfiguration der Bildaufnahme unter Unix/Linux}
Die Konfiguration der Bildaufnahme erfolgt durch Setzen von
Environment-Variablen. Die Variablen ICESCANDEVICE0 .. ICSCANDEVICE9
korrespondieren mit den 10 möglichen Kanälen 0..9. Die Einträge haben die
folgende Form:
\begin{verbatim}
ICESCANDEVICE0=fw,0,MODE_640x480_YUV422,30
\end{verbatim}
Der erste Wert (hier: fw) spezifiziert die Art des Eingabe-Gerätes, den
zuständigen Treiber, die darauffolgenden Parameter sind jeweils
Geräte-spezifisch.

\begin{itemize}
\item {\bf fw} - IEEE1394-Kameras (IIDC-kompatibel)
\begin{verbatim}
ICESCANDEVICE0=fw,0,MODE_640x480_YUV422,30
\end{verbatim}
Die Parameter nach {\bf fw} haben die folgende Bedeutung:
\begin{itemize}
\item Nummer der Kamera\\
Die vorhandenen Kameras werden von 0 an durchnummeriert.
\item Modus\\
Modus, in dem die Kamera betrieben werden soll.
\item Bildwiederhol-Rate\\
Die Bildwiederhol-Rate in fps (Frames per second).
\end{itemize}

\item {\bf file} - Einlesen von einer Datei
\begin{verbatim}
ICESCANDEVICE0=file,/tmp/img.jpg,640,480,255
\end{verbatim}
Der erste Parameter nach der Kennung {\bf file } gibt den Namen der Datei an. 
Die folgenden optionalen Parameter beschreiben die Bildgröße (x,y) und den 
maximalen Grauwert. Werden diese nicht angegeben, so werden sie zur Laufzeit 
aus der Bilddatei ermittelt, was allerdings zeitaufwendiger ist.

\item {\bf program} - Ein Programm, welches eine Bilddatei bereitstellt
\begin{verbatim}
ICESCANDEVICE0=program,igen /tmp/x.jpg,/tmp/x.jpg,640,480,255
\end{verbatim}
Die Parameter nach {\bf program} haben die folgende Bedeutung:
\begin{itemize}
\item Programmaufruf\\
Aufruf des Programmes mit Parametern.
\item Bilddateiname\\
Name der erstellten Bilddatei.
\end{itemize}
Die folgenden optionalen Parameter beschreiben die Bildgröße (x,y) und 
den maximalen Grauwert. Werden diese nicht angegeben, so werden sie 
vom System als ``unbekannt'' gemeldet. Es ist dann Sache des
Anwendungsprogrammes, eine geeignete Bildgröße zu wählen.

\end{itemize}
 
\newpage
\makeatletter{}\nsection{Grundlegende Datenstrukturen}{datastructures}
\subsection{Punkte - Datenstrukturen Point und IPoint}
\hypertarget{Point}{}
\hypertarget{IPoint}{}
Die Klassen \class{Point} und \class{IPoint} beschreiben Punkte der 
Ebene durch ihre Koordinaten. \class{Point} speichert die Koordinaten 
als {\bf double}-Werte, \class{IPoint} als {\bf int}-Werte. Oft werden 
Punkte auch als 2D-Vektoren aufgefasst.

Für einen sehr schnellen Zugriff sind die Instanz-Variablen $x$ und $y$ von 
aussen zugreifbar. Da \class{Point} und \class{IPoint} als 
Spezialisierungen einer Template-Klasse implementiert sind, gelten die 
folgenden Methoden für beide Klassen, auch wenn hier jeweils nur 
\class{Point} genannt ist.

Konstruktoren

\ctor{Point}{}{point.h}
\descr{Standard-Konstruktor. Die Koordinaten werden mit 0 initialisiert.}

\ctor{Point}{double x, double y}{point.h}
\descr{Die Koordinaten werden mit $(x,y)$ initialisiert.}

\ctor[explicit]{Point}{const Vector \&v}{point.h}
\descr{Legt eine Datenstruktur Point an und initialisiert $x$ und $y$ mit den
ersten beiden Werten des \see{Vector} v.}

\ctor[explicit]{Point}{const IVector \&v}{point.h}
\descr{Legt eine Datenstruktur Point an und initialisiert $x$ und $y$ mit den
ersten beiden Werten des \see{IVector} v.}

\ctor[explicit]{Point}{double d[]}{point.h}
\descr{Legt eine Datenstruktur Point an und initialisiert $x$ und $y$ mit den
ersten beiden Werten des Feldes d. }

Zugriffsmethoden

\method{double}{X}{}
\methodf{double}{Y}{}
\descr{Lesender Zugriff auf die Koordinatenwerte.}

Operatoren

\method{bool}{operator ==}{const Point \&p}
\methodf{bool}{operator !=}{const Point \&p}
\descr{Test zweier Punkte auf Gleichheit/Ungleichheit.}

\method{Point}{operator +}{const Point \&p}
\methodf{Point}{operator +=}{const Point \&p}
\descr{Komponentenweise Summe zweier Punkte.}

\method{Point}{operator -}{const Point \&p}
\methodf{Point}{operator -=}{const Point \&p}
\descr{Komponentenweise Differenz zweier Punkte.}

\method{Point}{operator *}{double f}
\methodf{Point}{operator *=}{double f}
\descr{Produkt mit Zahl $f$.}

\method{double}{operator *}{Point second}
\descr{Skalarprodukt zweier Punkte}

\method{Point}{operator /}{double d}
\methodf{Point}{operator /=}{double d}
\descr{Quotient mit Zahl $d$.}

Methoden

\method{int}{Shift}{double dx,double dy}
\descr{Verschiebt den Punkt um $(dx,dy)$.}

\method{double}{r}{}
\methodf{double}{phi}{}
\descr{Polarkoordinaten-Darstellung}

\method{Point}{normalized}{}
\descr{Liefert den normalisierten Vektor.}

\subsection{Walker Klassenhierarchie}
\hypertarget{Walker}{}

Walker verwenden eine ähnliche Idee wie die Iteratoren in der STL. 
Während Iteratoren das Fortschreiten über die Elemente eines 
Containers mittels der Operatoren ++ und -- organisieren, 
wird die Klasse \class{Walker} verwendet, um damit eine Sequenz 
von Punktkoordinaten zu erzeugen und damit Pfade beziehungsweise 
Flächen (im Bild) abzulaufen.

Die Klasse \class{Walker} ist von \class{IPoint} abgeleitet. Eine 
Instanz von \class{Walker} kann deshalb direkt anstelle 
eines \class{IPoint} verwendet werden, um zum Beispiel Koordinaten 
im Bild zu adressieren.

Die Klasse Walker verfügt über Methoden, um das ``Wandern durchs Bild''
zu organisieren. 
\see{Walker::init()} setzt den \class{Walker} auf den Ausgangspunkt zurück, 
\see{Walker::next()} setzt auf den nächsten Punkt.
Mittels \see{Walker::ready()} kann abgefragt werden, ob das Ende des 
Pfades erreicht ist.

Durch Rücksetzen mit \see{Walker::init()} kann ein Walker mehrfach 
verwendet werden. \see{Walker::moveTo()} verschiebt den 
Walker auf eine neue Position. Bezug ist dabei der Referenz-Punkt, 
dessen genaue Lage von der Art des Walkers abhängt. Zum Beispiel ist 
bei Konturen der Referenzpunkt der Startpunkt, bei 
Nachbarschafts-Walkern ist der zentrale Ausgangspunkt Referenzpunkt.

Die Klasse \class{Walker} ist eine abstrakte Basisklasse, von der 
sich eine Klassen-Hierarchie ableitet:

\begin{itemize}
\item \class{Walker} Abstrakte Basisklasse, abgeleitet von \class{IPoint}
\begin{itemize}
\item \class{WindowWalker} Walker über ein Fenster im Bild.
\item \class{PointListWalker} Walker über eine Punktliste, typisch genutzt für Pfade
\item \class{RegionWalker} Walker über eine Region, nutzbar für Flächen
\end{itemize}
\end{itemize}

Eine typische Anwendung eines Walkers zeigt das Beispiel, das eine
Region in ein Bild einzeichnet (analog \see{Region::draw()}):

\begin{verbatim}
Region region = ... ;
RegionWalker rw(region);
for (rw.init(); ! rw.ready(); rw.next())
    img.setPixel(rw, img.maxval);
\end{verbatim}

\subsubsection{Walker}
Die Klasse \class{Walker} ist eine abstrakte Basisklasse für alle in
ICE implementierten Walker. Sie ist ihrerseits abgeleitet von 
\class{IPoint}.

\ctor{Walker}{}{Walker.h}
\ctorf{Walker}{IPoint p}
\ctorf{Walker}{int x, int y}
\descr{Konstruiert einen Walker, dessen Referenzpunkt im Ursprung (0,0)
beziehungsweise im gegebenen Punkt liegt.}

\method{void}{moveTo}{IPoint p}
\descr{Verschiebt den Walker. 
Dabei wird der Referenzpunkt in den Punkt $p$ verschoben. 
Schließt den Aufruf von \see{Walker::init()} ein.}

\method{void}{init}{}
\descr{Setzt Walker auf Anfangspunkt.}

\method{void}{next}{}
\descr{Setzt Walker auf nächsten Punkt. Wird beim Weitersetzen 
das Ende des Pfades {\bf überschritten}, wird ready 
auf true gesetzt und der aktuelle Punkt gehört nicht mehr zum Pfad.}

\method{void}{next}{int steps}
\descr{Setzt Walker um $steps$ Schritte weiter. 
Wird beim Weitersetzen das Ende des Pfades {\bf überschritten}, 
wird ready auf true gesetzt und der aktuelle Punkt 
gehört nicht mehr zum Pfad.}

\method{bool}{ready}{}
\descr{Gibt zurück, ob der Pfad abgelaufen ist.}

\subsubsection{WindowWalker}
\hypertarget{WindowWalker}{}
Die Klasse \class{WindowWalker} ist ein \class{Walker}, der alle
Punkte eines Fensters (\see{Window}) durchläuft.

\ctor{WindowWalker}{const Window \&w}{Walker.h}
\descr{Legt einen Walker für das Fenster w an. Referenzpunkt des 
Walkers ist die linke obere Ecke des Fensters.}

\ctor{WindowWalker}{const Image \&img center}{Walker.h}
\descr{Legt einen Walker für das Bild img an. Referenzpunkt des 
Walkers ist der Punkt (0,0).}

\ctor{WindowWalker}{IPoint center, int sizex, int sizey = -1}{Walker.h}
\descr{Legt einen Walker für ein Fenster um den Punkt center an. Das Fenster
hat die Breite sizex und die Höhe sizey. Wird sizey weggelassen oder 
ist sizey gleich -1, ist das Fenster quadratisch mit der Größe sizex.
Der Referenzpunkt des Walkers ist das Zentrum des Fensters.}

\seebaseclass{Walker}

\subsubsection{PointListWalker}
\hypertarget{PointlistWalker}{}
Die Klasse \class{WindowWalker} ist ein \class{Walker}, der alle in
einer Punktliste enthaltenen Punkte durchläuft. 
\ctor{PointListWalker}{}{PointListWalker.h}
\descr{Standard-Konstruktor. Bevor dieser Walker nutzbar ist, muss er mit
\see{PointListWalker::setPointList} initialisiert werden.}

\ctor{PointListWalker}{IPoint p}{PointListWalker.h}
\descr{Konstruktor, der nur den Referenzpunkt setzt. 
Bevor dieser Walker nutzbar ist, muss er mit 
\see{PointListWalker::setPointList} initialisiert werden.}

\ctor{PointListWalker}{const \vector{IPoint} \&pl,int idx = 0}{PointListWalker.h}
\descr{Der Walker wird mit der gegebenen Punktliste initialisiert. Mittels
des Parameters idx kann ein Start-Index gewählt werden. Ist idx ungleich Null
arbeitet der Walker zyklisch vom Index idx bis zum Index idx-1.
Der Referenzpunkt des Walkers wird auf den Punkt pl[idx] gesetzt.}

\ctor{PointListWalker}{const Contur \&c}{PointListWalker.h}
\descr{Ein Walker wird mit den Konturpunkten der Contur c erzeugt.}

\method{void}{setPointList}{const \vector{IPoint} \&v,int idx = 0}
\descr{Der Walker wird mit der gegebenen Punktliste initialisiert. Mittels
des Parameters idx kann ein Start-Index gewählt werden. Ist idx ungleich Null
arbeitet der Walker zyklisch vom Index idx bis zum Index idx-1.
Der Referenzpunkt des Walkers wird auf den Punkt pl[idx] gesetzt.
Der Aufruf dieser Methode impliziert eine Neuinitialisierung.}

\method{void}{setStartIndex}{int idx = 0}
\descr{Setzt den als Start zu verwendenden Index. Ist idx ungleich Null
arbeitet der Walker zyklisch vom Index idx bis zum Index idx-1.
 Der Aufruf dieser Methode impliziert eine Neuinitialisierung.}

\seebaseclass{Walker}

\subsubsection{Nachbarschafts-Walker}
\hypertarget{Neighbor8Walker}{}
\hypertarget{Neighbor4Walker}{}

Die Klassen \class{Neighbor4Walker} und \class{Neighbor8Walker} 
erzeugen Walker, die die Vierer- bzw Achter-Nachbarschaft eines 
gegebenen Punktes durchlaufen.

\ctor{Neighbor4Walker}{IPoint p}{PointListWalker.h}
\descr{Erzeugt einen Walker, der die Punkte in der Vierer-Nachbarschaft
des Punktes p durchläuft. Referenzpunkt ist der Punkt p.}

\ctor{Neighbor8Walker}{IPoint p}{PointListWalker.h}
\descr{Erzeugt einen Walker, der die Punkte in der Achter-Nachbarschaft
des Punktes p durchläuft. Referenzpunkt ist der Punkt p.}

\seebaseclass{Walker}\\
\seebaseclass{PointListWalker}

\subsubsection{RegionWalker}
\hypertarget{RegionWalker}{}

Ein \class{RegionWalker} durchläuft eine Region, die zum Beispiel durch
eine Instanz der Klasse \class{Region} oder eine Kontur (\class{Contur})
bestimmt wird. 

\ctor{RegionWalker}{const Region \&region}{RegionWalker.h}
\descr{Legt einen RegionWalker für die Region region an. Dieser 
RegionWalker durchläuft alle Punkte der Region.}

\ctor{RegionWalker}{const Contur \&contur}{RegionWalker.h}
\descr{Legt einen RegionWalker an, der das durch die Punkte des durch die
\class{Contur} bestimmten Objektes durchläuft.}

\seebaseclass{Walker}

\subsection{Point3d, Vector3d, IPoint3d und IVector3d}
\hypertarget{Point3d}{}
\hypertarget{Vector3d}{}
\hypertarget{IPoint3d}{}
\hypertarget{IVector3d}{}
Die Klassen \class{Point3d},\class{Vector3d}, \class{IPoint3d} 
und \class{IVector3d} dienen der Repräsentation von Raumpunkten. 
Die Begriffe {\bf Vector} und {\bf Point} sind hier gleichwertig 
und können synonym verwendet werden, im folgenden verwenden wir nur 
\class{Vector3d}. 
\class{IPoint3d} und \class{IVector3d} repräsentieren Raumpunkte durch 
ganzzahlige Koordinaten,  \class{Point3d} und \class{Vector3d} 
dagegen Koordinaten vom Typ {\bf double}. Die folgende Beschreibung 
verwendet \class{Vector3d} als Typangabe, \class{IVector3d} verhält 
sich entsprechend.

Für einen sehr schnellen Zugriff sind die Instanz-Variablen 
$x$, $y$ und $z$ von außen zugreifbar. 

Operatoren und Konstruktoren ermöglichen eine problemlose Umwandlung 
von \class{Vector3d} in \class{Vector} und umgekehrt.

Konstruktoren:

\proch{}{Vector3d::Vector3d}{}{point3d.h}
\descr{Legt einen Punkt im Ursprung an.}

\proc{}{Vector3d::Vector3d}{const Vector3d \&p}
\procf{}{Vector3d::Vector3d}{double xp,double yp,double zp}
\descr{Legt einen Punkt mit der gegebenen Position an.}

\proc{explicit}{Vector3d::Vector3d}{const Vector \&v}
\procf{explicit}{Vector3d::Vector3d}{const IVector \&v}
\procf{explicit}{Vector3d::Vector3d}{double p[]}
\descr{Legt einen Punkt mit der gegebenen Position an. Zur Vermeidung 
ungewollter Konvertierungen muss der Aufruf explizit erfolgen.}

Operatoren:
\begin{center}
\begin{tabular}{ccc@{=}c}
Vector3d & + & Vector3d & Vector3d\\
Vector3d & - & Vector3d & Vector3d\\
 & - & Vector3d & Vector3d\\
Vector3d & * & Vector3d & double \\
double & * & Vector3d & Vector3d \\
Vector3d & * & double & Vector3d \\
\end{tabular}
\end{center}

Methoden:

\proc{Vector}{Vector3d::operator Vector}{}
\descr{Typwandlung in $Vector$.}

\proc{Vector3d}{Vector3d::Normalized}{}
\descr{Gibt einen normalisierten Vektor (der Länge 1) zurück.}

\proc{void}{Vector3d::Normalize}{}
\descr{Normalisiert den Vektor.}

\subsection{Window}
\hypertarget{Window}{}

Die Klasse \class{Window} beschreibt ein rechteckiges achsparalleles 
Fenster anhand der linken oberen und der rechten unteren Ecke bzw. 
der minimalen und maximalen Koordinaten-Werte in X- und Y-Richtung.

Konstruktoren

\proch{}{Window::Window}{}{window.h}
\descr{Standard-Konstruktor. Die Koordinaten werden mit 0 initialisiert.}

\proch{}{Window::Window}{int x1,int y1,int x2,int y2}{window.h}
\descr{Die linke obere Ecke wird mit $(x1,y1)$, die rechte untere Ecke mit
  $(x2,y2)$ initialisiert.}

Zugriffs-Methoden

\proch{int}{Window::Width}{}{window.h}
\procf{int}{Window::Height}{}
\descr{Die Methoden geben die Breite bzw. die Höhe des Fensters zurück.}

\proch{int}{Window::GetLeft}{}{window.h}
\procf{int}{Window::XI}{}
\procf{int}{Window::GetRight}{}
\procf{int}{Window::XA}{}
\procf{int}{Window::GetTop}{}
\procf{int}{Window::Yi}{}
\procf{int}{Window::GetBottom}{}
\procf{int}{Window::YA}{}
\descr{Zugriff auf die X-Koordinatenwerte des linken oder rechten Randes
  bzw. auf die Y-Koordinatenwerte des oberen oder unteren Randes.}

\proch{const IPoint \&}{Window::P1}{}{window.h}
\procf{const IPoint \&}{Window::P2}{}
\descr{Zugriff auf die linke obere Ecke bzw. die rechte untere Ecke als
  \see{IPoint}.}

\proch{IPoint}{Window::getSize}{}{window.h}
\descr{Zugriff auf die Größe des Fensters als Datenstruktur \class{IPoint}.}

Methoden

\proch{bool}{Window::Inside}{const IPoint \&p}{window.h}
\procf{bool}{Window::Inside}{int x,int y}
\descr{Testet, ob der Punkt $p$ bzw. $(x,y)$ im Fenster liegt}

\proch{bool}{Window::operator ==}{const Window \&w}{window.h}
\procf{bool}{Window::operator !=}{const Window \&w}
\descr{Vergleich zweier Fenster auf Gleichheit bzw. Ungleichheit.}

\proch{int}{Window::Shift}{int dx,int dy}{window.h}
\descr{Verschiebt das Fenster um $(dx,dy)$.}

\subsection{Vektoren}
\hypertarget{Vector}{}
\hypertarget{IVector}{}

Der Datentyp (class) \class{Vector} repräsentiert ein Feld 
von $double$-Werten. 
Die Dimension $n$ kann ein beliebiger Wert größer Null sein. Die Index-
Numerierung der Elemente läuft von $0$ bis $n-1$. 
Gegenüber der STL-Klasse \verb+vector<double>+ sind Vektoren der Klasse
\class{Vector} um viele mathematische Operationen erweitert.

Der Datentyp (class) \class{IVector} repräsentiert ein Feld von 
\verb+int+-Werten.
Die Beschreibung des \class{Vector} trifft sinngemäß weitgehend auch für die 
Klasse \class{IVector} zu, wenn der Typ $double$ durch $int$ ersetzt wird.\\
Die Klasse \class{IVector} kann auch als Wert überall dort eingesetzt werden, 
wo auch ein \class{Vector} stehen könnte, da die Klasse \class{Vector} über 
einen entsprechenden Tywandlungskonstruktor verfügt.
\\
Eine spezielle Implementierung dreidimensionaler Vektoren \class{Vector3d} 
kann für eine effiziente Rechnung mit dreidimensionalen Vektoren verwendet 
werden. Eine Konvertierung von und nach der Klasse \class{Vector} kann 
erfolgen:
\begin{itemize}
\item Konstruktor der Klasse \class{Vector3d} mit Parameter vom 
Typ \class{Vector}  (Typwandlungs-Konstruktor)
\item $operator$ \class{Vector} der Klasse \class{Vector3d}
\end{itemize}
Diese ermöglichen eine Verwendung von \class{Vector3d} als 
\class{Vector} ohne explizite Konvertierung.
\\
\subsubsection{Konstruktoren}
\proc{}{Vector::Vector}{}
\descr{Ein Vektor der Länge 0 wird angelegt.}

\proc{}{Vector::Vector}{int n}
\descr{Ein Vektor der Dimension $n$ wird angelegt.}

\proc{}{Vector::Vector}{int n,double *data}
\descr{Ein Vektor der Dimension $n$ wird angelegt und mit den Werten des
  C-array $data$ belegt.}

\proc{}{Vector::Vector}{const Vector \&v}
\descr{Ein Vektor wird als Kopie des Vektor $v$ angelegt.}

\proc{explicit}{Vector::Vector}{const vector<double> \&v}
\descr{Der vector<double> $v$ wird in einen Vektor konvertiert.}

\proc{}{Vector::Vector}{double d1,double d2}
\proc{}{Vector::Vector}{double d1,double d2,double d3}
\proc{}{Vector::Vector}{double d1,double d2,double d3,double d4}
\proc{}{Vector::Vector}{double d1,double d2,double d3,double d4,double d5}
\descr{
Ein Vektor der entsprechenden Länge wird angelegt und die Elemente werden mit
$d1$, $d2$ ... initialisiert.
}

\subsubsection{Operatoren}

\begin{tabular}{|c|l|}
\hline
Operator & Funktion \\
\hline
Vector = Vector & Zuweisungs-Operator \\
Vector + Vector & Vektor-Addition \\
Vector - Vector & Vektor-Subtraktion \\
- Vector        & Negation des Vektors \\
Vector * Vector & Skalar-Produkt \\
Vector * double & Multiplikation mit Skalar \\
double * Vector & Multiplikation mit Skalar \\
Vector [ int ]  & Zugriff auf ein beliebiges Element \\
Vector (int,int)& Teil-Vektor (Vektor-Wert) \\
\hline
\end{tabular}

\proch{double \&}{Vector::at}{int idx}{VectorO.h}
\descr{Zugriff auf das Element mit dem Index $idx$ des Vektors analog zum 
Operator[], aber ohne Bereichstestung.}

\subsubsection{Element-Funktionen}

\proch{int}{Vector::Size}{}{VectorO.h}
\procf{unsigned int}{Vector::size}{}
\descr{Gibt die Dimension des Vektors zurück.}

\proch{bool}{Vector::empty}{}{VectorO.h}
\descr{Gibt $true$ zurück, wenn der Vektor leer ist, also 0 Elemente hat.}

\proch{void}{Clear}{}{VectorO.h}
\descr{Löscht den Vektor. Der Vektor hat danach 0 Elemente. }

\proch{void}{Resize}{int n}{VectorO.h}
\descr{Reinitialisiert den Vektor und legt $n$ Elemente an. Der vorhandene
  Inhalt wird zerstört!}

\proch{void}{Vector::Set}{double val}{VectorO.h}
\descr{Setzt alle Elemente auf den Wert $val$.}

\proch{void}{Vector::SetV}{double d1}{VectorO.h}
\procf{void}{Vector::SetV}{double d1,double d2}
\procf{void}{Vector::SetV}{double d1,double d2,double d3}
\procf{void}{Vector::SetV}{double d1,double d2,double d3,double d4}
\procf{void}{Vector::SetV}{double d1,double d2,double d3,double d4,double d5}
\descr{Setzt die ersten Elemente des Vektors auf die übergebenen Werte.}

\proch{void}{Vector::Append}{double val}{VectorO.h}
\proch{void}{Vector::Append}{const Vector \&v}{VectorO.h}
\descr{Verlängert den Vektor indem der Wert $val$ beziehungsweise die Werte
  des Vektors $v$ angehängt werden.}

\proch{void}{Vector::Exchange}{int i1,int i2}{VectorO.h}
\descr{Tauscht die Elemente mit dem Index $i1$ und $i2$ aus.}

\proch{void}{Vector::Delete}{int i1,int i2}{VectorO.h}
\procf{void}{Vector::Delete}{int i}
\descr{Löscht die Elemente mit von Index $i1$ bis $i2$ oder das
Element mit Index $i$.}

\proch{double}{Vector::Length}{}{VectorO.h}
\descr{Gibt die Länge (den Betrag) des Vektors zurück}

\proch{void}{Vector::Normalize}{}{VectorO.h}
\descr{Normiert den Vektor auf eine Länge (Betrag) von Eins.\\
\seealso{Normalize}
}

\proc{void}{Vector::Sort}{int order=0}
\descr{
Sortiert die Elemente des Vektors in aufsteigender (order=0) oder absteigender
(order=1) Ordnung.
}

\subsubsection{Funktionen mit Vektoren}
\label{Vector-Funktionen}

\proc{Vector}{Normalize}{const Vector \&v}
\descr{
Gibt den normalisierten Vector $v$ zurück.\\
\seealso{Vector::Normalize}
}

\proc{Vector}{Cross}{const Vector \&v1,const Vector \&v2}
\descr{
Gibt das Kreuzprodukt der Vektoren $v1$ und $v2$ zurück.
}

\subsection{Matrizen}
\hypertarget{Matrix}{}

Der Datentyp \class{Matrix} repräsentiert ein zwei-dimensionales Feld von 
{\bf double}-Werten bzw. ein Feld von \hyperlink{Vector}{Vektoren}.
Die Dimensionen $m$ und $n$ können beliebige Werte größer gleich Null sein. 
Die Index-Numerierung der Elemente läuft von $0$ bis $n-1$ bzw. von $0$ bis
$m-1$.

\hypertarget{IMatrix}{}
Der Datentyp \class{IMatrix} verwendet statt des Datentypes $double$ für die
Elemente den Typ Integer ($int$). Durch einen Typwandlungskonstruktor kann
eine $Matrix$ aus einer $IMatrix$ erzeugt werden, was an vielen Stellen den
Einsatz von $IMatrix$ äquivalent zu $Matrix$ erlaubt.

Diese Klassendefinitionen ersetzen den alten Datentyp \see{MatrixStruct}.
Zur {\bf Anwendung} von Matrizen siehe auch Abschnitt \bsee{Matrix-Algebra}.

\subsubsection{Konstruktoren}
\proc{}{Matrix::Matrix}{}
\descr{Legt eine Matrix der Groesse (0,0) an. Diese Matrix kann so 
nicht verwendet werden.}

\proc{}{Matrix::Matrix}{const int rows,const int cols,int initmode=0}
\descr{
Legt eine Matrix mit $rows$ Zeilen und $cols$ Spalten an. Alle Werte sind mit
Null belegt. Wird $initmode=1$ gesetzt, so wird die Matrix als Einheitmatrix
initialisiert.
}

\proc{explicit}{Matrix::Matrix}{const int rows,const int cols,double *init}
\descr{
Legt eine Matrix mit $rows$ Zeilen und $cols$ Spalten an. Die Werte werden mit
den Werten im Feld $init$ belegt. Die rows*cols Werte müssen zeilenweise
abgelegt sein.
}

\proc{}{Matrix::Matrix}{const Matrix\& m}
\descr{Legt eine neue Matrix als Kopie der gegebenen Matrix an 
(Kopierkonstruktor).}

\proc{}{Matrix::Matrix}{const IMatrix\& im}
\descr{
Legt eine neue Matrix mit den konvertierten Werten der gegebenen 
Integer-Matrix an.
}

\proc{explicit}{Matrix::Matrix}{const Image\& m,int mode=RAW,int sign=UNSIGNED}
\descr{
Legt eine neue Matrix mit der Größe des Bildes $m$ an und trägt die Werte 
in die Matrix ein. Es erfolgt eine Transformation der
Werte entsprechend des durch $mode$ und $sign$ bestimmten Modus äquivalent 
zu \see{ConvImgImgD}.
}

\proc{explicit}{Matrix::Matrix}{const ImageD \& m}
\descr{
Legt eine neue Matrix mit der Größe des Gleitkomma-Bildes $m$ 
an und trägt die Werte in die Matrix ein.
}

\subsubsection{Operatoren}
\begin{tabular}{|c|l|}
\hline
Operator & Funktion \\
\hline
Matrix = Matrix & Zuweisungs-Operator \\
Matrix + Matrix & Matrix-Addition (elementweise)\\
Matrix - Matrix & Matrix-Subtraktion (elementweise)\\
- Matrix & Negierte Matrix\\
Matrix * Matrix & Matrix-Multiplikation \\
Matrix * double & Multiplikation aller Elemente mit einer Konstanten \\
double * Matrix & Multiplikation aller Elemente mit einer Konstanten \\
Matrix [int] & Zugriff auf Zeile einer Matrix (-> Vector) \\
Matrix [int i][int j] & Zugriff auf Element der Matrix\\
Matrix (int i1,int j1,int i2,int j2) & Teil-Matrix \\
Matrix $||$ Matrix & Nebeneinander Anordnen und Verbinden \\
Matrix \&\& Matrix & Untereinander Anordnen und Verbinden \\
! Matrix & Transponierte Matrix \\
\hline
\end{tabular} \\
Bei den Operatoren $||$ und \&\& können sinngemäß statt Matrizen auch 
Vektoren angewendet werden. Diese werden als Spalten-Vektor ($||$) bzw.
als Zeilen-Vektor (\&\&) interpretiert.\\
\\
Bei der Multiplikation ist anwendbar:
\begin{tabular}{l}
Vector * Matrix = Vector\\
Matrix * Vector = Vector\\
\end{tabular}

Folgende Methoden unterstützen die Multiplikation mit der transponierten
Matrix:
\proch{Matrix}{Matrix::MulTrans}{const Matrix \&m2}{MatrixO.h}
\descr{Gibt das Produkt der transponierten Matrix mit der Matrix $m2$ zurück.}
\proch{Vector}{Matrix::MulTrans}{const Vector \&v}{MatrixO.h}
\descr{Gibt das Produkt der transponierten Matrix mit dem Vektor $v$ zurück.}

\subsubsection{Element-Funktionen}

\proc{int}{Matrix::rows}{}
\descr{Gibt Zeilenzahl der Matrix zurück.}

\proc{int}{Matrix::cols}{}
\descr{Gibt Spaltenzahl der Matrix zurück.}

\proc{int}{Append}{const Vector \&v}
\descr{Hängt den Inhalt des Vektors $v$ als neue Zeile an die bestehende
  Matrix an. Die Größe des Vektors muss gleich der Zahl der Spalten der Matrix
  sein.}

\proc{void}{Matrix::ExchangeRow}{int i1,int i2}
\descr{Austausch der Zeilen $i1$ und $i2$.}

\proc{void}{Matrix::ExchangeCol}{int i1,int i2}
\descr{Austausch der Spalten $i1$ und $i2$.}

\proc{int}{Matrix::DeleteRow}{int n}
\procf{int}{Matrix::DeleteRow}{int n1,int n2}
\descr{
Löscht die Zeile $n$ bzw. die Zeilen $n1$ bis $n2$ aus der
Matrix.
}

\proc{int}{Matrix::DeleteCol}{int n}
\procf{int}{Matrix::DeleteCol}{int n1,int n2}
\descr{
Löscht die Spalte $n$ bzw. die Spalten $n1$ bis $n2$ aus der
Matrix.
}

\proc{double}{Matrix::MaxVal}{}
\descr{Liefert den Wert des größten Elements der Matrix.}

\proc{void}{Matrix::SumRows}{Vector \&sum}
\proc{void}{Matrix::SumCols}{Vector \&sum}
\descr{Trägt die Werte der Zeilensummen/Spaltensummen in den Vektor $sum$ ein.}

\proc{int}{Matrix::AddDyadicProd}{const Vector \& v,const Vector \& w,double factor}
\proc{int}{Matrix::AddDyadicProd}{const Vector \& v, double factor}
\descr{Bildet das dyadische Produkt der Vektoren $v$ und $w$ beziehungsweise
  von $v$ mit sich selbst, multipliziert dieses mit $factor$ und addiert
  dieses zur Matrix.}

\proc{int}{Matrix::Sort}{int col=0,bool asc=true}
\descr{
Sortiert die Zeilen der Matrix aufsteigend ($asc=true$) oder absteigend
($asc=false$) nach dem Wert der Spalte $col$.
}

\subsection{Punktlisten und Polygone}
\label{Punktliste}
Listen von 2D-Punkten können als \bsee{Matrix} gespeichert werden, 
viele Funktionen benutzen aber auch \verb+vector<Point>+ als Punktliste.\\
In Matrizen wird jeder Punkt als eine Zeile der Matrix abgelegt.
Die Matrix hat mindestens 2 Spalten, die die Koordinaten x und y der Ebene
enthalten. Ist eine dritte Spalte vorhanden, wird diese in einigen Funktionen
als Gewicht interpretiert. Zusätzlich vorhandene Spalten werden ignoriert und
können zusätzlich punktbezogene Daten enthalten.

In {\bf einigen Funktionen} werden solche Punktlisten als Polygon 
interpretiert (siehe aber auch \bsee{Polygon}).
Dabei werden aufeinanderfolgende Punkte und 
der Anfangs- und Endpunkt der Punktliste logisch durch Kanten verbunden. 
Der Anfangspunkt darf nicht als Endpunkt wiederholt werden, 
sonst eine zusätzliche Kante der Länge Null eingeführt wird. 
Die Kanten eines Polygons dürfen sich nicht 
gegenseitig schneiden (Test durch IsPolygon()).

\proc{int}{isPolygon}{const Matrix \& pl}
\descr{Es wird geprüft, dass sich die Kanten eines Polygons nicht 
gegenseitig schneiden.}

\proch{bool}{InsidePolygon}{const Matrix \&pl,const Point \&p}{polygon.h}
\descr{Es wird untersucht, ob der Punkt $p$ innerhalb des Polygons $pl$ liegt.}

\proch{Matrix}{ReducePolygon}{const Matrix \&pl,int n}{polygon.h}
\procf{Matrix}{ReducePolygon}{const Contur \&c,int n}
\descr{Erzeugt ein reduziertes Polygon mit $n$ Ecken aus dem Polygon $pl$ und
gibt dieses zurück.
Dies geschieht durch suksessives Weglassen ``unwichtiger'' Ecken. Die
Signifikanz einer Ecke ergibt sich wie folgt: Seien $e_k$ und $e_{k+1}$ die
Vektoren der beiden anliegenden Kanten. Die Signifikanz ist dann
\[
s_k=\frac{|e_k x e_{k+1}|}{|e_k| + |e_{k+1}|}
\]
Beim alternativen Aufruf wird die Contur $c$ als Polygon interpretiert. 
}

\proch{Matrix}{FitPolygonContur}{const Matrix \&pl, const Contur \&c,int step=0}{polygon.h}
\descr{Die Matrix $pl$ muss ein Polygon enthalten, welches 
  näherungsweise die Contur $c$ beschreibt. Diese kann beispielsweise durch
  \see{ReducePolygon} entstanden sein. Diese Funktion passt iterativ das
  Polygon besser an die Kontur an. Der Parameter $step$ entspricht dem
  Parameter $step$ von \see{FitLine}, welches intern verwendet
  wird. Ein Speziallfall ist $n=-1$, dann wird Fitting mit linearer
  Optimierung verwendet. Dies ist im allgemeinen robuster gegen Ausreißer,
  dauert aber länger.}

\proch{vector$<$Point$>$}{ConvexHull}{const vector$<$Point$>$ \&pl}{convexhull.h}
\descr{
Zu der übergebenen Punktliste $pl$ wird die konvexe Hülle erzeugt 
und als vector$<$Point$>$ zurückgegeben. Die Punkte der zurückgegeben Liste 
sind geordnet, so das die Punktfolge ein Polygon definiert. Ein \bsee{Polygon} kann 
direkt mit Hilfe des Konstruktors erzeugt werden.
}

\proch{Matrix}{ConvexHull}{const Matrix \&pl}{convex.h}
\procf{Contur}{ConvexHull}{const Contur \&c}
\descr{
Erzeugt die konvexe Hülle der als Matrix übergebenen Punktmenge bzw. der übergebenen Kontur.
}

\seealso{ConturPointlist}
\seealso{PointlistContur}

\subsection{ColorValue}
\hypertarget{ColorValue}{}
Die Klasse \class{ColorValue} dient der Speicherung von Farbwerten in Form
von ganzzahligen Intensitätswerten für die Grundfarben Rot, Grün und 
Blau. Werte vom Typ \class{ColorValue} werden zum Setzen und Lesen von 
Werten in Farbbildern der Klasse \class{ColorImage} verwendet. Für 
einen schnellen Zugriff 
sind die int-Variablen \verb+red+, \verb+green+ und \verb+blue+ der 
Klasse \verb+public+. Die Klasse \class{ColorValue} ist nicht 
als Basisklasse einer Klassenhierarchie konzipiert und es sollten keine
Klassen davon abgeleitet werden: Die Methoden sind alle nicht virtuell.

\subsubsection{Konstruktoren}

\proch{}{ColorValue::ColorValue}{}{ColorValue.h}
\descr{Standard-Konstruktor. Die Farbwerte $red$,
$green$ und $blue$ werden mit 0 intialisiert.}

\proch{explicit}{ColorValue::ColorValue}{int val}{ColorValue.h}
\descr{Typwandlungs-Konstruktor. Alle Farbwerte $red$,
$green$ und $blue$ werden mit $val$ intialisiert.}

\proch{}{ColorValue::ColorValue}{int redval,int greenval,int blueval}{ColorValue.h}
\descr{Konstruktor, der die Farbwerte $red$,
$green$ und $blue$ werden mit den gegebenen Werten intialisiert.}

\subsubsection{Operatoren}

\begin{center}
\begin{tabular}{ccc@{=}c}
ColorVal & + & ColorVal & ColorVal\\
ColorVal\& & += & ColorVal & const ColorVal\&\\
ColorVal & - & ColorVal & ColorVal\\
ColorVal\& & -= & ColorVal & const ColorVal\&\\
ColorVal & * & int & ColorVal\\
ColorVal\& & *= & int & const ColorVal\&\\
ColorVal & / & int & ColorVal\\
ColorVal\& & /= & int & const ColorVal\&\\
ColorVal & * & double & ColorVal\\
ColorVal\& & *= & double & const ColorVal\&\\
ColorVal & / & double & ColorVal\\
ColorVal\& & /= & double & const ColorVal\&\\
\end{tabular}
\end{center}

\subsubsection{Methoden}
\proch{double}{ColorValue::abs}{}{ColorValue.h}
\descr{Berechnet den Betrag (Länge) des durch die Werte
 $red$, $green$ und $blue$ gebildeten Vektors.}

\proch{double}{ColorValue::abs2}{}{ColorValue.h}
\descr{Berechnet das Quadrat des Betrages (Länge) des durch die Werte
 $red$, $green$ und $blue$ gebildeten Vektors.}

\proch{int}{ColorValue::absL1}{}{ColorValue.h}
\descr{Summe der Beträge der Werte $red$, $green$ und $blue$.}

\proch{int}{ColorValue::getGray}{}{ColorValue.h}
\descr{Berechnet einen Grauwert als Mittelwert von 
$red$, $green$ und $blue$.}

\proch{ColorValue}{ColorValue::Limited}{int maxValue}{ColorValue.h}
\descr{Ermittelt einen Farbwert, dessen Werte $red$, 
$green$ und $blue$ im Interval $[0,maxValue]$ liegen.
Werte ausserhalb des Intervalls werden auf den jeweiligen 
Extremwert gesetzt. Dies kann benutzt werden, um beim Schreiben 
in ein Farbbild mittels \bsee{ColorImage::setPixel} Überläufe zu
vermeiden.}

\subsection{Farbraum-Transformationen}
Werte der Klasse \class{ColorValue} repräsentieren Farbwerte im
RGB-Farbraum. Die folgenden Funktionen konvertieren diese RGB-Werte
in andere Farbräume und zurück. Dabei werden Farbwerte in anderen 
Farbräumen durch drei Gleitkomma-Werte vom Typ \verb+double+ beschrieben.
Die Werte liegen im Intervall 0..1 bzw -0.5..0.5, nur bei Werten des
Lab-Farbraumes werden die dort üblichen Bereich 0..100, -150..100 und
-100..150 für L, a und b verwendet. Weiterhin gibt es Funktionen zur
Farbraum-Transformation von Bildern (\see{ColorImageToHSI}..) .
 

\proch{void}{RgbToHsi}{const ColorValue \&src, int maxval, double \&h, double \&s, double \&i}{ColorSpace.h}
\procf{void}{RgbToHsi}{const ColorValue \&src, double \&h, double \&s, double \&i}
\procf{void}{RgbToYuv}{const ColorValue \&src, int maxval, double \&h, double \&s, double \&i}
\procf{void}{RgbToYuv}{const ColorValue \&src, double \&h, double \&s, double \&i}
\procf{void}{RgbToXyz}{const ColorValue \&src, int maxval, double \&x, double \&y, double \&z}
\procf{void}{RgbToXyz}{const ColorValue \&src, double \&x, double \&y, double \&z}
\procf{void}{RgbToLab}{const ColorValue \&src, int maxval, double \&x, double \&y, double \&z}
\procf{void}{RgbToLab}{const ColorValue \&src, double \&x, double \&y, double \&z}
\descr{Transformation von Werten von \class{ColorValue} aus dem RGB-Farbraum in 
die Farbräume HSI, YUV, XYZ und Lab. Wird der Maximalwert maxval angegeben, 
so werden die RGB-Wert in \class{ColorValue} als Werte im Bereich 0..maxval 
angenommen, sonst 0..255.}

\proch{void}{HsiToRgb}{double h, double s, double i, ColorValue \&dst, int maxval = 255}{ColorSpace.h}
\procf{void}{YuvToRgb}{double y, double u, double v, ColorValue \&dst, int maxval = 255}
\procf{void}{XyzToRgb}{double x, double y, double z, ColorValue \&dst, int maxval = 255}
\procf{void}{LabToRgb}{double l, double a, double b, ColorValue \&dst, int maxval = 255}
\descr{Transformieren Farbwerte aus den Farbräumen HSI,YUV, XYZ und LAB in den
RGB-Farbraum. Die RGB-Werte werden in Variablen der Klasse \class{ColorValue} 
gespeichert. Der Umfang der RGB-Werte beträgt 0..maxval.}

\proch{void}{HsiToRgb}{double h, double s, double i, double \&r, double \&g, double \&b}{ColorSpace.h}
\procf{void}{RgbToHsi}{double r, double g, double b, double \&h, double \&s, double \&i}
\procf{void}{YuvToRgb}{double y, double u, double v, double \&r, double \&g, double \&b}
\procf{void}{RgbToYuv}{double r, double g, double b, double \&h, double \&s, double \&i}
\procf{void}{RgbToXyz}{double r, double g, double b, double \&x, double \&y, double \&z}
\procf{void}{XyzToRgb}{double x, double y, double z, double \&r, double \&g, double \&b}
\procf{void}{XyzToLab}{double x, double y, double z, double \&l, double \&a, double \&b}
\procf{void}{LabToXyz}{double l, double a, double b, double \&x, double \&y, double \&z}
\procf{void}{RgbToLab}{double r, double g, double b, double \&x, double \&y, double \&z}
\procf{void}{LabToRgb}{double l, double a, double b, double \&rr, double \&gg, double \&bb}
\descr{Allgemeine Farbraumtransformationen.}
 
\newpage
\makeatletter{}\nsection{Filter}{filter}

In diesem Abschnitt werden Filter-Operationen über Bilder beschrieben.
Alle Typen von Bildrepräsentationen werden hier soweit es geht gemeinsam 
abgehandelt (\class{Image}, \class{ImageD}, \class{ColorImage}). 
Auf die Besonderheiten bei bestimmten Typen wird speziell hingewiesen. 
Die Funktionen zur Bildfilterung benötigen im allgemeinen ein Quellbild
und ein Zielbild. Bei fehlerfreier Abarbeitung wird OK zurückgegeben, sonst
ein Fehlerkode.

\subsection{Lineare lokale Filter}
\hypertarget{LSIFilter}{}
\subsubsection{Klasse LSIFilter}
Die Klasse \class{LSIFilter} repräsentiert allgemeine LSI-Filter. 
LSI-Filter können durch die Vorgabe von Filtermasken 
(als \class{Matrix} oder \class{IMatrix}) oder mittels spezieller 
Funktionen (z.B. \see{mkDirSmearFilter}) erzeugt werden.

Ein LSI-Filter beschreibt immer eine LSI-Filterung der Form 
\[ g \prime (x,y) = \sum_{i,j} f(i,j) \cdot g(x+i,y+j) ,\]
wobei je nach Filtertyp unterschiedliche interne Repräsentationen 
zur Anwendung kommen. Ganzzahlige Filter sind typischerweise 
schneller als Gleitkomma-Filter (Initialisierung mit \class{IMatrix} 
statt \class{Matrix}).
 
\subtitle{Konstruktoren}
\proch{}{LSIFilter::LSIFilter}{}{lsifilter.h}
\descr{Standardkonstruktor. Ein durch den Standardkonstruktor erzeugtes 
Filter ist nicht benutzbar, sondern es muss durch Zuweisung ein 
richtiges Filter zugewiesen werden.}

\proch{}{LSIFilter::LSIFilter}{const LSIFilter \&f}{lsifilter.h}
\descr{Kopierkonstruktor.}

\proch{}{LSIFilter::LSIFilter}{const Matrix \&m}{lsifilter.h}
\descr{Konstruiert ein (double-)Filter mit der als \class{Matrix} $m$ 
übergebenen Maske. 
\[ g(x,y) = \sum_{i,j} m_{i,j} \cdot g(x+i,y+j) \]
}

\proch{}{LSIFilter::LSIFilter}{const IMatrix \&m,int norm}{lsifilter.h}
\procf{}{LSIFilter::LSIFilter}{int *m,int norm}
\descr{Konstruiert ein (int-)Filter mit der als \class{IMatrix} oder 
C-Array $m$ übergebenen Maske.
\[ g(x,y) = {1 \over norm} \cdot \sum_{i,j} m_{i,j} \cdot g(x+i,y+j) \]
}

\subtitle{Abfrage und Manipulation}

\proch{double}{LSIFilter::getMask}{int x,int y}{lsifilter.h}
\descr{Gibt den Wert der Filtermaske an der Stelle $x,y$ zurück.}

\proch{void}{LSIFilter::NegateMask}{}{lsifilter.h}
\descr{Negiert die Koeffizienten der Filtermaske.}

\proch{double}{LSIFilter::proposeOffset}{const Image \&img}{lsifilter.h}
\descr{Gibt einen Offset-Wert zurück, der bei der Filterung eines Integerbildes
angewendet werden sollte, damit die Ergebniswerte im positiven ganzzahligen 
Bereich der Grauwerte des Ergebnisbildes $img$ liegen.}


\subsubsection{Filtererzeugung}
Neben den Konstruktoren, die aus Matrizen mit den Filterkoeffizienten LSIFilter 
erzeugen, gibt es Funktionen zur Erzeugung spezieller Filter.

\proch{LSIFilter}{mkPolynomFilter}{int n,int grad,int i,int j}{lsifilter.h}
\descr{Erzeugt einen Filter, der als Filter-Ergebnis den Koeffizienten $a_{i,j}$ eines 
an der Stelle (x0,y0) an die Grauwertfunktion angepaßten Polynoms des Grades $grad$ 
ermittelt.
\[
g(x,y) = \sum_{i,j} a_{i,j} \cdot (x-x_0)^i \cdot (y-y_0)^j 
\]
Folgende Aufrufe erzeugen Filter, die äquivalent zu anderen Filterfunktionen sind:\\
\begin{tabular}{cc}
  mkPolynomFilter(3,1,0,0) & \bsee{SmearImg} \\
  mkPolynomFilter(3,1,1,0) & \bsee{GradXImg} \\
  mkPolynomFilter(3,1,0,1) & \bsee{GradYImg} \\
  mkPolynomFilter(3,2,0,0) & \bsee{MeanImg} \\
  mkPolynomFilter(3,2,2,0) & \bsee{LaplaceXImg} \\
  mkPolynomFilter(3,2,0,2) & \bsee{LaplaceYImg}
\end{tabular}
}

\setlength{\unitlength}{1cm}
\begin{picture}(6,6)
  \epsfig{figure=dirsmear.eps,width=6cm}
\end{picture}
\proch{LSIFilter}{mkDirSmearFilter}{int n,double dir,double len,double width}{lsifilter.h}
\descr{Erzeugt ein Mittelwertfilter, dessen Maske eine diskrete Approximation 
der im Bild dargestellten roten Fläche darstellt.}

\begin{picture}(6,6)
  \epsfig{figure=dirdob.eps,width=6cm}
\end{picture}
\proch{LSIFilter}{mkDirDoBFilter}{int n,double dir,double len,double width}{lsifilter.h}
\descr{Erzeugt ein dem DoB-Filter (\see{DoBImg}) ähnliches Filter, 
dessen Maske eine diskrete Approximation des Bildes dargestellt. Dabei
kennzeichnet die roten Fläche  positive Maskenwerte, die blaue Fläche negative
Maskenwerte. Die Werte sind so gewählt, dass in einem homogenen Bild das Filter
den Wert Null liefert.}

\begin{picture}(6,6)
  \epsfig{figure=diredge.eps,width=6cm}
\end{picture}
\proch{LSIFilter}{mkDirEdgeFilter}{int n,double dir,double rad}{lsifilter.h}
\descr{Erzeugt ein Kanten-Filter, dessen Maske eine diskrete Approximation 
des Bildes dargestellt. Dabei
kennzeichet die roten Fläche  positive Maskenwerte, die blaue Fläche negative
Maskenwerte. Die positiven und negativen Werte sind betragsmäßig gleich.}

\subsubsection{Anwendung von LSIFilter}

\proch{int}{LSIFilter::Filter}{const Image \&src,Image \&dst,int offset}{lsifilter.h}
\procf{int}{LSIFilter::Filter}{const Image \&src,ImageD dst}
\procf{int}{LSIFilter::Filter}{ImageD src,ImageD dst}
\descr{Wendet das Filter auf das Bild $src$ an und speichert das Ergebnis
im Bild $dest$. Im Falle der Integer-Bilder verschieben sich die 
Ergebniswerte um $offset$. Damit kann erreichtwerden, dass negative 
Filterergebnisse auf den Bereich des Zielbildes abgebildet werden 
(\see{LSIFilter::proposeOffset}). }

\proch{int}{LSIImg}{const Image \&src,Image \&dst,const LSIFilter \&f,int offset}{lsifilter.h}
\descr{Wendet das Filter $f$ auf das Bild $src$ an und speichert das Ergebnis
im Bild $dest$. Dies ist äquivalent zu LSIFilter::Filter(src,dst,offset).}

\seealso{GetVal}

\subtitle{Spezielle Aufrufformen}

In den speziellen Aufrufformen wird das LSIFilter implizit generiert 
und angewendet. Deshalb ergeben sich keine inhaltlichen Unterschiede 
zur Erzeugung eines Filters mit nachfolgender Filterung.

\proc{int}{LSIImg}{Image src,int nx,int ny,int *mask,int norm,int offset,Image dest}
\descr{
Allgemeines LSI-Filter. Mit mit den ungeraden Werten $nx$ und $ny$ wird 
die Größe der Filtermaske angegeben (3,5,7,\dots). Die Filtermaske $mask$ 
ist ein int-Array der Größe $ny \cdot nx$. Die Bildpunkte des 
Zielbildes werden nach der Formel
$$vd(x,y)={maxd \over norm \cdot maxs}\cdot \sum vs(x-i,y-j) \cdot mask(i,j) +
offset$$
berechnet.
}
\proc{int}{LSIImg}{Image src,int nx,int ny,double *mask,int offset,Image dest}
\descr{
Allgemeines LSI-Filter. Mit mit den ungeraden Werten $nx$ und $ny$ wird 
die Größe der Filtermaske angegeben (3,5,7,\dots). Die Filtermaske $mask$ 
ist ein double-Array der Größe $ny \cdot nx$. Die Bildpunkte des 
Zielbildes werden nach der Formel
$$vd(x,y)={maxd \over maxs}\cdot \sum vs(x-i,y-j) \cdot mask(i,j) + offset$$
berechnet.
}
\proc{int}{LSIImg}{Image src,const Matrix \&mask,int offset,Image dest}
\descr{
Allgemeines LSI-Filter. Die Filtermaske $mask$ ist eine $Matrix$. 
Die Bildpunkte des Zielbildes werden nach der Formel
$$vd(x,y)={maxd \over maxs}\cdot \sum vs(x-i,y-j) \cdot mask(i,j) + offset$$
berechnet.
}
\proc{int}{LSIImg}{Image src,const IMatrix \&mask,int norm,int offset,Image dest}
\descr{
Allgemeines LSI-Filter. Die Filtermaske $mask$ ist eine $IMatrix$. 
Die Bildpunkte des Zielbildes werden nach der Formel
$$vd(x,y)={maxd \over { maxs \cdot norm } }\cdot \sum vs(x-i,y-j) \cdot mask(i,j) + offset$$
berechnet.
}

\subsubsection{Spezielle lineare lokale Filter}
Die speziellen linearen lokalen Filter sind in der Laufzeit gegenüber 
den allgemeinen LSI-Filtern (\class{LSIFilter} optimiert. Viele 
beschränken sich auf eine 3*3-Umgebung.

\proch{int}{SmearImg}{const Image \&src,Image \&dest,int n=3}{filter.h}
\procf{int}{SmearImg}{const Image \&src,Image \&dest,int nx,int ny}
\procf{int}{SmearImg}{const Image \&img,int n}
\descr{
Fenster-Mittelwertfilter. Das Fenster wird quadratisch (Größe $n$*$n$) 
oder rechteckig (Größe $nx$*$ny$) gewählt. Die Laufzeit dieser (optimierten)
Variante ist nicht von der Fenstergröße abhängig.
}

\proch{int}{SmearImgD}{ImageD src,ImageD dest,int nx,int ny}{darith.h}
\procf{int}{SmearImgD}{ImageD src,ImageD dest,int n}
\descr{
Fenster-Mittelwertfilter. Das Fenster wird quadratisch (Größe $n$*$n$) 
oder rechteckig (Größe $nx$*$ny$) gewählt. Hier wird jedoch nicht der 
Mittelwert, sondern die Grauwert-Summe im Fenster als Ergebniswert 
abgelegt. Die Laufzeit dieser (optimierten) Variante ist nicht von der 
Fenstergröße abhängig.
}

\proch{int}{BoxImg}{const Image \&src,Image \&dest,int n=3}{filter.h}
\procf{int}{BoxImg}{const Image \&src,Image \&dest,int nx,int ny}
\descr{
Boxfilter, der die Werte im Fenster summiert. Der Unterschied zu 
\bsee{SmearImg} besteht in der fehlenden Division durch die Box-Größe. 
Die Ergebniswerte können deshalb sehr groß werden und werden auf den 
Grauwertumfang des Zielbildes beschränkt.
Das Fenster wird quadratisch (Größe $n$*$n$) 
oder rechteckig (Größe $nx$*$ny$) gewählt. Die Laufzeit dieser (optimierten)
Variante ist nicht von der Fenstergröße abhängig.
}

\proch{int}{DoBImg}{Image src,Image dest,int n1,int n2,int mode=SMD\_SHIFT}{filter.h}
\descr{
''Difference of Boxes'' - Differenz zweier Fenster-Mittelwertfilter mit den
Größen $n1$ und $n2$. Dieses Filter kann als schnelle Approximation des
MexicanHat-Filters verwendet werden. Der Parameter $modus$ steuert, wie die
Differenz (\see{SubImg}) gebildet wird:\\
\begin{tabular}{|c|c|} \hline
mode & Wert \\ \hline
SMD\_ABSOLUTE & $vd=\vert v1-v2 \vert$ \\
SMD\_POSITIVE & $vd=max(v1-v2,0)$ \\
SMD\_SHIFT & $vd=v1-v2+max/2$ \\ \hline
\end{tabular}\\
}

\proch{int}{GradXImg}{Image src,int norm,Image dest}{filter.h}
\descr{
Gradient in x-Richtung:
$${norm\cdot maxd \over 6 \cdot maxs}\left[{ \matrix{-1&0&1\cr-1&0&1\cr-1&0&1}}
\right] +{maxd \over 2}$$
}
\seealso{GradImg}
\seealsonext{GradDirImg}

\proc{int}{GradYImg}{Image src,int norm,Image dest}
\descr{
Gradient in y-Richtung:
$${norm\cdot maxd \over 6 \cdot maxs}\left[{ \matrix{-1&-1&-1\cr0&0&0\cr1&1&1}}
\right] +{maxd \over 2}$$
}
\seealso{GradImg}
\seealsonext{GradDirImg}

\proc{int}{MeanImg}{Image src,Image dest}
\descr{gewichtetes Mittelwertfilter:
$${maxd \over 9 \cdot maxs}\left[{ \matrix{-1&2&-1\cr2&5&2\cr-1&2&-1}}
\right]$$
}

\proc{int}{LaplaceXImg}{Image src,int norm,Image dest}
\descr{
Laplacefilter in x-Richtung:
$${norm\cdot maxd \over 12 \cdot maxs}\left[{ \matrix{1&-2&1\cr1&-2&1\cr1&-2&1}}
\right] +{maxd \over 2}$$
}
\proc{int}{LaplaceYImg}{Image src,int norm,Image dest}
\descr{
Laplacefilter in y-Richtung:
$${norm\cdot maxd \over 12 \cdot maxs}\left[{ \matrix{1&1&1\cr-2&-2&-2\cr1&1&1}}
\right] +{maxd \over 2}$$
}
\proc{int}{LaplaceImg}{Image src,int norm,Image dest}
\descr{
Laplacefilter:
$${norm\cdot maxd \over 16 \cdot maxs}\left[{ \matrix{2&-1&2\cr-1&-4&-1\cr2&-1&2}}
\right] +{maxd \over 2}$$
}

\proc{int}{GaussImg}{const Image \&src,Image \&dest,int neighb,double sigma}
\procf{int}{GaussImg}{const Image \&src,ImageD dest,int neighb,double sigma}
\procf{int}{GaussImg}{ImageD src,ImageD dest,int neighb,double sigma}
\descr{
Gaussfilterung eines Bildes. Es wird eine Filtermaske der Größe
$neighb*neighb$ nach der folgenden Formel berechnet:\\
$$mask(i,j)={1\over norm}e^{i^2+j^2 \over 2 sigma^2}\quad ,\quad
i,j=-{neighb-1 \over 2},\dots,{neighb-1 \over 2}$$
$norm$ wird so festgelegt, daß die Summe der Filterkoeffizienten 1 ergibt.
}

\proch{int}{MexicanHatImg}{const Image \&src,Image \&dest,double sigma,int neighb=0}{filter.h}
\procf{int}{MexicanHatImg}{const Image \&src,ImageD dest,double sigma,int neighb=0}
\procf{int}{MexicanHatImg}{ImageD src,ImageD dest,double sigma,int neighb=0}
\descr{
Es wird das Mexican Hat-Filter (auch Laplace of Gaussian-Operator oder Marr-Hildret-Operator) 
auf das Bild $src$ angewendet und das Ergebnis in Bild $dest$ gespeichert. 
Dabei ist $sigma$ der Parameter der Gauss-Funktion, $neighb$ die Größe der Filtermaske.
$neighb$ muss hinreichend groß gewählt werden, um das ideale Filter zu approximieren.
Ist $neighb$ gleich Null, so wird die Filtermaske als nächstgrößte ungerade Zahl zu 
$ 5 \cdot sigma$ gewählt.
}

\subsection{Nichtlineare lokale Filter}

\proc{int}{GradImg}{const Image \&src,int norm,Image \&dest}
\descr{Aus den Gradienten in x- und y-Richtung wird der Betrag berechnet:\\
$$val={norm\cdot maxd \over maxs}\cdot \sqrt{gradx^2+grady^2}$$
}

\proc{int}{GradDirImg}{const Image \&src,Image \&dest}
\descr{
Es wird die Richtung des Gradienten bestimmt und auf die acht
Freemanrichtungen (0 \dots 7) quantisiert.
}

\proch{int}{CalcDirectionImg}{const Image \&src,Image \&dir,int dsize=11}{filter.h}
\proc{int}{CalcDirectionImg}{const Image \&src,Image \&dir,int dsize=11,ImageD eval}
\descr{Im Bild $src$ wird aus dem Grauwertgradienten für jeden Punkt eine 
Vorzugsrichtung ermittelt. Der Gradient wird dabei über eine Umgebung der 
Größe $dsize$*$dsize$ gemittelt und der Winkel als Ergebnis in das Bild $dir$ eingetragen.
Der Winkelbereich $0 \le \varphi < 2 \pi$ wird dabei auf den Grauwertumfang 
des Zielbildes $dir$ abgebildet. 
Das Bild $dir$ ist direkt geeignet zur Verwendung mit dem gerichteten 
Filter \bsee{OrientedEdgeImg}.
Wenn das double-Bild $eval$ als Parameter angegeben werden, wird auf diesem der
Betrag des gemittelten Gradienten abgelegt, der als Maß für die Gerichtetheit im 
jeweiligen Punkt verwendet werden kann.}

\proch{int}{CalcDirectionStructImg}{const Image \&src,Image \&dir,int dsize=11}{filter.h}
\proc{int}{CalcDirectionStructImg}{const Image \&src,Image \&dir,int dsize=11,ImageD lambda1,ImageD lambda2}
\descr{Im Bild $src$ wird aus dem Grauwertgradienten mittels des 
Struktur-Tensors für jeden Punkt eine Vorzugsrichtung ermittelt. 
Der Winkel wird dabei über eine Umgebung der Größe $dsize$*$dsize$ 
gemittelt und das Ergebnis in das Bild $dir$ eingetragen.
Der Winkelbereich $0 \le \varphi < \pi$ wird dabei auf den 
Grauwertumfang des Zielbildes $dir$ abgebildet.
Das Bild $dir$ ist direkt geeignet zur Verwendung 
mit den gerichteten Filtern \bsee{OrientedSmearImg} und \bsee{OrientedDoBImg}.
Wenn die double-Bilder $lambda1$ und $lambda2$ 
als Parameter angegeben werden, werden auf diesen die Eigenwerte 
des Struktur-Tensors abgelegt, die als Maß für die Gerichtetheit im 
jeweiligen Punkt verwendet werden können.}

\proch{int}{OrientedSmearImg}{const Image \&src,const Image \&dir,
  Image \&dest,int fsize=11,int flength=10,int fwidth=1}{filter.h}
\proc{int}{OrientedDoBImg}{const Image \&src,const Image \&dir,
  Image \&dest,int fsize=11,int flength=10,int fwidth=1}
\descr{Gerichtete Mittelwertfilter (\see{mkDirSmearFilter}) bzw. 
gerichtete DoB-Filter (\see{mkDirDoBFilter}) werden 
punktweise angewendet, wobei die Orientierung des Filters aus dem 
Bild $dir$ (\see{CalcDirectionStructImg}) entnommen wird. Zur Bedeutung der 
Filterparameter siehe \bsee{mkDirSmearFilter} und \bsee{mkDirDoBFilter}.
}

\proch{int}{OrientedEdgeImg}{const Image \&src,const Image \&dir,
  Image \&dest,int fsize=11,int rad=10}{filter.h}
\descr{Der gerichtete Kantenfilter (\see{mkDirEdgeFilter}) wird 
punktweise angewendet, wobei die Orientierung des Filters aus dem 
Bild $dir$ (\see{CalcDirectionImg}) entnommen wird. Zur Bedeutung der 
Filterparameter siehe \bsee{mkDirEdgeFilter}.
}

\subsection{Morphologische und Rangordnungs-Filter}
\proch{int}{ErodeImg}{const Image \&src,int nx,int ny,Image \&dest}{filter.h}
\procf{int}{ErodeImg}{const Image \&src,Image \&dest,int nx=3, int ny=-1}
\descr{
Es wird eine Erosion in der $nx$*$ny$-Umgebung durchgeführt.
$nx$ und $ny$ müssen ungerade sein. Dies entspricht dem Minimum-Filter mit 
dem gegebenen Fenster. Beim Aufruf in der zweiten Variante steht Weglassen von
$ny$ für ein quadratisches Fenster. Der Vorzugswert für $nx$ ist 3.}
\seealso{MinMaxImg}

\proc{int}{ErodeImg}{const Image \&src,int neighb,int *mask,Image \&dest}
\procf{int}{ErodeImg}{const Image \&src,int nx,int ny,int *mask,Image \&dest}
\procf{int}{ErodeImg}{const Image \&src,const Imatrix \&mask,Image \&dest}
\procf{int}{ErodeImg}{const Image \&src,Image \&dest,const IMatrix \&mask}
\descr{
Es wird eine verallgemeinerte Erosion mit dem in der Maske {\bf mask} 
definierten strukturierenden Element durchgeführt. Die 
Bildpunkte in der Umgebung werden für die Minimum-Bildung berücksichtigt, 
wenn der enstsprechende Wert in der Maske verschieden von Null ist.\\
Die Maske kann als C-Array gegeben sein und muss $neighb * neighb$ 
beziehungsweise $nx * ny$ Elemente enthalten, wobei $neighb$, 
$nx$ und $ny$ ungerade Zahlen (3, 5, 7,\dots) sein müssen.\\
Wird {\bf mask} als \class{IMatrix} gegeben, so entspricht die 
Nachbarschaftsgröße der Matrix-Größe. Diese Größen müssen ebenfalls 
ungeradzahlig sein.
}

\proch{int}{DilateImg}{const Image \&src,int nx,int ny,Image \&dest}{filter.h}
\procf{int}{DilateImg}{const Image \&src,Image \&dest,int nx=3, int ny=-1}
\descr{
Es wird eine Dilatation in der $nx$*$ny$-Umgebung durchgeführt.
$nx$ und $ny$ müssen ungerade sein. Dies entspricht dem Maximum-Filter mit 
dem gegebenen Fenster. Beim Aufruf in der zweiten Variante steht Weglassen von
$ny$ für ein quadratisches Fenster. Der Vorzugswert für $nx$ ist 3.}
\seealso{MinMaxImg}

\proc{int}{DilateImg}{const Image \&src,int neighb,int *mask,Image \&dest}
\procf{int}{DilateImg}{const Image \&src,int nx,int ny,int *mask,Image \&dest}
\procf{int}{DilateImg}{const Image \&src,const Imatrix \&mask,Image \&dest}
\procf{int}{DilateImg}{const Image \&src,Image \&dest,const IMatrix \&mask}
\descr{
Es wird eine verallgemeinerte Dilatation mit dem in der Maske {\bf mask} 
definierten strukturierenden Element durchgeführt. Die 
Bildpunkte in der Umgebung werden für die Maximum-Bildung berücksichtigt, 
wenn der entsprechende Wert in der Maske verschieden von Null ist.\\
Die Maske kann als C-Array gegeben sein und muss $neighb * neighb$ 
beziehungsweise $nx * ny$ Elemente enthalten, wobei $neighb$, 
$nx$ und $ny$ ungerade Zahlen (3, 5, 7,\dots) sein müssen.\\
Wird {\bf mask} als \class{IMatrix} gegeben, so entspricht die 
Nachbarschaftsgröße der Matrix-Größe. Diese Größen müssen ebenfalls 
ungeradzahlig sein.
}

\proch{int}{OpeningImg}{const Image \&src,Image \&dest,int nx=3, int ny=-1}{filter.h}
\procf{int}{OpeningImg}{const Image \&src,Image \&dest,const IMatrix \&mask}
\descr{
Es wird ein Opening in der $nx$*$ny$-Umgebung durchgeführt. Dies ist die 
Hintereinanderausführung einer Erosion gefolgt von einer Dilatation. 
$nx$ und $ny$ müssen ungerade sein. Weglassen von $ny$ steht für ein 
quadratisches Fenster. Der Vorzugswert für $nx$ ist 3.\\
Bei Angabe einer \class{IMatrix} als Maske, werden Erosion und Dilatation 
mit dieser Maske ausgeführt.
}

\proch{int}{ClosingImg}{const Image \&src,Image \&dest,int nx=3, int ny=-1}{filter.h}
\procf{int}{ClosingImg}{const Image \&src,Image \&dest,const IMatrix \&mask}
\descr{
Es wird ein Closing in der $nx$*$ny$-Umgebung durchgeführt. Dies ist die 
Hintereinanderausführung einer Dilatation gefolgt von einer Erosion. 
$nx$ und $ny$ müssen ungerade sein.
Weglassen von $ny$ steht für ein quadratisches Fenster. 
Der Vorzugswert für $nx$ ist 3.\\
Bei Angabe einer \class{IMatrix} als Maske, werden Dilatation und Erosion
mit dieser Maske ausgeführt.}

\proc{int}{MinMaxImg}{const Image \&src,int nx, int ny,Image \&minimg, Image \&maximg}
\descr{Bestimmt gleichzeitig das Resultat eines Minimum-Filters 
(Erosion) und eines Maximum-Filters (Dilatation) mit gegebenem Fenster. 
Wenn {\bf beide} Filter benötigt werden, ist die Kombination beider 
Filter effektiver als die getrennte Ausführung von \bsee{ErodeImg} 
und \bsee{DilateImg}.
}

Das folgende Beispiel soll die Verwendung von ErodeImg() und DilateImg() 
demonstrieren.

\begprogr
\begin{verbatim}
/*Erosion und Dilatation*/
#include <image.h>

void main(int argc,char *argv[])
{
  Image img;
  int mask[3][3]={{1,0,0},{0,1,0},{0,0,1}};       // strukturierendes Element
  img=ReadImg(argv[1],NULL);                      // Bild einlesen
  Show(ON,img,"Original-Bild");                   // Bild darstellen
  Image erode_img = NewImg(img);
  Show(ON, erode_img, "Mit Maske erodiertes Bild");
  ErodeImg(img,3,mask,erode_img);                 // Erosion
  Image dilate_img = NewImg(img);
  Show(ON, dilate_img, "Mit Maske dilatiertes Bild");
  DilateImg(img,3,mask,dilate_img);                // Dilatation
}
\end{verbatim}
\endprogr

\proch{int}{RankImg}{const Image \&src,int neighb,int rank,Image \&dest}{rank.h}
\procf{int}{RankImg}{const Image \&src,int nx,int ny,int rank,Image \&dest}
\descr{
Für jeden Bildpunkt wird in einer Umgebung der Größe $neighb*neighb$
beziehungsweise $nx*ny$ der Wert mit dem Rang $rank$ bestimmt und 
ins Zielbild eingetragen. $neighb$, $nx$ und $ny$ müssen ungerade sein.
}

\proch{int}{MedianImg}{const Image \&img,int size,Image \&dest}{rank.h}
\descr{Bestimmt als Spezialfall von \bsee{RankImg} ein Bild $dest$, dessen
  Pixel den Wert des Median der Werte in der Umgebung $neighb*neighb$ des
  Originalbildes haben.}

\proc{int}{SubRankImg}{const Image \&src,int neighb,int rank,Image \&dest}
\descr{
Für jeden Bildpunkt wird in einer Umgebung der Größe $neighb*neighb$ der Wert
mit dem Rang $rank$ bestimmt und vom Grauwert dieses Punktes im Originalbild
subtrahiert. Falls das Ergebnis kleiner als Null ist, wird Null im Zielbild
eingetragen. $neighb$ muß eine ungerade Zahl sein.
}

\proch{int}{RelaxImg}{const Image \&src,Image \&dest,int neighb=3}{icefunc.h}
\descr{
Es wird ein Relaxationsfilter zur Schärfung auf Bild $img1$ angewendet und 
das Ergebnis im Bild $img2$ abgespeichert. Dabei wird im Quellbild $src$ in
einer $neighb*neighb$ Umgebung das Maximum und das Minimum der Grauwerte 
bestimmt und im Ergebnisbild wird derjenige dieser beiden Werte eingetragen, 
der näher am Originalgrauwert liegt. 
}

\proch{int}{SkelettImg}{const Image \&src,const Image \&dest,int lvl=1}{filter.h}
\descr{Erzeugt nach dem Algorithmus von Zhang und Suen ein binäres Skelettbild. 
Dabei wird das Quellbild als Binärbild betrachtet, in dem Grauwerte größer 
gleich $lvl$ als Objekt-, die anderen als Untergrundpunkte betrachtet werden. 
Das Ergebnis ist ein Binärbild, in dem die Skelett-Punkte mit dem maximalen 
Grauwert eingetragen sind. Untergrundpunkte haben den Wert 0.}

\subsection{Globale lineare Filterung}

Als globale lineare Filterungs-Funktionen stellt ICE die
Faltung zweier Bilder und deren Umkehrung bereit. Die linearen 
globalen Filterungs-Funktionen basieren auf der Fourier- und der
Hartleytransformation und sind deshalb dort dokumentiert.
\newline
\seealso{FourierImgD} \\
\seealso{HartleyImgD} \\
\seealso{ConvolutionImg} \\
\seealso{InvConvolutionImg} 

 
\newpage
\makeatletter{}\nsection{Konturen, Kanten und Regionen}{conturs}

\subsection{Konturfolge}
\label{Konturen}

\subsubsection{Objekte}
Die Konturfolge dient in der Bildverarbeitung dazu, Objekte zu finden. Das
Innere der gefundene Kontur repräsentiert im Bild das Objekt. Ausgangspunkt
ist die Möglichkeit, für jedes einzelne Pixel im Bild die Entscheidung fällen
zu können, ob es sich um einen Untergrund- oder einen Objektpunkt handelt. Im
einfachsten Falle geschieht dies durch die Festlegung eines Grauwert-Pegels:
Alle Punkte mit Werten größer gleich diesem Schwellwert sind Objektpunkte,
die anderen Untergrundpunkte.

\begin{figure}[h]
  \epsfig{figure=contur1.eps,width=8cm}
  \label{object}
  \caption{Ein Objekt und seine Kontur}
\end{figure}

Im Bild sind Objektpunkte blau markiert. Randpunkte eine Objekts
sind Objektpunkte, in deren 4-Nachbarschaft Untergrundpunkte
liegen. Randpunkte und benachbarte Untergrundpunkte bilden
Objekt-/Untergrund-Punktpaare. Umläuft man das Objekt, so entsteht eine Folge
von Objekt-/Untergrundpaaren, die die Kontur bilden. In ICE wird als Contur
die Folge der Randpunkte des Objekts abgelegt, die zugehörigen Untergrundpunkte
lassen sich eindeutig rekonstruieren.

Grundidee der Konturfolge ({\see{CalcContur}}) ist, daß man zunächst 
zeilenweise oder spaltenweise das Bild durchmustert und einen Startpunkt 
sucht. Ein geeigneter Startpunkt ist der erste Objektpunkt nach einem
Untergrund-/Objekt-Übergang. Ausgehend von diesem bekannten
Objekt-/Untergrund-Punktpaar wird dann in der Nachbarschaft nach weiteren
Paaren gesucht und so die Kontur verfolgt (gestrichelte Linie). Nach dem
Umlauf um das Objekt kehrt der Algorithmus immer zum Startpunkt zurück. Die
Konturen sind deshalb immer geschlossene Konturen, der Start- und der Endpunkt
sind dieselben. Geschlossene Konturen umschließen eine Fläche und besitzen
deshalb zusätzliche Merkmale, z.B. die Fläche und den Formfaktor.

\subsubsection{Löcher}
\begin{figure}[h]
  \epsfig{figure=contur2.eps,width=8cm}
  \label{fig:hole}
  \caption{Das Loch im Objekt und seine Kontur}
\end{figure}

In analoger Weise werden Konturen von Löchern gefunden. Trifft der Algorithmus
auf ein Loch, so findet in genau gleicher Weise eine Konturfolge statt. Im
Bild sind die Objekt-/Untergrund-Punktpaare und der Weg der
Konturfolge für das Loch in dem Objekt dargestellt. Der Pfeil an der
gestrichelten Konturlinie verdeutlicht, daß der Umlaufsinn einer Lochkontur
entgegengesetzt zur Kontur eines Objekts ist. Auch Lochkonturen sind immer
geschlossen. Wegen des negativen Umlaufsinns ist der Flächeninhalt einer
Lochkontur negativ.

\subsubsection{Undefinierte Punkte}
\label{UndefiniertePunkte}

\begin{figure}[h]
  \epsfig{figure=contur3.eps,width=8cm}
  \label{fig:hole}
  \caption{Konturfolge und undefinierte Punkte}
\end{figure}

Oft entsteht die Situation, daß die Entscheidung Objekt oder Untergrund nicht
für jedes Pixel eindeutig zu treffen ist. Dies gilt zum Beispiel auch für
Punkte außerhalb des Bildes. Oft werden diese der Einfachheit halber als
Untergrund-Punkte behandelt, genaugenommen ist eine solche Aussage nicht
möglich. Eine ähnliche Situation kann für Punkte im Bild entstehen. Diese
Punkte wollen wir im folgenden als ''undefiniert'' betrachten. Das Bild 
verdeutlicht diese Situation. Undefinierte Punkte sind rot markiert.

Die Kontur läßt sich jetzt immer noch genauso als Folge von
Objekt-/Untergrund-Punktpaaren definieren. Der Übergang von einer dualen 
Entscheidung zur ternären Entscheidung mit Objekt-Punkten, Untergrund-Punkten
und undefinierten Punkten hat zur Folge, daß die gefundenen Konturen nicht 
geschlossen sein müssen.

\subsection{Die Klasse Contur}
\hypertarget{Contur}{}

Für die Speicherung und Bearbeitung von Konturen wird die Klasse \class{Contur}
verwendet. Konturen entstehen als Ergebnis der Objektsuche im Bild 
mittels Konturfolge. Aber auch beliebige ebene geometrische 
Figuren als \class{Contur} beschrieben werden. 

Die Datenstruktur \class{Contur} repräsentiert eine Folge von Punkten, wobei 
in der Folge benachbarte Punkte auch im Bild benachbart sind. Sind Anfangs-
und Endpunkt der Punktfolge identisch, so ist die Kontur
geschlossen. Geschlossene Konturen umschließen eine Fläche und besitzen
deshalb zusätzliche Merkmale, z.B. die Fläche und den Formfaktor. Je nach
Umlaufsinn um die Fläche ist der Flächeninhalt positiv (positiver Umlaufsinn,
Objekt-Kontur) oder negativ (negativer Umlaufsinn, Loch-Kontur).

\subsubsection{Konstruktoren und Destruktoren}

\proch{}{Contur::Contur}{}{contur.h}
\descr{
Legt eine (noch ungültige) Kontur an. Für derartige, nicht initialisierte
Konturen hat $valid$ den Wert $false$. \\
\seealso{Contur::isValid}\\
Fehlgeschlagene Funktionen, die Konturen zurückliefern, geben ebenfalls
eine derartige Kontur zurück.
}
\proc{}{Contur::Contur}{const Contur \&c}
\descr{
Legt eine Kopie der Kontur $c$ an.
}

\procf{}{Contur::Contur}{IPoint p}
\proc{}{Contur::Contur}{int x,int y}
\descr{
Legt eine Kontur mit dem Startpunkt $p$ bzw. ($x,y$) an. Die Kontur hat die
Länge Null. 
}

\subsubsection{Erstellung und Bearbeitung einer Kontur}
Konturen werden nach der Definition eines Startpunktes (kann auch
beim Konstruktor schon geschehen) durch Anhängen weiterer Teile
aufgebaut. Angehängt werden Richtungscodes, Verbindungslinien zu 
weiteren Punkten oder ganze Konturen.

\proc{int}{Contur::Reset}{}
\descr{Die Kontur wird zurückgesetzt und ist danach wieder undefiniert 
(isValid()==false).\\
\seealso{Contur::isValid}
}

\proc{int}{Contur::Reset}{IPoint p}
\procf{int}{Contur::Reset}{int x,int y}
\descr{Die Kontur wird zurückgesetzt und mit dem Startpunkt $p$ bzw. $(x,y)$
neu initialisiert.
}

\proc{int}{Contur::SetStart}{IPoint p}
\procf{int}{Contur::SetStart}{int x,int y}
\descr{Der Startpunkt der Kontur wird auf ($x,y$) bzw. $p$ gesetzt. 
Dabei wird eine bis dahin ungültige Kontur gültig und hat die Länge 0. 
Bei einer bereits vorhandenen Kontur wird der Startpunkt versetzt, was 
einer Verschiebung der ganzen Kontur entspricht.}

\proc{int}{Contur::Add}{Freeman dir}
\descr{Hängt an eine gültige Kontur den Richtungskode $dir$
(Freeman-Richtung) an.\\
\seealso{Freeman}
}

\proc{int}{Contur::Add}{IPoint p}
\procf{int}{Contur::Add}{int x,int y}
\descr{Hängt an eine gültige Kontur die geradlinige Verbindung 
zu einem Punkt an.}

\proc{int}{Contur::Add}{const Contur \&c}
\descr{Hängt an eine gültige Kontur die Kontur $c$ an. 
Dazu wird zunächst die geradlinige Verbindung zwischen bisherigen 
Endpunkt der Kontur und dem Startpunkt der Kontur $c$ hergestellt
und dann die weiteren Punkte der Kontur $c$ angehängt.}

\proc{Contur}{operator+}{const Contur \&c1,const Contur \&c2}
\descr{ Die Verkettung der Konturen c1 und c2 wird zurückgegeben. 
Die Verkettung erfolgt genauso wie beim Anhängen einer Kontur 
an eine Kontur.}

\proc{void}{Contur::Close}{}
\descr{Schließt die Kontur, indem der Startpunkt angehängt wird.}

\proc{int}{Contur::InvDir}{}
\descr{Kehrt die Richtung der Kontur um. Die entstehende Kontur
besteht aus den gleichen Punkten, wird aber im entgegengesetzten
Umlaufsinn durchlaufen. \\
Achtung: Dadurch wird zwar eine Objekt-Kontur in eine Loch-Kontur
umgewandelt, es handelt sich aber nicht um das zum Objekt
komplementäre (flächengleiche) Loch.
}

\proc{Contur \&}{Contur::operator =}{const Trafo \&}
\descr{Zuweisungs-Operator}

\subsubsection{Abfrage elementarer Eigenschaften}

\proc{int}{Contur::isValid}{}   
\descr{Liefert den Wert {\bf true} genau dann, wenn es sich um eine gültige
(initialisierte) Kontur handelt.}
\proc{int}{Contur::Number}{}
\descr{Liefert die Anzahl der Richtungscodes innerhalb der Kontur.}
\proc{double}{Contur::Length}{}
\descr{Liefert die geometrische Länge der Kontur.}
\proc{int}{Contur::isClosed}{}
\descr{Liefert {\bf true}, falls es sich bei der Kontur um eine gültige
geschlossene Kontur handelt.}
\proc{IPoint}{Contur::Start}{}
\descr{Liefert den Startpunkt der Kontur.}
\proc{IPoint}{Contur::End}{}
\descr{Liefert den Endpunkt der Kontur.}
\proc{int}{Contur::StartX}{}
\procf{int}{Contur::StartY}{}
\descr{Liefert die Koordinaten des Startpunktes der Kontur.}
\proc{int}{Contur::EndX}{}
\procf{int}{Contur::EndY}{}
\descr{Liefert die Koordinaten des Endpunktes der Kontur.}
\proc{int}{Contur::isHole}{}
\descr{Liefert {\bf true }, falls es sich bei der Kontur um eine 
geschlossene, gültige Kontur handelt, die ein Loch beschreibt.}
\proc{int}{Contur::getRect}{int \&xi,int \&yi,int \&xa,int \&ya}
\descr{Schreibt die Koordinaten des umschreibenden
Rechtecks der Kontur auf die Variablen $xi$, $yi$, $xa$ und $ya$.}
\seealso{FeatureContur}

\subsubsection{Zugriff auf Kontur-Daten}
\proc{Freeman}{Contur::getDirection}{int i}
\descr{Liefert den Freemancode an der Stelle $i$ in der Kontur. Gültige Werte 
von i liegen im Interval 0...Anzahl der Richtungscodes-1.\\
\seealso{Freeman}
\seealsonext{Contur::Number}
}

\proc{const std::vector\textless{}Freeman\textgreater{}\&}{Contur::getDirections}{}
\descr{Liefert eine Referenz auf einen vector aller Freemancodes der Kontur.\\
\seealso{Freeman}
\seealsonext{Contur::Number}
}

\proc{int}{Contur::getDirections}{std::vector\textless{}Freeman\textgreater{}\& fc}
\descr{Belegt Vector $fc$ mit den Freemancodes der Kontur.
\\
\seealso{Freeman}
\seealsonext{Contur::Number}
}
\proc{int}{Contur::getPairs}{std::vector\textless{}IPoint\textgreater{} \&opl,std::vector\textless{}IPoint\textgreater{} \&upl}
\procf{int}{Contur::getPairs}{std::vector\textless{}IPoint\textgreater{} \&pl,std::vector\textless{}Freeman\textgreater{} \&fc}
\descr{Ermittelt zu einer Kontur die Objekt/Untergrund-Pixelpaare. Das Ergebnis 
wird bereitgestellt als 
Liste von Objektpunkten $opl$ und Liste von Untergrundpunkten $upl$ oder als
Liste von Objektpunkten $pl$ und Liste von Richtungen $fc$, die vom Objektpunkt 
auf den Untergrundpunkt verweisen.}

\proc{int}{Contur::DirCode}{int i}
\descr{Liefert den Richtungscode an der Stelle $i$ in der Kontur.
Gültige Werte von i liegen im Interval 0...Anzahl der Richtungscodes-1.\\
\seealso{Freeman}
\seealsonext{Contur::Number}
}

\proc{IPoint}{Contur::getPoint}{int nr}
\procf{int}{Contur::getPoint}{int nr,int \&x,int \&y}
\descr{Berechnet den Punkt an der Stelle $nr$ der Kontur. Gültige
Werte von $nr$ liegen im Interval 0...Anzahl der Richtungscodes 
(\see{Contur::Number}). Der spezielle Wert $nr=0$ liefert den 
Startpunkt der Kontur, $nr=Contur::Number()$ liefert den 
Endpunkt der Kontur.\\
\seealso{Contur::Start}
\seealsonext{Contur::End}
}

\proc{void}{Contur::getPoints}{vector<IPoint> \&pl,bool close=false}
\descr{
Erzeugt eine Liste von Punkten der Kontur. Da bei geschlossenen Konturen der
Endpunkt gleich dem Anfangspunkt ist, kann für diese mit dem Parameter $close$ 
entschieden werden, ob der Endpunkt in die Liste aufgenommen ($close = true$)
oder weggelassen werden soll ($close = false$).
}

\proc{\bsee{IMatrix}}{ConturPointlist}{const Contur \&c,int diff=1,bool close=true}
\descr{Erzeugt aus einer Contur eine Liste von Punkten als \see{IMatrix}.
  Durch Angabe von $diff$ kann festgelegt werden, dass nur jeder diff. Punkt in 
  die Liste eingetragen wird. Bei offenen Konturen werden Anfangs- und Endpunkt immer in 
  die Liste eingetragen. Bei geschlossenen Konturen entscheidet der Parameter $close$,
  ob der Endpunkt, der ja gleich dem Anfangspunkt ist, an die Liste angehängt wird.
  Punktlisten werden beispielsweise beim adaptiven Fitting
  benötigt (\see{Adaptives Fitting}). }

\subsubsection{Kontur-Merkmale}
\proc{int}{FeatureContur}{Contur c,double \&length,double \&area,double
\&form,double \&conv}
\descr{
Für eine geschlossene Kontur $c$ werden die Merkmale Konturlänge $length$,
Anzahl der zu dem von der Kontur berandeten Objekt gehörenden Bildpunkte
$area$, Formfaktor $form$ und Konvexitätsmaß $conv$ berechnet. 
\begin{itemize}
\item Die Konturlänge
ergibt sich als Summe der Freemancodes, wobei gerade Richtungen mit 1 und
ungerade Richtungen mit $\sqrt 2$ gewichtet werden. 
\item Der Formfaktor wird nach
der Formel $form={length^2 \over 4\pi\cdot area}$ berechnet, so daß sich für
einen idealen Kreis der Wert 1 ergeben würde. Für reale Objekte ist der 
Formfaktor immer größer als 1. 
\item Die Konvexität wird nach der Formel $conv={3 \cdot l_0 +
l_1 \over 2 \cdot (x_a-x_i+y_a-y_i+p_a-p_i+ma-mi)}$ berechnet, wobei $l_0$ die
Anzahl der Richtungscodes, $l_1$ die Anzahl der ungeraden Richtungscodes,
$x_i=min(x)$, $x_a=max(x)$, $y_i=min(y)$, $y_a=max(y)$, $p_i=min(x+y)$,
$p_a=max(x+y)$, $m_i=min(x-y)$und $m_a=max(x-y)$ ist.
\end{itemize}
}

\proc{double}{RoughnessContur}{Contur c, int diff}
\descr{
Es wird ein Maß für die ``Rauhigkeit'' der Kontur $c$ als Verhältnis der
Konturlänge zur Länge eines Polygonzuges bestimmt, der sich ergibt, wenn man
Konturpunkte mit dem Abstand $diff$ in der Richtungscodeliste durch
Geradensegmente verbindet.
}

Als weitere Konturmerkmale lassen sich die Momente (\see{Moments}) und
invariante Momente ({\see{Invariante Momente}) berechnen.

\subsection{Kontursuche}

Die Konturfolge beruht auf einer Klassifikation der
Bildpunkte in ``Objektpunkte'' und ``Untergrundpunkte''. 
Konturpunkte, die mittels der Konturfolge (\see{CalcContur}) gefunden 
werden, sind stets Randpunkte des Objektes, also Objektpunkte, in 
deren (Vierer-)Nachbarschaft sich
Untergrundpunkte befinden. Die Konturfolge umrundet ein Objekt, indem
jeweils Objekt-/Untergrund-Punktpaare gefunden werden. Der Kontur 
werden die Objektpunkte hinzugefügt. Möglich ist auch eine Beschreibung der
Kontur durch Richtungskodes, die die Bewegung von Konturpunkt zu Konturpunkt
beschreiben.

Bei der binären Klassifikation ``Objekt'' / ``Untergrund''
ist gesichert, daß immer geschlossene Konturen gefunden werden.
Bei der dreiwertigen Unterscheidung der Pixel nach Objekt/Untergrund/Undefiniert
können auch offene Konturen gefunden werden (\see{UndefiniertePunkte}). 

Neben dem reinen Grauwertbild wird bei der Konturfolge auch ein
``Markierungsbild'' betrachtet. Markierte Punkte, also Punkte für die
der Wert im Markierungsbild ungleich Null ist, und Punkte außerhalb 
des Bildes werden standardmäßig als Untergrund betrachtet. Damit
können bestimmte (markierte) Bildbereiche bei der Konturfolge 
ausgeschlossen werden. Dies wird normalerweise auch dazu benutzt, 
um bereits gefundene Objekte von der weiteren Suche auszuschließen.

Es besteht auch die Möglichkeit, markierte Punkte und Punkte außerhalb 
des Bildes als ``Objekt'' bzw. ``Undefiniert'' zu erklären.
``Undefinierte'' Punkte sind weder Objektpunkte noch Untergrundpunkte. Dies
kann für Punkte verwendet werden, an denen keine Entscheidung für Objekt oder
Untergrund möglich ist. Die Konturfolge bricht ab, wenn es kein 
Objekt-/Untergrund-Punktpaar zur Fortsetzung gibt. Das kann der Fall 
sein, wenn undefinierten Punkte erreicht werden. Es entstehen so
offenen Konturen.

Standardmäßig wird eine Schwellwert-Entscheidung bezüglich des Grauwertes
verwendet, um über Objekt und Untergrund zu entscheiden.

Um die Konturfolge möglichst flexibel zu gestalten, kann aber auch eine 
eigene Funktion zur Bildpunktklassifikation definiert werden, die
durch einen Funktionspointer übergeben wird. Die Funktion muß dem 
folgenden Prototyp genügen\\
\\
object\_rc {\bf cls}(const Image \&iv,int x,int y,int thr)\\
\\
wobei $x$ und $y$ die Koordinaten des zu klassifizierenden Bildpunktes sind
und $thr$ ein Parameter für die Klassifikation, der von den Funktionen zur
Startpunkt- und Kontursuche durchgereicht wird. Als Funktionswert muß der 
Wert $isobject$ für Objektpunkte und $isunderground$  für 
Untergrundpunkte zurückgegeben werden. Undefinierte Punkte 
geben $isunknown$ zurück.

Wenn für die Klassifikationsfunktion der Null-Pointer übergeben wird, 
wird die Funktion {\em ObjectThr} verwendet, die die übliche pegelbasierte
Konturfolge verwirklicht. Bildpunkte, deren Grauwerte größer oder gleich 
$thr$ sind, werden als Objektpunkte klassifiziert, sofern sie nicht 
markiert sind. Der Einsatz von {\em ObjectThrInv}
invertiert dieses Verhalten: Objekte sind Punkte mit niedrigem Grauwert, also
einem Grauwert kleiner als $trsh$.

Die Klassifikationsfunktion {\em LocalSegObj} kann zusammen mit den lokalen
Segmentierung mittels \see{LocalSeg} verwendet werden oder wenn andersweitig
bereits ein Bild vorliegt, dessen Pixelwerte zwischen Objekt (=1), Untergrund
(=0) und undefiniert (=2) unterscheiden. Der Parameter $thr$ hat hier keine
Bedeutung. 

\proch{double}{CalcThreshold}{const Hist \&h}{threshold.h}
\procf{double}{CalcThreshold}{const Hist \&h,double \&discmax}
\procf{int}{CalcThreshold}{const Histogram \&h}
\procf{int}{CalcThreshold}{const Histogram \&h,double \&discmax}
\descr{
Aus dem Histogramm $h$ wird nach der Methode von Otsu eine 
Schwelle zur Binarisierung und Konturdetektion bestimmt. Die Variable
$discmax$ wird mit dem maximierten Wert der Diskriminanzfunktion belegt.
}

\proc{int}{CalcThreshold}{Image img}
\procf{int}{CalcThreshold}{Image img,double \&discmax,int diff=1}
\descr{
Aus dem Bild $img$ wird mit Hilfe des Histogramms nach der Methode von Otsu
eine Schwelle zur Konturdetektion bestimmt. Die Variable
$discmax$ wird mit dem maximierten Wert der Diskriminanzfunktion belegt.
Für die Berechnung des Histogramms bei einem gegebenen Bild kann 
mit dem Parameter $diff$ festgelegt werden, dass nur jeder $diff$. Punkt 
verwendet wird.
}

\proch{int}{SearchStart}{Image iv,Image io,object\_rc (*cls)(),int thr,int
diff,int ps[2],int mode=HORZ}{contur.h}
\procf{int}{SearchStart}{Image iv,Image io,int (*cls)(),int thr,int
diff,IPoint \&ps,int mode=HORZ}
\descr{
Das Bild $iv$ wird auf Suchzeilen ($mode$=HORZ, Standard) bzw. 
Suchspalten ($mode$=VERT) im Abstand $diff$ nach einem Startpunkt für 
die Konturfolge durchsucht. Die Suche wird bei dem durch $ps$ gegebenen 
Punkt begonnen. Ein Startpunkt im Sinne dieser Funktion ist ein 
Objektpunkt, unter dessen 4-Nachbarn mindestens ein Untergrundpunkt ist. 
Der gefundene Startpunkt wird auf 
$ps$ zurückgegeben und dient als Ausgangspunkt für die Konturfolge 
mit CalcContur(). Wenn ein Startpunkt gefunden wurde, ist der 
Funktionswert OK, sonst NOT\_FOUND. Für die Startpunktsuche sind 
markierte Punkte und Punkte außerhalb des Bildes immer ``Undefiniert'' 
(=$isunknown$).
}

\proc{Contur}{CalcContur}{Image iv,Image io,object\_rc (*cls)(),int thr,int
ps[2],int lng=0,object\_rc marked=isunderground,object\_rc outside=isunderground}
\procf{Contur}{CalcContur}{Image iv,Image io,object\_rc (*cls)(),int thr,const IPoint \&ps,int lng=0,object\_rc marked=isunderground,object\_rc outside=isunderground}
\descr{
Ausgehend vom Startpunkt $ps$ wird die Kontur eines über die 4-Nachbarschaft
zusammenhängenden Objektes bestimmt. Für die Bildpunktklassifikation wird
normalerweise die gleiche Funktion und die gleiche Schwelle verwendet,
wie bei der Startpunktsuche (\see{SearchStart}). $lng$ gibt die maximal 
zulässige Konturlänge an, bei $lng=0$ (Standard) wird eine beliebig lange 
Kontur zugelassen.
Die wahlfreien Parameter $marked$ und $outside$ bestimmen, wie markierte
Punkte bzw. Punkte außerhalb des Bildes behandelt werden. 
Es gibt die Möglichkeiten:
\begin{itemize}
\item $isunderground$ - der Punkt wird als Untergrundpunkt betrachtet
\item $isobject$ - der Punkt wird als Objekt betrachtet
\item $isunknown$ - der Punkt wird als Undefiniert betrachtet
\end{itemize}
}

Am folgenden Beispiel soll die Verwendung der Funktionen demonstriert werden.

\begprogr\begin{verbatim}
/* Konturfolge */
#include <stdio.h>
#include <image.h>
#define PGL     10
#define IMG     "cont_t.tif"
void main(int argc,char *argv[])
{
  Image imgv = ReadImg(IMG);                     // Bild einlesen
  Image imgo = NewImg(imgv->xsize,imgv->ysize,3); // Markierungsbild anlegen
  ClearImg(imgo);                          // und löschen

  Show(OVERLAY,imgv,imgo);                 // Bilddarstellung

  IPoint start(0,0);                       // Startpunktsuche beginnt bei 0,0
  Contur c;

  while (SearchStart(imgv,imgo,NULL,PGL,1,start)==OK)
  {                                // solange weiterer Startpunkt gefunden
    c=CalcContur(imgv,imgo,NULL,PGL,start);   // Kontur verfolgen
    if (c.valid)
    {
      MarkContur(c,1,imgo);                // markieren 
    }
    else PutVal(imgo,start.x,start.y,1);   // als bearbeitet markieren
  }
  GetChar();
}
\end{verbatim}
\endprogr

\proc{Contur}{GetContur}{int ps[2],int (*cls)(int,int,void*),void *par,int lng}
\descr{
Ausgehend von dem Startpunkt $ps$ wird die Kontur der Funktion $cls()$
verfolgt. Für Objektpunkte muß der Funktionswert von $cls()$ Null sein
und für Punkte außerhalb des Objektes kleiner Null. 
Der Funktionswert -4 bewirkt einen Abbruch der Konturfolge, so daß 
eine offene Kontur erzeugt wird. Der Pointer $par$ dient zur 
Parameterübergabe an die Funktion $cls()$ und wird an diese durchgereicht.
}

\proch{int}{LocalSeg}{Image source,Image oimg,int neighb,int level}{lseg.h}
\descr{Die Funktion erzeugt aus dem Bild $source$ ein Bild $oimg$, in dem
  jedes Pixel einen Wert hat, der entscheidet ob das Pixel im
  Originalbild $source$ ein Objekt- (=LSobject) oder Untergrundp>ixel (=LSunderground) ist, 
  oder ob dies undefiniert (=LSunknown) ist. Die Entscheidung erfolgt, indem
  in der Umgebung $neighb$ das Maximum und das Minimum der Grauwerte gesucht
  werden. Überschreitet die Differenz vom Maximum und Minimum die Schwelle
  $level$, so wird anhand des Schwellwertes $(Maximum+Minimum)/2$ über Objekt
  und Untergrund entschieden. Sonst ist der Punkt undefiniert. Unter
  Verwendung der Funktion \see{LocalSegObj} kann das so erzeugte Bild für die
  Konturfolge verwendet werden.}

\proch{int}{LocalSeg}{Image source,Image oimg,int neighb,int level1,int level2}{lseg.h}
\descr{Analog zur Funktion LocalSeg mit einem Parameter $level$ erzeugt die
  Funktion aus dem Bild $source$ ein Bild $oimg$, in dem
  jedes Pixel eine einen Wert hat, der entscheidet ob das Pixel im
  Originalbild $source$ ein Objekt- (=LSobject) oder Untergrundpixel
  (=LSunderground) ist, oder ob dies undefiniert (=LSunknown) ist. Zusätzlich
  gibt es die Entscheidungsmöglichkeit schwaches Objekt (=LSweakobject) und
  schwacher Untergrund (=LSweakunderground).
  Die Entscheidung erfolgt, indem in der Umgebung $neighb$ das Maximum 
  und das Minimum der Grauwerte gesucht werden. 
  Überschreitet die Differenz vom Maximum und Minimum die Schwelle
  $level1$, so wird anhand des Schwellwertes $(Maximum+Minimum)/2$ über Objekt
  und Untergrund entschieden.
  Wird die nur (geringere) Schwelle $level2$ überschritten, so werden die
  Pixel als schwaches Objekt oder schwacher Untergrund klassifiziert.
  Sonst ist der Punkt undefiniert. 
  Unter Verwendung der Funktion \see{LocalSegObj} bzw. \see{LocalSegObjHigh} 
  können im so erzeugten Bild mittels Konturfolge schwache oder starke Objekte 
  gefunden werden.}


\subsection{Kantendetektion}

\proc{int}{GradThreshold}{Image img}
\descr{Aus dem Bild $img$ wird ein geeigneter Schwellwert für die
  Kantenverfolgung bestimmt. Für die Startpunktsuche kann dieser Wert direkt
verwendet werden, für die Kantenverfolgung kann er auf ca. ein Drittel
reduziert werden.
}
\proc{int}{SearchGradStart}{Image iv,Image io,int thr,int diff,int
ps[2],int mode}
\descr{
Das Bild $iv$ wird auf Suchzeilen ($mode$=HORZ) bzw. Suchspalten ($mode$=VERT)
im Abstand $diff$ nach einem lokalen Maximum des Gradientenbetrages
gesucht. Die Suche wird bei dem durch $ps$ gegebenen Punkt begonnen. Wenn
der Gradientenbetrag in einem lokalen Maximum den Wert $thr$ übersteigt, wird
der Punkt als Startpunkt für die Kantenverfolgung auf $ps$
zurückgegeben. Wenn ein Startpunkt gefunden wurde, ist der Funktionswert OK,
sonst NOT\_FOUND.
}
\proc{int}{SearchCircStart}{Image iv,Image io,int c[2],int r,int pgl,int
ps[2]}
\descr{
Auf einem Kreis um den Punkt $c$ mit dem Radius $r$ wird nach einem lokalen
Maximum des Gradientenbetrages gesucht. Wenn der Gradientenbetrag in einem
lokalen Maximum den Wert $thr$ übersteigt, wird der Punkt als Startpunkt für
die Kantenverfolgung auf $ps$ zurückgegeben. Wenn ein Startpunkt gefunden
wurde, ist der Funktionswert OK, sonst NOT\_FOUND.
}
\proc{int}{SearchCStart}{Image iv,Image io,Contur c,int *ptr,int pgl,int ps[2]}
\descr{
Auf der durch $c$ gegebenen Kurve wird nach einem lokalen Maximum des
Gradientenbetrages gesucht. Die Suche wird bei dem $*ptr$-ten Punkt
begonnen. Wenn der Gradientenbetrag in einem lokalen Maximum den Wert $thr$
übersteigt, wird der Punkt als Startpunkt für die Kantenverfolgung auf $ps$
zurückgegeben und die aktuelle Position wird für eine spätere Weitersuche auf
$*ptr$ bereitgestellt. Wenn ein Startpunkt gefunden wurde, ist der Funktionswert OK,
sonst NOT\_FOUND.
}
\proc{Contur}{CalcGradContur}{Image iv,Image io,int thr,int maxg,int ps[2],int lng}
\descr{
Ausgehend vom Startpunkt $ps$ wird eine Kante (Kurve mit maximalem
Gradientenbetrag) verfolgt (in beiden Richtungen), solange der
Gradientenbetrag größer als $thr$ ist. Die Bildpunkte mit dem größeren
Grauwert liegen jeweils rechts der Kante. Kleinere Lücken der 
Länge $maxg$ werden übersprungen, wenn noch ein lokales Maximum 
des Gradientenbetrages vorhanden
ist. Der Wert $thr$ kann kleiner sein, als bei der Startpunktsuche
(ca. 1/3). $lng$ gibt die maximal zulässige Konturlänge an, bei $lng=0$ wird
eine beliebig lange Kontur zugelassen.
}

\begprogr\begin{verbatim}
/* Kantendetektion */
#include <stdio.h>
#include <image.h>
#define PGL     10
#define IMG     "cont_t.tif"
void main(int argc,char *argv[])
{
  Image imgv,imgo;
  Contur c;
  int ps[2]={0,0};
  imgv=ReadImg(IMG,NULL);                    /* Bild einlesen */
  imgo=NewImg(imgv->xsize,imgv->ysize,63);   /* Overlaybild anlegen */
  ClearImg(imgo);
  Show(OVERLAY,imgv,imgo);                   /* Bilddarstellung */
  Display(ON);
  while(SearchGradStart(imgv,imgo,PGL,5,ps,HORZ)==OK)
  {                                          /* Bild nach Startpunkt durchsuchen */
    c=CalcGradContur(imgv,imgo,PGL,0,ps,0);  /* Kontur verfolgen */
    if (c.valid)
    {
      MarkContur(c,1,imgo);                  /* Kontur markieren */
    }
    ps[0]++;
  }
  getchar();
  Display(OFF);
}
\end{verbatim}\endprogr

\subsection{Liniendetektion}

\proc{int}{RidgeThreshold}{Image img}
\descr{Aus dem Bild $img$ wird ein geeigneter Schwellwert für die Linienverfolgung
bestimmt. Für die Startpunktsuche kann dieser Wert direkt verwendet werden,
für die Linienverfolgung kann er auf ca. ein Drittel reduziert werden.
}
\proc{int}{SearchRidgeStart}{Image imgv,Image imgo,int thr,int diff,int ps[2],int
mode}
\descr{Das Bild wird zeilenweise ($mode$=HORZ) bzw. spaltenweise ($mode$=VERT), beginnend
bei $ps$ nach einem Startpunkt für die Linienverfolgung durchsucht. Die
Suchzeilen bzw. -Suchspalten haben den Abstand $diff$. Die Startpunktsuche stopt
an Punkten, deren Laplacewert in x- bzw y-Richtung größer als $thr$ ist und in
deren direkter Nachbarschaft kein Punkt markiert ist. Der Schwellwert $thr$
sollte mit Hilfe der Funktion RidgeThreshold bestimmt werden. Wenn ein Startpunkt
gefunden wurde, ist der Funktionswert OK, sonst NOT\_FOUND.
}
\proc{Contur}{CalcRidgeContur}{Image imgv,Image imgo,int thr,int ps[2],int lng}
\descr{Ausgehend vom Startpunkt $ps$ wird (in beiden Richtungen) eine Linie
(``Kammlinie im Grauwertgebirge'') verfolgt. Die Linienverfolgung wird
abgebrochen, wenn sich eine Fortsetzung nicht mindestens um den Wert $thr$ vom
Untergrund abheben würde oder wenn ein markierter Punkt erreicht wird. Der
Schwellwert $thr$ sollte mit Hilfe der Funktion RidgeThreshold() bestimmt
werden.
}

\subsection{Konturlisten}
\hypertarget{ConturList}{}

Für die Analyse komplexerer Szenen wird die Verwaltung von 
Konturen in Listen unterstützt. Die Klasse \class{ConturList} liefert
die Methoden zur Verwaltung von Konturen in Listen.

\proc{}{ConturList::ConturList}{}
\descr{Anlegen einer leeren Konturliste.}
\proc{}{ConturList::ConturList}{const ConturList\& cl}
\descr{Anlegen einer neuen Konturliste als Kopie der 
übergebenen Konturliste $cl$.}

\proc{ConturList \&}{ConturList::operator=}{const ConturList\& cl}
\descr{Kopieren der Konturliste $cl$ in die Konturliste.}

\proc{int}{ConturList::Add}{const Contur \&c}
\descr{Die Kontur $c$ wird an die Liste angehängt. In der
Liste wird eine Kopie von $c$ angelegt, so daß $c$ freigegeben oder
andersweitig weiter verwendet werden kann.}
\proc{int}{ConturList::Del}{int i}
\descr{Die Kontur mit Index $i$ wird aus der Konturliste entfernt.}

\proc{Contur *}{ConturList::GetContur}{int i}
\descr{Es wird ein Zeiger auf die Kontur Nummer $i$ zurückgegeben.}

Die Anzahl der Konturen kann über die konstante Referenz 
ConturList::number abgefragt werden.

Das folgende Beispiel zeigt die Verwendung einer Konturliste:

\begprogr
\begin{verbatim}
/* Arbeit mit Konturlisten */
#include <stdio.h>
#include <image.h>

#define PGL     10
#define IMG     "cont_t.tif"

void main(int argc,char *argv[])
{
  Image imgv,imgo;
  Contur c;
  ConturList cl;
  int ps[2]={0,0};
  imgv=ReadImg(IMG,NULL);                  // Bild einlesen
  imgo=NewImg(imgv->xsize,imgv->ysize,63); // Overlaybild anlegen
  ClearImg(imgo);                          // und löschen

  while(SearchStart(imgv,imgo,NULL,PGL,5,ps,HORZ)==OK)
  {                                        // Bild nach Startpunkt durchsuchen
    c=CalcContur(imgv,imgo,NULL,PGL,ps,0); // Kontur verfolgen 
    if (c.valid)                           // Konturfolge erfolgreich ?
    {
        cl.Add(c);                         // Kontur in liste eintragen
        MarkContur(c,1,imgo);              // markieren 
    }
    else PutVal(imgo,x,y,1);               // Punkt als bearbeitet markieren
  }
                                           // nun alle Konturen füllen
  for (i=0;i<cl.number;i++)                // Schleife über alle Konturen
  {
    FillRegion(*(cl.GetContur(i)),2,imgo);
  }

// jetzt Konturliste mit einer leeren Konturliste überschreiben
// alle gespeicherten Konturen gehen verloren und der Speicher
// wird freigegeben

  cl=ConturList();
}
\end{verbatim}
\endprogr

\subsection{Hilfsfunktionen zur Arbeit mit Konturen}
\proc{bool}{pointInside}{double x,double y,const Contur \&c}
\procf{bool}{pointInside}{const Point \&p,const Contur \&c}
\proc{bool}{pointInside}{double x,double y,const Matrix \&pl}
\procf{bool}{pointInside}{const Point \&p,const Matrix \&pl}
\descr{
 Für einen gegebenen Punkt wird entschieden, ob dieser innerhalb einer 
gegebenen Kontur bzw. innerhalb eines gegebenen Polygons liegt. Das Gebiet 
innerhalb der Kontur/des Polygons ist durch die stetige Verbindungslinie 
benachbarter Punkte definiert (einschließlich dieser Linie).}

\proc{}{conturFromPolygon}{const Matrix \&pl,Contur \&c}
\descr{
Aus dem in der Punktliste $pl$ gegebenen Polygon wird eine Kontur
erstellt. Die Konturpunkte sind dabei die äußersten Pixel, deren Mittelpunkte
noch innerhalb des Polygons liegen (einschließlich Rand).}

\subsection{Arbeiten mit Richtungen}
\hypertarget{Freeman}{}

Diskrete Richtungen werden oft mit dem Freeman-Code angegeben. 

\begin{figure}
  \epsfig{figure=freeman.eps,width=5cm}
  \label{fig:freeman}
  \caption{Die Freeman-Richtungskodes}
\end{figure}

Die Klasse \class{Freeman} enthält einen entsprechenden Richtungswert und erlaubt Operationen auf diesem,
wobei der zyklische Character der Richtungscodes berücksichtigt wird. Richtungen vom Typ Freeman 
lassen sich durch einen Typwandlungskonstruktor aus int-Werten erzeugen und mittels der Methode 
Int() wieder in int-Werte umwandeln.

Die Operationen zur Verschiebung eines Punktes beziehungsweise zur Berechnung des Nachbarn in
einer Richtung verwenden die folgenden Offsets.

\begin{tabular}{|l|c|c|c|c|c|c|c|c|} \hline
$dir$     & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\ \hline
$\Delta x$ & 1 & 1 & 0 & -1 & -1 & -1 & 0 & 1 \\ \hline
$\Delta y$ & 0 & 1 & 1 & 1 & 0 & -1 & -1 & -1 \\ \hline
\end{tabular}

\subsubsection{Konstruktoren und Typwandlung}

\proch{}{Freeman::Freeman}{}{freeman.h}
\descr{Standard-Konstruktor. Erzeugt eine Richtung mit dem Freemancode 0.}

\proch{}{Freeman::Freeman}{int dir}{freeman.h}
\descr{Typwandlungs-Konstruktor. Erzeugt eine Richtung mit dem Freemancode $dir$. Werte außerhalb
des Intervalls 0..7 werden Modulo 8 behandelt.}

\proch{}{Freeman::Freeman}{const Freeman \&sec}{freeman.h}
\descr{Kopierkonstruktor}

\proc{int}{Freeman::Int}{} 
\descr{Liefert den Richtungscode als int-Wert im Intervall 0..7 .}

\subsubsection{Anwendung auf Punkte}

\proch{void}{Freeman::move}{int x,int y,int \&xn,int \&yn}{freeman.h}
\descr{Berechnet das Ergebnis der Verschiebung des Punktes $(x,y)$ um 
einen Schritt und gibt das Ergebnis auf $xn$ und $yn$ zurück.}

\proch{void}{Freeman::move}{int \&x,int \&y}{freeman.h}
\descr{Verschiebt den Punkt (x,y) um einen Schritt.}

\proch{void}{Freeman::move}{IPoint p1,IPoint \&p2}{freeman.h}
\descr{Berechnet das Ergebnis der Verschiebung des Punktes $p1$ um 
einen Schritt und gibt das Ergebnis auf $p2$ zurück.}

\proch{void}{Freeman::move}{IPoint \&p}{freeman.h}
\descr{Verschiebt den Punkt $p$ um einen Schritt.}

\proch{IPoint}{Freeman::step}{IPoint \&p}{freeman.h}
\descr{Berechnet das Ziel eines Schrittes vom Punkt $p$.}

\subsubsection{Operatoren}
Die Operatoren rechnen analog zum Typ int mit den Richtungskodes, berücksichtigen 
aber, dass Richtungskodes zyklisch sind ($7+1 \rightarrow 1$).

\begin{tabular}{ll}
Operator      & Bedeutung \\
\verb#a + b#  & Summe \\
\verb#a += b# & \verb#a = a + b# \\
\verb#a - b#  & Differenz \\
\verb#a -= b# & \verb#a = a - b# \\
\verb#a++#    & \verb#a += 1# \\
\verb#++a#    & \\
\verb#a--#    & \verb#a -= 1# \\
\verb#--a#    & \\
\verb#a==b#   & Test auf Gleichheit \\
\end{tabular}

\proch{Freeman}{Inverse}{}{freeman.h}
\descr{Berechnet die entgegengesetzte Richtung.}


\subsection{Regionen}
\hypertarget{Region}{}

Regionen sind Mengen von Bildpunkten. Regionen beschreiben Gebiete in Bildern,
die nicht notwendigerweise zusammenhängen müssen. Genauso ist es möglich, dass
Regionen Löcher aufweisen. Mittels der Klasse \class{Region} können solche Gebiete
erfaßt, dargestellt und bearbeitet werden. Ausgangspunkt für die Berechnung von
Gebieten können \class{Konturen} sein. Es ist auch möglich, Regionen aufzubauen,
indem zu anfänglich leeren Regionen Punkte(Pixel), Fenster (\class{Window}) 
und andere Regionen hinzugefügt werden.\\
Zur Anwendung von Regionen siehe auch \see{RegionGrow}.

\subsubsection{Konstruktoren und Konvertierungen}

\ctor{Region}{}{region.h}
\descr{Legt eine leere Region an.}

\ctor{Region}{const Region \&r}{region.h}
\descr{Legt eine Kopie der Region $r$ an.}

\ctor{Region}{const Contur \&c}{region.h}
\descr{Legt eine Region an, die die inneren und Randpunkte der Kontur $c$ umfasst.}

\subsubsection{Regionen-Arithmetik}
Unter Regionen-Arithmetik werde die Konstruktion von Regionen durch Hinzufügen
und Entfernen von Punkten(Pixel), Fenstern (achsparallele Rechtecke) und
Regionen verstanden. 
Bei Verwendung der Ausdruck-Schreibweise (Operatoren +, - und \&) ist zu 
beachten, dass die dabei notwendige Erzeugung temporärer Objekte
Zeit- und Speicherplatz-aufwendig ist.

\method{void}{add}{int x,int y}
\methodf{void}{add}{const IPoint \&p}
\methodf{void}{add}{const Point \&p}
\descr{Fügt den durch die Koordinaten $x$ und $y$ bzw. durch Point $p$
  gegebenen Punkt der Region hinzu.}

\method{void}{add}{int x1,int y1,int x2,int y2}
\methodf{void}{add}{const Window \&w}
\descr{Fügt das durch die Eckpunkte $x1,y1$,$x2,y2$ gegebene achsparallele
  Rechteck bzw. das \class{Window} w der Region hinzu.}

\method{void}{add}{const Region \&r}
\descr{Fügt die Region $r$ der Region hinzu.}

\method{const Region \&}{operator +=}{const Region \&r2}
\descr{Vereinigung mit der Region r2.}

\method{Region}{operator +}{const Region \&r1,const Region \&r2}
\descr{Vereinigt die beiden Regionen und gibt die vereinigte Region als
  Funktionswert zurück.}

\method{void}{del}{int x,int y}
\methodf{void}{del}{const Point \&p}
\methodf{void}{del}{const IPoint \&p}
\descr{Entfernt den durch die Koordinaten $x$ und $y$ bzw. durch Point p
  gegebenen Punkt aus der Region.}

\method{void}{del}{int x1,int y1,int x2,int y2}
\descr{Entfernt das durch die Eckpunkte $x1,y1$,$x2,y2$ gegebene 
achsparallele Rechteck aus der Region.}

\method{void}{del}{const Region \&r}
\descr{Entfernt die Region $r$ aus der Region.}

\method{Region}{operator -}{const Region \&r1,const Region \&r2}
\descr{Bildet eine neue Region aus Punkten, die in $r1$ enthalten und in $r2$
  nicht enthalten sind und gibt diese Region als Funktionswert zurück.}


\subsubsection{Abfrage von Eigenschaften}

\method{bool}{inside}{int x,int y}
\descr{Gibt zurück, ob der Punkt $x,y$ in der Region enthalten ist}

\method{bool}{isEmpty}{void}
\descr{Gibt zurück, ob die Region leer ist, also keine Punkte enthält}

\method{int}{getArea}{}
\descr{Gibt die Fläche der Region (=Zahl der Pixel) zurück.}

\method{int}{CalcMoments}{Moments \&m}
\descr{Berechnet die Momente der Region und legt das Ergebnis in der
  Datenstruktur m von Typ \class{Moments} ab.}

\method{void}{getPoints}{\vector{IPoint} \&points}
\descr{Gibt eine Punktliste aller Punkte der Region zurück.}
 
\newpage
\makeatletter{}\nsection{Klassen-Hierarchie Geometrisches Objekt}{geoObject}

Alle Klassen, die der Beschreibung von geometrischen Objekten der Ebene 
dienen, leiten sich von der abstrakten Basis-Klasse \class{GeoObject} ab.
In dieser Klasse wird das grundsätzliche Verhalten der Methoden 
beschrieben, die in den abgeleiteten Klassen reimplementiert werden. 

\vspace{1cm}
\noindent
Klassen-Hierarchie:

\begin{description}
\item[\see{GeoObject}] Abstrakte Basisklasse
\begin{description}
\item[\see{Circle}] Kreis
\begin{description}
\item[\see{CircleSeg}] Kreissegment
\item[\see{Ellipse}] Ellipse
\begin{description}
\item[\see{EllipseSeg}] Ellipsensegment
\end{description}
\end{description}
\item[\see{LineSeg}] Strecke, Strahl oder Gerade
\item[\see{Triangle}] Dreieck
\item[\see{PolygonalCurve}] PolygonalCurve
\begin{description}
\item[\see{Polygon}] Polygon
\end{description}
\end{description}
\end{description}

\subsection{GeoObject}
\hypertarget{GeoObject}{}
\label{GeoObject}

GeoObject ist eine abstrakte Basisklasse für 
\hyperlink{geometricObject}{geometrische Objekte} der Ebene.

\proc{}{GeoObject::GeoObject}{}
\descr{Legt ein Objekt der Klasse GeoObject an.}
\proc{}{GeoObject::GeoObject}{const GeoObject \&c}
\descr{Legt ein Objekt der Klasse GeoObject an und initialisiert 
die Parameter mit den Werten des übergebenen Objektes (Kopierkonstruktor).}
\proc{}{GeoObject::GeoObject}{double xm,double ym}
\procf{explicit}{GeoObject::GeoObject}{Point m}
\procf{explicit}{GeoObject::GeoObject}{IPoint m}
\procf{explicit}{GeoObject::GeoObject}{const Vector \&v}
\descr{Legt ein Objekt GeoObject an und initialisiert die Koordinaten mit den
übergebenen Werten.}

\proch{Point}{GeoObject::getPos}{}{geo\_ob.h}
\descr{Liefert die Koordinaten (des Referenzpunktes) als \bsee{Point}.}

\proch{void}{GeoObject::setPos}{Point x}{geo\_ob.h}
\descr{Setzt die Koordinaten (des Referenzpunktes) des geometrischen Objekts. 
Dies stellt eine Verschiebung des ganzen Objektes dar.}

\proch{void}{GeoObject::Shift}{double dx,double dy}{geo\_ob.h}
\procf{void}{GeoObject::Shift}{Point p}
\descr{Verschieben des geometrischen Objekts um $dx$ in X-Richtung und 
$dy$ in Y-Richtung.}

\proch{double}{GeoObject::Distance}{double x,double y}{geo\_ob.h}
\procf{double}{GeoObject::Distance}{\bsee{IPoint} p}
\procf{double}{GeoObject::Distance}{\bsee{Point} p}
\descr{Ermittelt den Abstand zwischen dem gegebenen Punkt $p$ 
und der Randlinie des Objektes.
}
\proch{double}{GeoObject::Distance}{const GeoObject \&obj}{geo\_ob.h}
\descr{Ermittelt den Abstand des Referenzpunktes des
geometrischen Objektes $obj$ von der Randlinie des Objektes.}

\proch{bool}{GeoObject::Inside}{double xp,double yp}{geo\_ob.h}
\procf{bool}{GeoObject::Inside}{IPoint p}
\procf{bool}{GeoObject::Inside}{Point p}
\descr{Ermittelt, ob der Punkt (x,y) bzw. $p$ innerhalb des Objektes liegt. 
Die Methode der (abstrakten) Basisklasse $GeoObject$ liefert hier immer 
false zurück. Dies gilt auch für geometrische Objekte ohne Fläche wie 
z.B. \bsee{LineSeg}.
}

\subsection{Circle}
\label{Circle}
\hypertarget{Circle}{}

\begin{figure}[h]
  \epsfig{figure=circle.eps,width=5cm}
  \label{fig:circle}
\end{figure}

Die Klasse Circle ist direkt von der Basis-Klasse \class{GeoObject} abgeleitet
und repräsentiert Kreise in der Ebene.

\noindent
Konstruktoren:

\proc{}{Circle::Circle}{}
\descr{Legt ein Objekt Circle an.}
\proc{}{Circle::Circle}{const Circle \&c}
\descr{Legt ein Objekt Circle an und initialisiert die Parameter mit den
Werten des übergebenen Kreises (Kopierkonstruktor).}
\proc{}{Circle::Circle}{double xm,double ym,double r}
\procf{}{Circle::Circle}{Point m,double r}
\descr{Legt ein Objekt Circle an und initialisiert die Parameter mit den
übergebenen Werten für Mittelpunkt und Radius.}

\proc{explicit}{Circle::Circle}{const Vector \&c}
\descr{Legt ein Objekt Circle an und initialisiert die Parameter
des Mittelpunktes (xm,ym) und den Radius mit Werten aus dem 
übergebenen \see{Vector}.}

\proc{explicit}{Circle::Circle}{const double d[]}
\descr{Legt ein Objekt Circle an und initialisiert die Parameter 
des Mittelpunktes (xm,ym) und den Radius mit Werten aus dem 
übergebenen Feld d.}

\noindent
Methoden:
\proc{double}{Circle::getR}{}
\descr{Zugriff auf den Radius des Kreises.}
\proc{void}{Circle::setR}{double val}
\descr{Setzt den Wert des Radius auf den übergebenen Wert.}

Zu den wesentlichen ererbten und überschriebenen Methoden siehe:
\begin{itemize}
\item \see{GeoObject::setPos}, ..
\item \see{GeoObject::getPos}, ..
\item \see{GeoObject::Shift}
\end{itemize}

\subsection{CircleSeg}
\label{CircleSeg}
\hypertarget{CircleSeg}{}

\begin{figure}[h]
  \epsfig{figure=circleseg.eps,width=5cm}
  \label{fig:circle}
\end{figure}

Die Klasse \class{CircleSeg} ist über die Klasse \class{Circle} von der 
Basis-Klasse \class{GeoObject} abgeleitet und repräsentiert 
Kreis-Segmente (Kreisausschnitte) in der Ebene. 

\noindent
Konstruktoren:

\proc{}{CircleSeg::CircleSeg}{}
\descr{Legt ein Objekt CircleSeg an.}
\proc{}{CircleSeg::CircleSeg}{const CircleSeg \&c}
\descr{Legt ein Objekt CircleSeg an und initialisiert die Parameter mit den
Werten des übergebenen Kreis-Segments (Kopierkonstruktor).}
\proc{}{CircleSeg::CircleSeg}{double xm,double ym,double r,
  double phi1,double phi2}
\proc{}{CircleSeg::CircleSeg}{Point p,double r,double phi1,double phi2}
\descr{Legt ein Objekt CircleSeg an und initialisiert die Parameter mit den
übergebenen Werten für Mittelpunkt und Radius. 
$phi1$ und $phi2$ sind Anfangs- und Endwinkel des Segments bezogen auf die X-Achse.}

\proc{explicit}{CircleSeg::CircleSeg}{const Vector \&c}
\descr{Legt ein Objekt CircleSeg an und initialisiert die Koordinaten
des Mittelpunktes (xm,ym), den Radius und die Segmentwinkel mit Werten 
aus dem übergebenen \see{Vector}.}

\proc{explicit}{CircleSeg::CircleSeg}{const double d[]}
\descr{Legt ein Objekt CircleSeg an und initialisiert die Koordinaten
des Mittelpunktes (xm,ym), den Radius und die Segmentwinkel mit Werten 
aus dem übergebenen Feld d.}

\noindent
Methoden:
\proc{double }{CircleSeg::getPhi1}{}
\descr{Zugriff auf den Wert des Anfangswinkels.}
\proc{void}{CircleSeg::setPhi1}{double val}
\descr{Setzt den Wert des Anfangswinkels auf den übergebenen Wert.}
\proc{double}{CircleSeg::getPhi2}{}
\descr{Zugriff auf den Wert des Endwinkels.}
\proc{void}{CircleSeg::setPhi2}{double val}
\descr{Setzt den Wert des Endwinkels auf den übergebenen Wert.}

Zu den wesentlichen ererbten und überschriebenen Methoden siehe:
\begin{itemize}
\item \see{GeoObject::setPos}, ..
\item \see{GeoObject::getPos}, ..
\item \see{GeoObject::Shift}
\end{itemize}

\subsection{Ellipse}
\label{Ellipse}
\hypertarget{Ellipse}{}

\begin{figure}[h]
  \epsfig{figure=ellipse.eps,width=5cm}
  \label{fig:ellipse}
\end{figure}

Die Klasse Ellipse ist über die Klasse \class{Circle} von der 
Basis-Klasse \class{GeoObject} abgeleitet und repräsentiert Ellipsen
in der Ebene.

\noindent
Konstruktoren:

\proc{}{Ellipse::Ellipse}{}
\descr{Legt ein Objekt Ellipse an.}
\proc{}{Ellipse::Ellipse}{const Ellipse \&c}
\descr{Legt ein Objekt Ellipse an und initialisiert die Parameter mit den
Werten der übergebenen Ellipse (Kopierkonstruktor).}
\proc{}{Ellipse::Ellipse}{double xm,double ym,double r1,double r2,double phi}
\descr{Legt ein Objekt Ellipse an und initialisiert die Parameter mit den
übergebenen Werten für Mittelpunkt, große und kleine Halbachse und 
den Winkel $\varphi$.}

\proc{explicit}{Ellipse::Ellipse}{const Vector \&c}
\descr{Legt ein Objekt Ellipse an und initialisiert die Koordinaten
des Mittelpunktes (xm,ym), die Halbachsen und den Winkel $\varphi$ mit 
Werten aus dem übergebenen \see{Vector}.}

\proc{explicit}{Ellipse::Ellipse}{const double d[]}
\descr{Legt ein Objekt Ellipse an und initialisiert die Koordinaten
des Mittelpunktes (xm,ym), die Halbachsen und den Winkel $\varphi$ mit 
Werten aus dem übergebenen Feld $d$.}

\noindent
Methoden:
\proc{double}{Ellipse::getR1}{}
\descr{Liefert den aktuellen Wert der großen Halbachse zurück.}
\proc{void}{Ellipse::setR1}{double val}
\descr{Setzt den Wert der großen Halbachse auf den übergebenen Wert.}
\proc{double}{Ellipse::getR2}{}
\descr{Liefert den aktuellen Wert der kleinen Halbachse zurück.}
\proc{void}{Ellipse::setR2}{double val}
\descr{Setzt den Wert der kleinen Halbachse auf den übergebenen Wert.}
\begin{itemize}
\item Statt getR1() und setR1() können genauso die Methode getR() und setR() 
verwendet werden, die von \see{Circle} ererbt wurden. 
\item Wird durch Setzen mit diesen Methoden der Wert der kleinen Halbachse 
größer als der Wert der großen Halbachse werden in einer (internen)
Normalisierung die Werte vertauscht und der Winkel $\varphi$ angepaßt.
\end{itemize}

\noindent
Weiterhin sind die ererbten und überschriebenen Methoden von \class{Circle} und
\class{GeoObject} nutzbar.

\seealso{Circle::setR}
\seealsonext{Circle::getR} \\
\seealso{GeoObject::setPos}
\seealsonext{GeoObject::getPos}\\
\seealso{Draw}

\subsection{EllipseSeg}
\label{EllipseSeg}
\hypertarget{EllipseSeg}{}

\begin{figure}[h]
  \epsfig{figure=ellipseseg.eps,width=7cm}
  \label{fig:circle}
\end{figure}

Die Klasse \class{EllipseSeg} ist über die Klassen \class{Ellipse} 
und \class{Circle} von der Basis-Klasse \class{GeoObject} abgeleitet 
und repräsentiert Ellipsen-Segmente in der Ebene. 

\noindent
Konstruktoren:

\proc{}{EllipseSeg::EllipseSeg}{void}
\descr{Legt ein Objekt EllipseSeg an.}
\proc{}{EllipseSeg::EllipseSeg}{const EllipseSeg \&c}
\descr{Legt ein Objekt EllipseSeg an und initialisiert die Parameter mit den
Werten des übergebenen Ellipsen-Segments (Kopierkonstruktor).}
\proc{}{EllipseSeg::EllipseSeg}{double xm,double ym,double r1,double r2,double phi,double phi1,double phi2}
\descr{Legt ein Objekt EllipseSeg an und initialisiert die Parameter mit den
übergebenen Werten für Mittelpunkt, große und kleine Halbachse und 
Neigungswinkel $\varphi$ der Ellipse. $phi1 und $phi2 sind Anfangs-
und Endwinkel des Segments bezogen auf die große Achse der Ellipse.}

\proc{explicit}{EllipseSeg::EllipseSeg}{const Vector \&c}
\descr{Legt ein Objekt EllipseSeg an und initialisiert die Koordinaten
des Mittelpunktes (xm,ym), die Halbachsen, den Neigungswinkel und die 
Segmentwinkel mit Werten aus dem übergebenen \see{Vector}.}

\proc{explicit}{EllipseSeg::EllipseSeg}{const double d[]}
\descr{Legt ein Objekt EllipseSeg an und initialisiert die Koordinaten
des Mittelpunktes (xm,ym), die Halbachsen, den Neigungswinkel und die 
Segmentwinkel mit Werten aus dem übergebenen Feld $d$.}

\noindent
Methoden:
\proc{double}{EllipseSeg::Phi1}{void}
\descr{Liefert den aktuellen Wert des Anfangswinkels zurück.}
\proc{void}{EllipseSeg::setPhi1}{double val}
\descr{Setzt den Wert des Anfangswinkels auf den übergebenen Wert.}
\proc{double}{EllipseSeg::Phi2}{void}
\descr{Liefert den aktuellen Wert des Endwinkels zurück.}
\proc{void}{EllipseSeg::setPhi2}{double val}
\descr{Setzt den Wert des Endwinkels auf den übergebenen Wert.}
\seealso{Ellipse:setR1}
\seealsonext{Ellipse:getR1}
\seealsonext{Ellipse:setR2}
\seealsonext{Ellipse:getR2}\\
\seealso{GeoObject::setPos}
\seealsonext{GeoObject::getPos}

\noindent
Weiterhin sind die ererbten und überschriebenen Methoden von 
\class{Ellipse}, \class{Circle} und \class{GeoObject} nutzbar.

\noindent
\seealso{GeoObject::Draw}
\seealsonext{GeoObject::Shift}
\pagebreak
\subsection{LineSeg}
\label{LineSeg}
\hypertarget{LineSeg}{}

\begin{figure}[h]
  \epsfig{figure=lineseg.eps,width=12cm}
  \label{fig:circle}
\end{figure}

Die Klasse LineSeg ist direkt abgeleitet von der Basisklasse \class{GeoObject} 
und beschreibt Strecken, Strahlen und Geraden in der Ebene. Die Varianten
werden über ein Attribut $type$ unterschieden:
\begin{tabular}{|l|l|} \hline
  Typ & Wert \\ \hline
  Gerade & LineSeg::line \\ \hline
  Strahl & LineSeg::ray \\ \hline
  Strahl (in Gegenrichtung)& LineSeg::inv\_ray \\ \hline
  Strecke & LineSeg::segment \\ \hline
\end{tabular}

Die Strecken, Strahlen und Geraden der Klasse LineSeg sind gerichtet vom 
Startpunkt P1 zum Endpunkt P2. Diese Orientierung spielt in einigen Methoden 
eine Rolle (\bsee{LineSeg::RightOf},\bsee{LineSeg::OrientationAngle},
\bsee{LineSeg::Angle}).

\noindent

\subtitle{Konstruktoren}

\proc{}{LineSeg::LineSeg}{}
\descr{Legt ein Objekt LineSeg an.}
\proc{}{LineSeg::LineSeg}{Point p1,Point p2,int type=LineSeg::segment}
\descr{Legt ein Objekt LineSeg an und initialisiert mit den übergebenen Werten
von Startpunkt \see{Point} p1 und Endpunkt \see{Point} p2 der Strecke.}
\proc{}{LineSeg::LineSeg}{IPoint p1,IPoint p2,int type=LineSeg::segment}
\descr{Legt ein Objekt LineSeg an und initialisiert mit den übergebenen Werten
von Startpunkt \see{IPoint} p1 und Endpunkt \see{IPoint} p2 der Strecke.}
\proc{}{LineSeg::LineSeg}{const LineSeg \&p}
\descr{Legt ein Objekt LineSeg an und initialisiert mit den Werten des
übergebenen Objekts $p$ (Kopierkonstruktor).}
\proc{}{LineSeg::LineSeg}{double x1,double y1,double x2,double y2,int type=LineSeg::segment}
\descr{Legt ein Objekt LineSeg an und initialisiert mit den übergebenen Werten
von Startpunkt (x1,y1) und Endpunkt (x2,y2) der Strecke.}
\proc{}{LineSeg::LineSeg}{double p,double phi}
\descr{Legt ein Objekt LineSeg an und initialisiert mit den übergebenen Werten
der Hesseschen Geradenparameter. Der Typ ist $LineSeg::line$}
\proc{explicit}{LineSeg::LineSeg}{const Vector \&v,int type=LineSeg::segment}
\descr{Legt ein Objekt LineSeg an und initialisiert mit Werten für die
Start- und Endpunktkoordinaten aus dem übergebenen \see{Vector} v.}
\proc{explicit}{LineSeg::LineSeg}{double d[],int type=LineSeg::segment}
\descr{Legt ein Objekt LineSeg an und initialisiert mit Werten für die
Start- und Endpunktkoordinaten aus dem übergebenen Feld d.}
\noindent

\subtitle{Zugriffs-Methoden}

\proc{Point}{LineSeg::getP1}{}
\descr{Liefert die Koordinaten des Startpunktes als \bsee{Point}.}

\proc{Point}{LineSeg::getP2}{}
\descr{Liefert die Koordinaten des Endpunktes als \bsee{Point}.}

Die folgenden set-Methoden setzen nur den jeweiligen Endpunkt, im Gegensatz 
zu \bsee{GeoObject::setPos}.

\proc{void}{LineSeg::setP1}{Point p}
\descr{Setzt den Startpunkt auf $p$.}

\proc{void}{LineSeg::setP2}{Point p}
\descr{Setzt den Endpunkt auf $p$.}

\proc{int}{LineSeg::Type}{}
\descr{Gibt den Typ von LineSeg zurück.}
\proc{void}{LineSeg::setType}{int type}
\descr{Setzt den Typ des LineSeg auf $type$}

\subtitle{Parameterdarstellung}

Betrachten wir die Gerade gegeben durch die zwei Punkte $p_1$ und $p_2$, 
so wird ein Punkt der Geraden durch die Parameterdarstellung 
$p = p_1 + \mu \cdot (p_2 - p_1)$
beschrieben.

\proc{Point}{LineSeg::RelPoint}{double my}
\descr{Liefert den Punkt der Geraden, der in der Parameterdarstellung 
dem Parameter $my$ zugeordnet ist.}

\proc{double}{LineSeg::LimitedMy}{double my}
\descr{
Liefert zu einem gegebenen $my$ einen auf den jeweiligen Wertebereich 
beschränkten Wert zurück. Der Bereich ergibt sich aus dem Typ:\\
\begin{tabular}{|l|l|} \hline
  Typ & Wertebereich $\mu$ \\ \hline
  Gerade & $-\infty < \mu < \infty$ \\ \hline
  Strahl & $ 0 \le \mu < \infty$ \\ \hline
  Strahl (in Gegenrichtung)& $ -\infty < \mu \le 1$ \\ \hline
  Strecke & $ 0 \le \mu \le 1$ \\ \hline
\end{tabular}
}

\subtitle{Hessesche Normalform}

\proc{void}{LineSeg::CalcHesse}{double \&p,double \&phi}
\descr{
  Berechnet die Parameter $p$ und $phi$ der Darstellung der Geraden in 
  Hessescher Normalform $x \cdot cos(\varphi)+y \cdot sin(\varphi)=p$ .
  In der hier gewählten Normalisierung gilt $p \ge 0$ und $0 \le \varphi < 2 \cdot \pi$.
}
\proc{double}{LineSeg::P}{}
\descr{Liefert den Parameter $p$ der hessischen Normalform 
$x \cdot cos(\varphi)+y \cdot sin(\varphi)=p$ der Geraden}
\proc{double}{LineSeg::Phi}{}
\descr{Liefert den Parameter $\varphi$ der hessischen Normalform 
$x \cdot cos(\varphi)+y \cdot sin(\varphi)=p$ der Geraden}

\subtitle{Analytische Geometrie}

\proc{double}{LineSeg::OrientationAngle}{}
\descr{Liefert den Winkel des Vektors von p1 nach p2 bezüglich der X-Achse.}

\proc{double}{LineSeg::Angle}{const LineSeg \&sec}
\descr{Liefert den Winkel zwischen dem $LineSeg$ (*this) und $sec$. Dabei sind 
die beiden Geraden gerichtet und der Winkel wird zwischen $*this$ und $sec$ 
berechnet. Der Winkel ist immer nichtnegativ im Intervall $0 \le \varphi < \pi$.}

\proc{bool}{LineSeg::RightOf}{Point p}
\descr{Die Methode RightOf ermittelt, ob der gegebene Punkt $p$ rechts der 
{\bf Geraden} liegt. Dabei wird die Gerade als von Punkt p1 nach p2 
orientiert betrachtet bzw. in positiver Richtung der 
Parameterdarstellung $my$.
}

\proc{bool}{LineSeg::LeftOf}{Point p}
\descr{Die Methode LeftOf ermittelt, ob der gegebene Punkt $p$ links der 
{\bf Geraden} liegt. Dabei wird die Gerade als von Punkt p1 nach p2 
orientiert betrachtet bzw. in positiver Richtung der 
Parameterdarstellung $my$.
}

\proc{Point}{LineSeg::ClosestPoint}{Point p}
\procf{Point}{LineSeg::ClosestPoint}{Point p,double \&my}
\descr{Berechnet den zum Punkt $p$ nächstgelegenen Punkt auf der Geraden, auf
  dem Strahl oder auf der Geraden. Die zweite Aufrufform liefert zusätzlich 
den Parameter des Punktes in der Parameterdarstellung der Geraden}

\proc{double}{LineSeg::Distance}{Point p}
\descr{Liefert die Distanz des Punktes $p$ zum Geradensegment. Dies ist 
identisch zum Abstand des nächsten Punktes (\bsee{LineSeg::ClosestPoint})
der Geraden zu $p$.}

\proch{bool}{LineSeg::Intersection}{const LineSeg \&second}{lineseg.h}
\procf{bool}{LineSeg::Intersection}{const LineSeg \&second,Point \&ip}
\procf{bool}{LineSeg::Intersection}{const LineSeg \&second,Point \&ip,double \&my1,double \&my2}
\descr{Ermittelt, ob sich die Strecke, Strahl oder Gerade mit der als 
Parameter gegebenen zweiten Strecke, Strahl oder Gerade schneiden. Wenn 
als Parameter vorhanden, wird der Schnittpunkt als $ip$ zurückgegeben. Die 
Parameter $my1$ und $my2$ liefern die Parameterdarstellung des Schnittpunktes
bezüglich sich selbst (*this) bzw. $second$ zurück.
}

\proc{Point}{LineSeg::Normal}{}
\descr{Liefert die Normale auf der Geraden als \bsee{Point}.}

Zu den wesentlichen ererbten Methode siehe:
\begin{itemize}
  \item \bsee{GeoObject::setPos}
  \item \bsee{GeoObject::Shift}
\end{itemize}

\seealso{Draw}

\subsection{Triangle}
\label{Triangle}
\hypertarget{Triangle}{}
Dreiecke werden durch ihre drei Eckpunkte definiert.

\subtitle{Konstruktoren}

\proch{}{Triangle::Triangle}{}{triangle.h}
\descr{Standard-Konstruktor. Erzeugt ein Dreieck mit den 
Eckpunkten (-1,0), (0,1), (1,0).}

\proch{}{Triangle::Triangle}{Point p1, Point p2, Point p3}{triangle.h}
\descr{Erzeugt ein Dreieck mit den gegebenen Eckpunkten.}

\subtitle{Zugriffs-Methoden}

\proch{bool}{Triangle::isValid}{}{triangle.h}
\descr{Ein Dreieck ist gültig, wenn die Eckpunkte nicht auf 
einer geraden liegen. Im Falle einer solchen Entartung sind die
Parameter des Umkreises ungültig.}

\proc{Point}{Triangle::getCorner}{int i}
\procf{const Point \&}{Triangle::P1}{}
\procf{const Point \&}{Triangle::P2}{}
\procf{const Point \&}{Triangle::P3}{}
\descr{Abfrage der Eckpunkte. Die Eckpunkte werden intern umgeordnet. Ihre
Zuordung entspricht nicht der im Konstruktor angegeben Reihenfolge.}

\proc{Point}{Triangle::getCCCenter}{}
\proc{double}{Triangle::getCCRadius}{}
\descr{Ermittelt den Mittelpunkt und den Radius des Umkreises (circumcircle).
Diese Werte sind nur gültig, wenn das Dreieck nicht entartet ist 
(\bsee{Triangle::isValid}). }

\proc{bool}{Triangle::isInsideCC}{Point point}
\descr{Ermittelt, ob der Punkt point innerhalb des Umkreise liegt.}

\proc{void}{Triangle2Region}{const Triangle \&t, Region \&r}
\descr{Die Funktion erzeugt zu dem Dreieck t eine \class{Region}, die 
die Fläche des Dreiecks beschreibt.}

\seebaseclass{GeoObject}

\subsection{PolygonalCurve}
\label{PolygonalCurve}
\hypertarget{PolygonalCurve}{}

Polygonale Kurven werden durch eine Reihe Punkte definiert, die durch 
geradlinige Kanten verbunden sind. Polygonale Kurven können geschlossen sein, 
das heißt, der Anfangspunkt stellt auch den Endpunkt dar. Polygonale 
Kurven sind geschlossen, wenn dies bei der Konstruktion der Instanz so
festgelegt wurde, die Lage der Punkte spielt keine Rolle. Eine spätere Änderung 
dieser Eigenschaft ist nicht möglich.
 
Der erste Eckpunkt ist mittels des Konstruktors bzw. der Methode 
\bsee{PolygonalCurve::Reset} festzulegen. Erfolgt dies nicht, wird dieser 
Punkt auf $(0,0)$ gesetzt. Die weiteren Eckpunkte 
werden mit der Methode \bsee{PolygonalCurve::Add} angehängt. Alternativ 
kann die ganze Kurve durch Angabe einer Liste von Punkten bzw. einer Kontur 
konstruiert werden.

\subtitle{Konstruktoren}
\proch{}{PolygonalCurve::PolygonalCurve}{bool closed=false}{polygonalcurve.h}
\descr{Legt eine polygonale Kurve mit einem Eckpunkt an, der Eckpunkt 
liegt im Ursprung. Im allgemeinen wird danach die eigentliche Konstruktion 
der polygonalen Kurve mit \bsee{PolygonalCurve::Reset} und 
\bsee{PolygonalCurve::Add} erfolgen.}

\proch{}{PolygonalCurve::PolygonalCurve}{const PolygonalCurve \&p}{polygonalcurve.h}
\descr{Kopierkonstruktor.}

\proch{}{PolygonalCurve::PolygonalCurve}{\bsee{Point} p,bool closed=false}{polygonalcurve.h}
\descr{Legt eine polygonale Kurve mit einer Ecke an, der Eckpunkt ist $p$. 
Im allgemeinen wird die weitere Konstruktion der polygonalen Kurve mit 
\bsee{PolygonalCurve::Add} erfolgen.}

\proch{explicit}{PolygonalCurve::PolygonalCurve}{const \bsee{Matrix} \&m,
                 bool closed=false}{polygonalcurve.h}
\procf{}{PolygonalCurve::PolygonalCurve}{const vector<Point> \&pl,bool closed=false}
\descr{Konstruiert eine polygonale Kurve aus einer Liste von Punkten.}

\proch{explicit}{PolygonalCurve::PolygonalCurve}{const \bsee{Contur} \&c,
                 bool closed=false}{polygonalcurve.h}
\descr{Konstruiert eine polygonale Kurve aus einer Kontur.
Als Eckpunkte der Kurve werden 
die Punkte der Kontur ( = Randpunkte des Objektes) verwendet. Die polygonale Kurve verläuft 
damit in dem Objekt, ist also nicht die Randlinie.
}

\subtitle{Zugriffs-Methoden}

\proch{int}{PolygonalCurve::size}{}{polygonalcurve.h}
\descr{Gibt die Zahl der Ecken der polygonalen Kurve zurück.}

\proch{bool}{PolygonalCurve::isClosed()}{}{polygonalcurve.h}
\descr{Gibt zurück, ob die polygonale Kurve gschlossen ist.}

\proch{const Point \&}{PolygonalCurve::operator[]}{int i}{polygonalcurve.h}
\descr{Gibt die $i$. Ecke der polygonalen Kurve zurück.}

\proch{\bsee{LineSeg}}{PolygonalCurve::edge}{int i}{polygonalcurve.h}
\procf{void}{edge}{int i,LineSeg \&l}
\descr{Gibt die $i$. Kante der polygonalen Kurve als \bsee{LineSeg} zurück.}

\proch{void}{PolygonalCurve::Reset}{}{polygonalcurve.h}
\procf{void}{PolygonalCurve::Reset}{Point p}
\descr{Setzt die polygonale Kurve zurück. Die polygonale Kurve besteht danach 
aus nur einem Eckpunkt. Dieser wird auf $(0,0)$ bzw. den übergebenen Punkt 
$p$ gesetzt.
}

\proch{Contur}{MakeContur}{}{polygonalcurve.h}
\descr{Erzeugt eine Contur, die die Kurve beschreibt. Aufgrund der 
Ganzzahligkeit der Konturpunktkoordinaten ist dies eine Näherung.
}

\proch{int}{getClosestCorner}{Point p}{polygonalcurve.h}
\descr{Bestimmt den zum gegebenen Punkt p am nächsten liegenden Eckpunkt 
der Kurve.}

\proch{int}{getClosestEdge}{Point p}{polygonalcurve.h}
\descr{Bestimmt die zum gegebenen Eckpunkt p am nächsten liegende Kante 
der Kurve.}

\proch{PolygonalCurve}{Reduced}{int nr, int mode=1}{polygonalcurve.h}
\procf{void}{Reduced}{int nr, PolygonalCurve \&p, int mode=1}
\descr{Erzeugt eine Kurve mit geringerer Eckenzahl $nr$, die die gegebene
Kurve approximiert.\\
\begin{tabular}{cl}
mode == 1 & merge \\
mode == 2 & split \\
\end{tabular}
}

\proch{PolygonalCurve}{PolygonalCurve::ReducedToPrecision}{double prec,int mode=1}
{polygonalcurve.h}
\procf{void}{PolygonalCurve::ReducedToPrecision}{double prec,PolygonalCurve \&res,int mode=1}
\descr{Erzeugt eine Kurve mit geringerer Eckenzahl, die die gegebene
Kurve so gut approximiert, dass kein Punkt weiter als $prec$ von der 
Approximation entfernt ist.\\
\begin{tabular}{cl}
mode == 1 & merge \\
mode == 2 & split \\
\end{tabular}
}

\seealso{Draw}

\subsection{Polygon}
\label{Polygon}
\hypertarget{Polygon}{}

Polygone werden durch ihre Eckpunkte definiert. Der erste Eckpunkt ist mittels 
des Konstruktors bzw. der Methode \bsee{Polygon::Reset} festzulegen. Erfolgt 
dies nicht, wird dieser Punkt auf $(0,0)$ gesetzt. Die weiteren Eckpunkte 
werden mit der Methode \bsee{Polygon::Add} angehängt. Alternativ kann das 
ganze Polygon durch Angabe einer Liste von Punkten bzw. einer Kontur 
konstruiert werden. Neben der Klasse Polygon werden in einigen Funktionen 
auch Punktlisten/Matrizen als Polygon interpretiert.

\subtitle{Konstruktoren}
\proch{}{Polygon::Polygon}{}{polygon.h}
\descr{Legt ein Polygon mit einem Eckpunkt an, der Eckpunkt liegt im Ursprung. 
Im allgemeinen wird danach die eigentliche Konstruktion des Polygon mit 
\bsee{Polygon::Reset} und \bsee{Polygon::Add} erfolgen.}

\proch{}{Polygon::Polygon}{const Polygon \&p}{polygon.h}
\descr{Kopierkonstruktor.}

\proch{}{Polygon::Polygon}{\bsee{Point} p}{polygon.h}
\descr{Legt ein Polygon mit einer Ecke an, der Eckpunkt ist $p$. 
Im allgemeinen wird die weitere Konstruktion des Polygon mit 
\bsee{Polygon::Add} erfolgen.}

\proch{explicit}{Polygon::Polygon}{const \bsee{Matrix} \&m}{polygon.h}
\procf{}{Polygon::Polygon}{const vector<Point> \&pl}
\descr{Konstruiert das Polygon aus einer Liste von Punkten.}

\proch{explicit}{Polygon::Polygon}{const \bsee{Contur} \&c}{polygon.h}
\descr{Konstruiert ein Polygon aus einer Kontur.
Als Eckpunkte des Polygons werden die Punkte der Kontur ( = Randpunkte des Objektes) verwendet. 
Das Polygon liegt damit in dem Objekt, ist also nicht die Randlinie.
}

\subtitle{Zugriffs-Methoden}

\proch{int}{Polygon::size}{}{polygon.h}
\descr{Gibt die Zahl der Ecken des Polygon zurück.}

\proch{const Point \&}{Polygon::operator[]}{int i}{polygon.h}
\descr{Gibt die $i$. Ecke der Polygons zurück.}

\proch{\bsee{LineSeg}}{Polygon::edge}{int i}{polygon.h}
\procf{void}{edge}{int i,LineSeg \&l}
\descr{Gibt die $i$. Kante des Polygons als \bsee{LineSeg} zurück.}

\proch{void}{Polygon::Reset}{}{polygon.h}
\procf{void}{Polygon::Reset}{Point p}
\descr{Setzt das Polygon zurück. Das Polygon besteht danach aus nur 
einem Eckpunkt. Dieser wird auf $(0,0)$ bzw. den übergebenen Punkt $p$ gesetzt.
}

\seealso{Draw}

\subsection{Zeichenfunktionen}
\proch{int}{Draw}{const \bsee{Circle} \&c,Image \&img,int val,int fval=-1}{draw.h}
\procf{int}{Draw}{const \bsee{CircleSeg} \&c,Image \&img,int val,int fval=-1}
\procf{int}{Draw}{const \bsee{Ellipse} \&c,Image \&img,int val,int fval=-1}
\procf{int}{Draw}{const \bsee{EllipseSeg} \&c,Image \&img,int val,int fval=-1}
\procf{int}{Draw}{const \bsee{LineSeg} \&c,Image \&img,int val}
\procf{int}{Draw}{const \bsee{Polygon} \&c,Image \&img,int val,int fval=-1}
\descr{Stellt das jeweilige geometrische Objekt im Bild $img$ dar. 
Dabei wird die Objektbegrenzung mit dem Wert $val$, das Objektinnere 
mit dem Wert $fval$ eingetragen. Wird $fval$ mit dem speziellen Wert -1 
vorgegeben, so wird das Objekt nicht gefüllt. }

\subsection{Implementierungshinweise für geometrische Objekte}
Klassen für weitere \hyperlink{SECTION:geoObject}{geometrische Objekte} können 
durch Ableitung von einer geeigneten Klasse der Klassenhierarchie 
\class{GeoObject} erfolgen. Es ist darauf zu achten, dass
alle abstrakten Methoden der Basisklasse implementiert werden. 
Insbesondere ist folgendes zu beachten:
\begin{itemize}
\item Die Methoden Distance(..) und Inside(..) mit unterschiedlicher Form 
der Parameterangaben werden intern in einen Aufruf von 
{\bf \verb+double distance(Point p) const;+} bzw.
{\bf \verb+bool inside(Point p) const;+} umgewandelt. Abgeleitete 
Klassen müssen diese (kleingeschriebenen) Methoden (re-)implementieren.
\item {\bf distance} bezieht sich immer auf den Abstand zur Begrenzungslinie 
des Objektes, nicht die Fläche.
\item {\bf inside} bezieht sich immer auf die Objekte-Fläche. Punkte der 
Begrenzungslinie sind nicht innerhalb. Geometrische Objekte ohne Fläche 
geben immer {\bf false} zurück, was bereits in der Basisklasse 
\class{GeoObject} so implementiert ist und somit nicht neu implementiert 
werden muss.
\end{itemize}

\nsection{Klassen-Hierarchie Geometrisches 3D-Objekt}{geoObject3d}
\label{Geometrisches3DObjekt}
\hypertarget{geometric3dObject}{}

Alle Klassen, die der Beschreibung von geometrischen Objekten des Raumes 
dienen, leiten sich von der abstrakten Basis-Klasse \class{GeoObject3d} ab.
\vspace{1cm}
\noindent
Klassen-Hierarchie:

\begin{description}
\item[\class{GeoObject3d}] Abstrakte Basisklasse
\begin{description}
\item[\class{Line3d}] Gerade, Strecke, Strahl
\item[\class{Sphere}] Kugel
\end{description}
\end{description}

\subsection{GeoObject3d}
\label{GeoObject3d}
\hypertarget{GeoObject3d}{}

\class{GeoObject3d} ist eine abstrakte Basisklasse für 
\hyperlink{geometric3dObject}{geometrische Objekte} des Raumes.
In dieser Klasse definierte Methoden sind in allen abgeleiteten Klassen
ebenfalls vorhanden.

Konstruktoren:

\proch{}{GeoObject3d::GeoObject3d}{void}{geo3d.h}
\descr{Legt ein 3D-Objekt im Ursprung an.}

\proc{}{GeoObject3d::GeoObject3d}{const GeoObject3d \&p}
\procf{}{GeoObject3d::GeoObject3d}{const Vector3d \&p}
\procf{}{GeoObject3d::GeoObject3d}{double xp,double yp,double zp}
\descr{Legt ein 3D-Objekt im angegebenen Punkt an.}

\proc{explicit}{GeoObject3d::GeoObject3d}{const Vector \&v}
\proc{explicit}{GeoObject3d::GeoObject3d}{double p[]}
\descr{Legt ein 3D-Objekt im angegebenen Punkt an.
 Zur Vermeidung ungewollter  Konvertierungen muß der Aufruf explizit erfolgen.}

\proc{double}{GeoObject3d::X}{void}
\procf{double}{GeoObject3d::Y}{void}
\procf{double}{GeoObject3d::Z}{void}
\descr{Lesender Zugriff auf die Koordinaten des 3D-Objekts}

\proc{void}{GeoObject3d::setX}{double x}
\procf{void}{GeoObject3d::setY}{double y}
\procf{void}{GeoObject3d::setZ}{double z}
\procf{void}{GeoObject3d::set}{const Vector \&v}
\descr{Setzen der Koordinatenwerte der Objektposition.}

\proc{Vector3d \&}{GeoObject3d::Pos}{}
\descr{Zugriff auf die Position des 3D-Objektes.}

\proc{void}{GeoObject3d::Shift}{double dx,double dy,double dz}
\proc{void}{GeoObject3d::Shift}{const Vector3d \&v}
\descr{Verschiebung des 3D-Objektes um die gegebene Verschiebung.}

\proc{double}{GeoObject3d::Distance}{double dx,double dy,double dz}
\procf{double}{GeoObject3d::Distance}{const Vector3d \&ob}
\descr{Euklidischer Abstand des gegebenen Raumpunktes vom 3D-Objekt}

\proc{double}{GeoObject3d::Volume}{}
\descr{Gibt das Volumen des 3D-Objektes zurück. Diese Methode ist in der
  Basis-Klasse abstrakt.}

\subsection{Sphere}
\label{Sphere}
\hypertarget{Sphere}{}

\class{Sphere} ist eine von \class{GeoObject3d} abgeleitetet Klasse 
zur Repräsentation von Kugeln.

Konstruktoren:
\proch{}{Sphere::Sphere}{}{sphere.h}
\descr{Legt eine Einheits-Kugel im Ursprung an.}

\proc{}{Sphere::Sphere}{double xp,double yp,double zp,double rp}
\procf{}{Sphere::Sphere}{const Vector3d \&p,double rp}
\procf{}{Sphere::Sphere}{const Point3d \&p,double rp}
\descr{Legt eine Kugel mit den gegebenen Parametern für Mittelpunkt und Radius
  an.}

\proc{}{Sphere::Sphere}{const Sphere \&p}
\descr{Legt eine Kopie der Kugel $p$ an (Kopierkonstruktor).}

\proc{explicit}{Sphere::Sphere}{const Vector \&v}
\procf{explicit}{Sphere::Sphere}{double d[]}
\descr{Legt eine Kugel mit den gegebenen Parametern für Mittelpunkt und Radius
  an. Der Aufruf muß explizit erfolgen.}

Methoden:

\proc{double}{Sphere::R}{}
\descr{Gibt den Radius der Kugel zurück.}

\proc{void}{Sphere::setR}{double vr}
\descr{Setzt den Radius der Kugel auf $vr$.}

\proc{double}{Sphere::Volume}{}
\descr{Berechnet das Volumen der Kugel.}

Siehe auch weitere Methoden der Basis-Klasse \see{GeoObject3d}.
\newcommand{\pfeil}[1]{\stackrel{\rightarrow}{{#1}}}

\subsection{Line3d}
\label{Line3d}
\hypertarget{Line3d}{}

\class{Line3d} ist eine von \class{GeoObject3d} abgeleitetet Klasse 
zur Repräsentation von Geraden, Strahlen und Strecken des Raumes. 
Die Gerade wird dabei in ihrer
Parameter-Form $\pfeil{x}=\pfeil{x_1}+p \cdot (\pfeil{x_2}-\pfeil{x_1})=\pfeil{x_1}+p \cdot \pfeil{dx}$ dargestellt. Der Parameter
$p$ ist bei Geraden unbeschränkt, ist bei Strahlen größer als Null und liegt
bei Strecken im Intervall $[0..1]$.

Konstruktoren:

\proch{}{Line3d::Line3d}{}{line3d.h}
\descr{Legt eine undefiniert Strecke an. Vor der Verwendung müssen die
  Endpunkte sinnvoll gesetzt werden.}

\proc{}{Line3d::Line3d}{double xp,double yp,double zp,double x2p,double y2p,double z2p}
\procf{}{Line3d::Line3d}{const Point3d \&p1,const Point3d \&p2}
\descr{Legt eine Strecke mit den gegebenen Endpunkten an.}

\proc{}{Line3d::Line3d}{const Line3d \&p}
\descr{Legt eine Kopie der gegebenen Gerade an (Kopierkonstruktor).}

\proc{explicit}{Line3d::Line3d}{const Vector \&v}
\procf{explicit}{Line3d::Line3d}{double d[]}
\descr{Legt eine Strecke mit den in Parametern angegebenen Endpunkten an. Der
  Aufruf muß explizit erfolgen.}

Elementzugriff:

\proc{double}{Line3d::X1}{}
\proc{double}{Line3d::Y1}{}
\proc{double}{Line3d::Z1}{}
\proc{Vector3d \&}{Line3d::P1}{}
\descr{Zugriff auf die Koordinatenwerte des Startpunktes. Diese Methoden sind
  identisch zu den gleichfalls nutzbaren Methoden X(),Y() und Z() der
  Basisklasse $GeoObject3d$.}

\proc{double}{Line3d::X2}{}
\proc{double}{Line3d::Y2}{}
\proc{double}{Line3d::Z2}{}
\proc{Vector3d}{Line3d::P2}{}
\descr{Zugriff auf die Koordinatenwerte des Endpunktes. Diese Werte
  werden berechnet, da intern nur ein Richtungsvektor gespeichert wird.}

\proc{double}{Line3d::DX}{}
\proc{double}{Line3d::DY}{}
\proc{double}{Line3d::DZ}{}
\proc{Vector3d \&}{Line3d::DP}{}
\descr{Zugriff auf die Werte des Richtungsvektors vom Start- zum Endpunkt.}

Methoden:

\proc{Vector3d}{Line3d::operator()}{double p}
\descr{Liefert die Koordinaten des Punktes $x$ der Geraden mit
  $\pfeil{x}=\pfeil{x_1}+p \cdot (\pfeil{x_2}-\pfeil{x_1})=\pfeil{x_1}+p \cdot
  \pfeil{dx}$}

\proc{double}{Line3d::Volume}{}
\descr{Gibt 0 zurück.}
 
\newpage
\makeatletter{}\nsection{Geometrische Transformationen}{geoTrafo}

\subsection{Die Klasse Trafo}
\label{Trafo}
\hypertarget{Trafo}{}

Projektive und affine Transformationen werden durch Objekte der
Klasse $Trafo$ beschrieben. Dabei wird intern mit homogenen
Koordinaten gerechnet und die Transformation durch die 
entsprechende Transformations-Matrix beschrieben.
Es existieren Methoden, die das Zusammensetzen einer Transformation 
aus speziellen affinen Transformationen erlauben. Dabei wird die 
hinzuzufügende Transformations-Matrix jeweils von links mit der
bereits vorhandenen Transformation multipliziert, was der nachfolgenden 
Ausführung der hinzuzufügenden Transformation entspricht.
\subsubsection{Konstruktoren und Destruktoren}
\proch{}{Trafo::Trafo}{void}{geo.h}
\descr{Initialisieren einer 2D-2D-Transformation mit der identischen
Transformation (Einheitsmatrix).}
\proch{}{Trafo::Trafo}{const Trafo \&}{geo.h}
\descr{Initialisieren einer Transformation mit einer gegebenen
Transformation (Copy-Konstruktor).}
\proch{}{Trafo::Trafo}{const Matrix \&}{geo.h}
\descr{Initialisieren einer Transformation anhand einer gegebenen
Transformations-Matrix (Klasse \see{Matrix}).}
\proch{}{Trafo::Trafo}{int dims,int dimd}{geo.h}
\descr{Initialisieren einer Transformation aus dem Raum der Dimension
$dims$ in den Raum der Dimension $dimd$.}
\subsubsection{Operatoren und elementare Funktionen}
\proch{Trafo \&}{Trafo::operator =}{const Trafo \&}{geo.h}
\descr{Zuweisungs-Operator}
\proch{Trafo \&}{Trafo::operator =}{const Matrix \&}{geo.h}
\descr{Umwandlung einer (Transformations-)Matrix in eine 
Transformation und Zuweisung an eine bestehende Transformation.}

\proch{double \&}{Trafo::operator ()}{int x,int y}{geo.h}
\descr{Zugriff auf das Element [i,j] der Transformationsmatrix
\see{Trafo::Tmatrix}.
}

\proch{Trafo}{operator *}{const Trafo \&,const Trafo \&}{geo.h}
\descr{Multiplikation zweier Transformationen = Hintereinander-Ausführung.
Das Ergebnis ist wieder eine Transformation (Klasse Trafo) }
\proch{Vector}{operator *}{const Trafo \&,const Vector \&}{geo.h}
\descr{Multiplikation einer Transformation mit einem $Vector$ = 
Anwendung der Transformation auf den Vektor. Das Ergebnis ist der
transformierte Vektor}
\proch{int}{Trafo::DimS}{void}{geo.h}
\descr{Liefert die Dimension des Ausgangs-Raumes der Transformation.}
\proch{int}{Trafo::DimD}{void}{geo.h}
\descr{Liefert die Dimension des Ziel-Raumes der Transformation.}
\proch{Matrix}{Trafo::Tmatrix}{void}{geo.h}
\descr{Liefert die Transformations-Matrix als Objekt der Klasse
\see{Matrix}.}
\proch{Matrix}{Trafo::Init}{void}{geo.h}
\descr{Setzt die Transformation zurück in den Zustand wie nach dem Anlegen
durch den Konstruktor.}
\proch{int}{Trafo::Invert}{}{geo.h}
\descr{Invertiert die Transformation.}
\proch{Trafo}{Trafo::Inverse}{}{geo.h}
\descr{Gibt die invertierte Transformation zurück.}
\subsubsection{Konstruktion allgemeiner Transformationen aus
elementaren Transformationen}
Die folgendenden Methoden fügen einer bestehenden Transformation eine weitere
Transformation hinzu (im Sinne der Hintereinanderausführung). Um eine bereits verwendete Transformation neu zu belegen, muß diese mit \see{Trafo::Init} zuückgesetzt werden.
\proch{int}{Trafo::Shift}{double x0,double y0}{geo.h}
\descr{Hinzufügen einer Translation um $(x0,y0)$
an eine xD-2D-Transformation.}
\proch{int}{Trafo::Shift}{double x0,double y0,double y0}{geo.h}
\descr{Hinzufügen einer Translation um $(x0,y0,y0)$
an eine xD-3D-Transformation.}
\proch{int}{Trafo::Shift}{vector3d v}{geo.h}
\descr{Hinzufügen einer Translation um $v$
an eine xD-3D-Transformation.}
\proch{int}{Trafo::Shift}{Vector v}{geo.h}
\descr{Hinzufügen einer Translation um $v$
an eine Transformation. Die Dimension des Ziel-Raumes der Transformation
muß gleich der Dimension des Verschiebungsvektors sein.}

\proch{int}{Trafo::Rotate}{double x0,double y0,double phi}{geo.h}
\descr{Hinzufügen einer Rotation um den Punkt $(x0,y0)$ um
den Winkel $phi$ (Bogenmaß) an eine xD-2D-Transformation.}
\proch{int}{Trafo::Rotate}{vector3d point,vector3d dir,double phi}{geo.h}
\descr{Hinzufügen einer Rotation um den Strahl vom Punkt $point$ 
mit der Richtung $dir$ um den Winkel $phi$ (Bogenmaß)an eine 
xD-3D-Transformation.}

\proch{int}{Trafo::RotateX}{double phi}{geo.h}
\proch{int}{Trafo::RotateY}{double phi}{geo.h}
\proch{int}{Trafo::RotateZ}{double phi}{geo.h}
\descr{Hinzufügen einer Rotation um die jeweilige Achse des
Koordinatensystems um den Winkel $phi$ (Bogenmaß)an eine 
xD-3D-Transformation.}

\proch{int}{Trafo::Flip}{int axis}{geo.h}
\descr{Hinzufügen einer Spiegelung, die die angebene Achse invertiert.}

\proch{int}{Trafo::ShearX}{double dxy}{geo.h}
\descr{Hinzufügen einer Scherung in Richtung der X-Achse an eine 
xD-2D-Transformation. Der Parameter ist der Quotient aus der Verschiebung
in X-Richtung und dem Y-Koordinatenwert.}
\proch{int}{Trafo::ShearY}{double dyx}{geo.h}
\descr{Hinzufügen einer Scherung in Richtung der Y-Achse an eine 
xD-2D-Transformation. Der Parameter ist der Quotient aus der Verschiebung
in Y-Richtung und dem X-Koordinatenwert.}
\proch{int}{Trafo::Scale}{double x0, double y0, double f}{geo.h}
\descr{Hinzufügen einer isotropen Skalierung um den 
Punkt $(x0,y0)$ um den Faktor $f$ an eine xD-2D-Transformation.}
\proch{int}{Trafo::Scale}{double x0, double y0, double fx,double fy}{geo.h}
\descr{Hinzufügen einer anisotropen Skalierung um den 
Punkt $(x0,y0)$ um die Faktor $fx$ bzw. $fy$ in X- bzw. Y-Richtung
an eine xD-2D-Transformation.}
\proch{int}{Trafo::Scale}{vector3d v, double f}{geo.h}
\descr{Hinzufügen einer isotropen Skalierung um den 
Punkt $v$ um den Faktor $f$ an eine xD-3D-Transformation.}
\proch{int}{Trafo::Scale}{vector3d v, double fx,double fy,double fz}{geo.h}
\descr{Hinzufügen einer anisotropen Skalierung um den 
Punkt $v$ um die Faktor $fx$, $fy$ bzw. $fz$ in X-, Y- bzw. Z-Richtung
an eine xD-3D-Transformation.}
\proch{int}{Trafo::Scale}{Vector v, double f}{geo.h}
\descr{Hinzufügen einer isotropen Skalierung um den 
Punkt $v$ um den Faktor $f$ an eine Transformation.}
\proch{int}{Trafo::Scale}{Vector v, Vector f}{geo.h}
\descr{Hinzufügen einer anisotropen Skalierung um den
Punkt $v$ an eine Transformation, wobei die Faktoren für die
verschiedenen Koordinatenrichtungen im Vektor $f$ abgelegt sind.}

\proch{int}{Trafo::Projective}{void}{geo.h}
\descr{Hinzufügen einer projektiven Abbildung, die die Dimension 
des Raumes um 1 vermindert. Die Abbildung erfolgt durch eine 
projektive Abbildung mit dem Ursprung als Zentrum in den Unter-Raum, bei 
dem die letzte Koordinate den Wert 1 hat.}

\subsubsection{Anwendung von Transformationen}

\proc{int}{Transform}{const Trafo \&,double \&x,double \&y}
\descr{Wendet die 2D-2D-Transformation auf $(x,y)$ an und
ändert die Variablen-Werte entsprechend.}

\proc{int}{Transform}{const Trafo \&,Point \&p}
\descr{Wendet die 2D-2D-Transformation auf $p$ an.}

\proc{int}{Transform}{const Trafo \&,double x,double y,double \&xt,double
\&yt}
\descr{Wendet die 2D-2D-Transformation auf $(x,y)$ an und
gibt das Ergebnis auf den Variablen $xt$ und $yt$ zurück.}

\proc{int}{Transform}{const Trafo \&,Point p1,Point \&p2}
\descr{Wendet die 2D-2D-Transformation auf $p$ an und gibt das Ergebnis auf $p2$ zurück.}

\proc{int}{TransformAndRound}{const Trafo \&,int \&x,int \&y}
\descr{Wendet die 2D-2D-Transformation auf $(x,y)$ an und
ändert die Variablen-Werte entsprechend. Die ganzzahligen Werte sind 
gegenüber den exakten Werten gerundet.}

\proc{int}{TransformAndRound}{const Trafo \&,int x,int y,int \&xt,int \&yt}
\descr{Wendet die 2D-2D-Transformation auf $(x,y)$ an und
gibt das Ergebnis auf den Variablen $xt$ und $yt$ zurück. Die ganzzahligen Werte sind 
gegenüber den exakten Werten gerundet.}

\proc{int}{Transform}{const Trafo \&,double \&x,double \&y,double \&z)}
\descr{Wendet die 3D-3D-Transformation auf $(x,y,z)$ an und
ändert die Variablen-Werte entsprechend.}

\proc{int}{Transform}{const Trafo \&,double x,double y,double z,double
\&xt,double \&yt,double \&zt}
\descr{Wendet die 3D-3D-Transformation auf $(x,y,z)$ an und
gibt das Ergebnis auf den Variablen $xt$, $yt$ und $zt$ zurück.}
\proc{int}{Transform}{const Trafo \&,double x,double y,double z,double
\&xt,double \&yt}

\descr{Wendet die 3D-2D-Transformation auf $(x,y,z)$ an und
gibt das Ergebnis auf den Variablen $xt$ und $yt$ zurück.}

\proc{int}{TransformList}{const Trafo \&tr,Matrix \&m}
\procf{int}{TransformList}{const Trafo \&tr,const Matrix \&m,Matrix \&m2}
\descr{Interpretiert die Matrix $m$ als Punktliste (jede Zeile
enthält die Koordinaten eines Punktes) und transformiert diese
mittels der Trafo $tr$. Das Ergebnis ist die transformierte Matrix $m$
beziehungsweise die Matrix $m2$.}

\proc{Contur}{Transform}{const Trafo \& tr,const Contur \& c}
\descr{Wendet die 2D-2D-Transformation auf die Kontur $c$ an 
und gibt die transformierte Kontur zurück}

\proc{int}{Transform}{const Trafo \&,const Image \&simg,Image \&dimg,int mode=DEFAULT}
\proc{int}{Transform}{const Trafo \&,const Image \&simg,Image \&dimg,int mode,
Image \&mark,int val=1}
\descr{Wendet die 2D-2D-Transformation auf das Bild $simg$ an 
und schreibt das Ergebnis in das Bild $dimg$. Da man bei der 
Transformation der Bildpunkte im allgemeinen keine ganzzahligen 
Koordinaten erhält, werden die Grauwerte für $mode$=INTERPOL 
bilinear interpoliert. Bei $mode$=DEFAULT werden die Koordinaten 
gerundet. Wenn der Originalpunkt zu einem Pixel des Zielbildes ausserhalb des
Quellbildes liegt, kann kein Grauwert berechnet werden und es wird der Wert
Null eingetragen. Wird als Parameter $mark$ ein Bild angegeben, so werden
diese Pixel in diesem Bild mit dem Wert $val$ belegt.
}
\seealso{TransImg} 

\subsection{Verzeichnungen}
\label{Distortion}
\hypertarget{Distortion}{}

Verzeichnungen von Kameras werden üblicherweise als radialsymmetrisch 
angenommen. Die Enstehung eines verzeichneten Bildes aus einem 
unverzerrten Bild wird als Änderung des Abstandes $r$ vom 
Symmetriezentrum (x0,y0) beschrieben. 

In ICE stehen die Klassen {\bf Distortion0}, {\bf Distortion1}, {\bf Distortion2} und 
{\bf Distortion3} zur Verfügung, die von der abstrakten Basisklasse  {\bf
Distortion} abgeleitet sind.

Diese Klassen realisieren die folgenden Verzeichnungs-Modelle:
\begin{itemize}
\item[Distortion0:] $r'=r \cdot (1 + d_2 \cdot r^2)$
\item[Distortion1:] $r'=r \cdot (1 + d_2 \cdot r^2 + d_4 \cdot r^4)$
\item[Distortion2:] $r'=r \cdot (1 + d_2 \cdot r^2 + d_3 \cdot r^3 + d_4 \cdot r^4)$
\item[Distortion3:] $r'=r \cdot (1 + d_2 \cdot r^2 + d_4 \cdot r^4 + d_6 \cdot r^6)$
\end{itemize}

\subsubsection{Konstruktoren}
Verzeichnungen können durch direkte Angabe von Verzeichnungsparametern oder
durch die Ermittlung aus Punktkorrespondenzen angelegt werden. 

\proch{}{Distortion0::Distortion0}{void}{distort.h}
\procf{}{Distortion1::Distortion1}{void}
\procf{}{Distortion2::Distortion2}{void}
\procf{}{Distortion3::Distortion3}{void}
\procf{}{Distortion0::Distortion0}{double x0,double y0,double d2=0.0}
\procf{}{Distortion1::Distortion1}{double x0,double y0,double d2=0.0,
double d4=0.0}
\procf{}{Distortion2::Distortion2}{double x0,double y0,double d2=0.0,
double d3=0.0,double d4=0.0}
\procf{}{Distortion3::Distortion3}{double x0,double y0,double d2=0.0,
double d4=0.0,double d6=0.0}
\descr{
Ein Verzeichnungs-Objekt wird angelegt und mit den gegebenen Werten
initialisiert.}

\proch{}{Distortion0::Distortion0}{const Matrix \&mark,const Matrix \&orig,Trafo \&tr,const Vector \&ImageCenter}{distort.h}
\procf{}{Distortion0::Distortion0}{const Matrix \&mark,const Matrix \&orig,const Vector \&ImageCenter}
\procf{}{Distortion0::Distortion0}{const Matrix \&mark,const Matrix \&orig}
\procf{}{Distortion1::Distortion1}{const Matrix \&mark,const Matrix \&orig,Trafo \&tr,const Vector \&ImageCenter}
\procf{}{Distortion1::Distortion1}{const Matrix \&mark,const Matrix \&orig,const Vector \&ImageCenter}
\procf{}{Distortion1::Distortion1}{const Matrix \&mark,const Matrix \&orig}
\procf{}{Distortion2::Distortion2}{const Matrix \&mark,const Matrix \&orig,Trafo \&tr,const Vector \&ImageCenter}
\procf{}{Distortion2::Distortion2}{const Matrix \&mark,const Matrix \&orig,const Vector \&ImageCenter}
\procf{}{Distortion2::Distortion2}{const Matrix \&mark,const Matrix \&orig}
\procf{}{Distortion3::Distortion3}{const Matrix \&mark,const Matrix \&orig,Trafo \&tr,const Vector \&ImageCenter}
\procf{}{Distortion3::Distortion3}{const Matrix \&mark,const Matrix \&orig,const Vector \&ImageCenter}
\procf{}{Distortion3::Distortion3}{const Matrix \&mark,const Matrix \&orig}
\descr{
$mark$ stellt eine Liste von im Bild vermessenen Markern bereit, $orig$
enthält eine 2D-Liste der originalen Position der Marker. Es wird die
Verzeichnung konstruiert. Das zugrunde liegende Modell ist eine projektive
2D-2D-Transformation gefolgt von der Verzeichnung. Dies entspricht der
Aufnahme einer ebenen Vorlage mit Markierungen mit einer Kamera. Wenn bereits
bekannt, kann für eine projektive 2D-2D-Transformation als Startwert $tr$
übergeben werden. Nach der Rückkehr ist diese Transformation auf die
ermittelte (optimierte) projektive Transformation gesetzt. $ImageCenter$
übergibt einen Startwert für die Lage des Symmetriezentrums.
}

\subsubsection{Zugriff auf die Daten der Verzeichnung}
\proch{double}{Distortion::X0}{void}{distort.h}
\descr{Es wird die X-Koordinate des Symmetriezentrums der Verzeichnung
zurückgegeben.}
\proch{double}{Distortion::Y0}{void}{distort.h}
\descr{Es wird die Y-Koordinate des Symmetriezentrums der Verzeichnung
zurückgegeben.}

\proch{double}{Distortion0::D2}{void}{distort.h}
\descr{Es wird der Wert von d2 zurückgegeben.}

\proch{double}{Distortion1::D2}{void}{distort.h}
\descr{Es wird der Wert von d2 zurückgegeben.}
\proch{double}{Distortion1::D4}{void}{distort.h}
\descr{Es wird der Wert von d4 zurückgegeben.}

\proch{double}{Distortion2::D2}{void}{distort.h}
\descr{Es wird der Wert von d2 zurückgegeben.}
\proch{double}{Distortion2::D3}{void}{distort.h}
\descr{Es wird der Wert von d3 zurückgegeben.}
\proch{double}{Distortion2::D4}{void}{distort.h}
\descr{Es wird der Wert von d4 zurückgegeben.}

\proch{double}{Distortion2::D2}{void}{distort.h}
\descr{Es wird der Wert von d2 zurückgegeben.}
\proch{double}{Distortion2::D4}{void}{distort.h}
\descr{Es wird der Wert von d4 zurückgegeben.}
\proch{double}{Distortion2::D6}{void}{distort.h}
\descr{Es wird der Wert von d6 zurückgegeben.}

\subsubsection{Anwendung und Invertierung von Verzeichnungen}

\proch{int}{Distortion::Distort}{double \&x,double \&y}{distort.h}
\procf{int}{Distortion::Distort}{double x,double y,double \&xd,double \&yd}
\procf{Vector}{Distortion::Distort}{const Vector \&p}
\procf{Point}{Distortion::Distort}{const Point \&p}
\descr{Anwendung der Verzeichnung auf einen Punkt. Der Punkt kann mit seinen
Koordinaten $x$ und $y$, als Punkt vom Typ \see{Point} oder als Vektor 
vom Typ \see{Vector} gegeben sein.
Die verzeichneten Kordinaten überschreiben $x$ und $y$ oder werden als 
$xd$ und $yd$, als Punkt oder als Vektor zurückgegeben.}

\proch{int}{Distortion::Rect}{double \&x,double \&y}{distort.h}
\procf{int}{Distortion::Rect}{double x,double y,double \&xr,double \&yr}
\procf{Vector}{Distortion::Rect}{const Vector \&p}
\procf{Point}{Distortion::Rect}{const Point \&p}
\descr{Invertierung der Verzeichnung eines Punktes. Der Punkt kann mit seinen
Koordinaten $x$ und $y$, als Punkt vom Typ \see{Point} oder als Vektor vom 
Typ \see{Vector} gegeben sein. Die unverzeichneten Kordinaten überschreiben 
$x$ und $y$ oder werden als $xd$ und $yd$, als Punkt oder als Vektor 
zurückgegeben.}

\proch{Image}{Distortion::RectImg}{Image source,int mode=DEFAULT}{distort.h}
\procf{Image}{Distortion::RectImg}{Image source,Image dest,int mode=DEFAULT}
\descr{Entzerrt das verzeichnete Bild $source$ und überschreibt $source$
beziehungsweise schreibt es als neues Bild $dest$. Punkte im Zielbild, zu
denen kein Punkt im Quellbild existiert, werden mit Null belegt. Die
Bestimmung der Grauwerte erfolgt je nach Modus:
\begin{itemize}
\item $mode=DEFAULT$ Es wird der Wert des nächstgelegenen Pixels verwendet.
\item $mode=INTERPOL$ Es werden die Werte der Nachbarn bilinear interpoliert.
\end{itemize}
Rückgabewert ist das Zielbild.}

 
\newpage
\makeatletter{}\nsection{Kameramodelle}{cameraModel}
\subsection{Datenstruktur Camera}
\label{Camera}
\hypertarget{Camera}{}
Die Datenstruktur \class{Camera} beschreibt die Eigenschaften einer Kamera. Dies
umfaßt die inneren und äußeren Parameter der Kamera bezüglich der projektiven
Abbildung sowie die Parameter der Verzeichnung (\see{Distortion}).

Die äußeren Kameraparameter beschreiben eine Transformation der
Weltkoordinaten eines Punktes in die Kamerakoordinaten durch eine Bewegung. 
Der Ursprung des Kamerakoordinatensystems sitzt im Projektionszentrum der 
projektiven Abbildung der Kamera, die Z-Achse liegt auf der optischen Achse
der Kamera von der Kamera weg, die X-Achse ist parallel zu horizontalen 
Achse der Bildebene, die Y-Achse ist parallel zur vertikalen Bildachse, aber
umgekehrt orientiert. Dies trägt der Tatsache Rechnung, daß in der
Bildverarbeitung üblicherweise die vertikale Achse nach unten gerichtet ist,
also entgegengesetzt zur üblichen Orientierung im Raum.
Die Bewegung (Transformation Weltkoordinaten in Kamerakoordinaten) wird
beschrieben durch die Eulerschen Winkel einer Drehung um die Z-Achse des
Weltkoordinatensystems ($\gamma$), Drehung um die Y-Achse des
Weltkoordinatensystems ($\beta$) und einer Drehung um die X-Achse des
Weltkoordinatensystems ($\alpha$), ausgeführt in dieser Reihenfolge und eine
Verschiebung. 

Die projektive 3D-2D-Transformation von Kamerakoordinaten in Bildkoordinaten
$(u,v)$ wird durch die inneren Kameraparameter charakterisiert. 
Dies sind die Kammerkonstante $f$, die Anisotropie $a$, die die abweichende
Skalierung bezüglich der Bildachsen beschreibt, die Scherung $s$ in u-Richtung
sowie der Hauptpunkt $(u_0,v_0)$. Die resultierende Transformationsmatrix ist
\centerline{
$\left( 
\begin{array}{cccc}
f & s \cdot f & u_0 & 0\\
0 & -a \cdot f & v_0 & 0\\
0 & 0 & 1 & 0
\end{array} 
 \right)$}

Für die Verzeichnung können alle vorhandenen Verzeichnungsmodelle
(\see{Distortion}) genutzt werden.

\subsubsection{Konstruktoren, Zuweisung, Destruktor}

\proch{}{Camera::Camera}{int dtyp=1}{camera.h}
\descr{Legt eine Kamera mit dem gegebenen Verzeichnungstyp $dtyp$ an (\see{Distortion}). }

\proch{}{Camera::Camera}{const Vector \&v,int dtyp=1}{camera.h}
\descr{Legt eine Kamera mit dem gegebenen Verzeichnungstyp $dtyp$ an
  (\see{Distortion}) und initialisiert diese mit den im Vektor $v$ gegebenen
  Parametern 
(\see{Camera::Set},\see{Camera::MakeVector})}

\proch{}{Camera::Camera}{const Camera \&c}{camera.h}
\descr{Kopierkonstruktor.}

\proch{Camera \&}{operator=}{const Camera \&c}{camera.h}
\descr{Zuweisungsoperator: Setzen einer Kamera (linke Seite)
auf die Werte der Kamera der rechten Seite.}

\subsubsection{Zugriff auf Komponenten und Parameter}

\proc{void}{Camera::Set}{double fp,double ap,double sp,
                   double u0p,double v0p,const Distortion \&d}
\procf{void}{Camera::Set}{double fp,double ap,double sp,double u0p,double v0p}
\descr{Setzt die internen Parameter einer Kamera entsprechend der gegebenen
Werte, mit bzw. ohne die Verzeichnungsparameter.}
\proc{void}{Camera::SetExt}{double dxp,double dyp,double dzp,double ap,double
bp,double cp}
\descr{Setzt die äußeren Kamera-Parameter.}

\proc{void}{Camera::Get}{double \&fp,double \&ap,double \&sp,double \&u0p,double \&v0p}
\descr{Ermittelt die internen Parameter der Kamera.}
\proc{void}{Camera::GetExt}{double \&dxp,double \&dyp,double \&dzp,
double \&ap,double \&bp,double \&cp}
\descr{Gibt die äußeren Kamera-Parameter zurück.}

\proc{const Distortion}{Camera::Dist}{}
\descr{Gibt eine konstante Referenz der Verzeichnung der Kamera zurück.}
\proc{int}{Camera::DistType}{}
\descr{Gibt den Type der Verzeichnung als Integer-Wert zurück.}

\proc{void}{Camera::SetDist}{const Distortion \&d}
\descr{Setzt die Verzeichnungsparameter der Kamera.}

Die speziellen Zugriffsmethoden, die die Parameter der Kamera in einem
\bsee{Vector} ablegen bzw. aus einem \bsee{Vector} laden dienen der
Nutzung mit Funktionen, die Vektoren als Parameter benötigen, wie zum Beispiel
die Funktion \bsee{LMDif}.

\proch{Vector}{Camera::MakeVector}{int what=Camera::all}{camera.h}
\descr{Erzeugt einen Vektor, in dem die Parameter der Kamera gespeichert
sind. Mittels Parameter $what$ kann festgelegt werden, welche Parameter im
Vektor abgelegt werden:
\begin{itemize}
\item[Camera::all] Es werden alle Parameter abgelegt.
\item[Camera::internal] Es werden die internen Parameter abgelegt
(einschließlich Verzeichnung). 
\item[Camera::external] Es werden die äußeren Parameter abgelegt.
\end{itemize}
}

\proch{void}{Camera::Set}{const Vector \&v,int what=Camera::all}{camera.h}
\descr{Setzt die Parameter etsprechend der Daten im Vektor $v$. Zur Bedeutung
des Parameters $what$ siehe \see{Camera::MakeVector}.}

\subsubsection{Transformationen}

\proch{Vector}{Camera::Transform}{const Vector \&v}{camera.h}
\descr{Abbildung eines als Vektor gegebenenen Raumpunktes in die
Bildebene und Rückgabe als Vektor.}

\proch{Point}{Camera::Transform}{const Vector3d \&v}{camera.h}
\descr{Abbildung eines als Vektor3d gegebenenen Raumpunktes in die
Bildebene und Rückgabe als Point.}

\proch{Point}{Camera::Transform}{const Point3d \&v}{camera.h}
\descr{Abbildung eines als Point3d gegebenenen Raumpunktes in die
Bildebene und Rückgabe als Point.}

\proc{void}{Camera::Transform}{double x,double y,double z,double \&u,double \&v}
\descr{Abbildung eines durch die Koordinaten x, y und z gegebenenen
Raumpunktes in die Bildebene. Die Rückgabe der Koordinaten erfolgt über die
Parameter u und v.}

\proc{Line3d}{Ray}{const Point \&bp}
\procf{Line3d}{Ray}{double u,double v}
\procf{Line3d}{Ray}{const Vector \&bp}
\descr{Berechnet zu einem gegebenen Bildpunkt den Sehstrahl.}

\subsubsection{Ein- und Ausgabe}

\proch{string}{Camera::toString}{const string \&del}{camera.h}
\descr{Erzeugt einen beschreibenden String. $del$ wird als Trennzeichen
zwischen den Parametern verwendet. Typisch ist die Verwendung des
Zeilenvorschubs für eine zeilenweise Ausgabe der Parameter (default) oder 
Leerzeichen, Komma oder ähnliches für die Ausgabe auf einer Zeile.}

\subsection{Planare Selbstkalibrierung mit einem Muster nach Zhang}

Mit der Funktion \see{DrawPattern} erstellt man das zu verwendende planare
Kalibriermuster, welches man dann auf z.B. ein weißes A4 Blatt druckt oder
gleich auf dem planaren Monitor darstellt. Wird das Muster auf Papier
gedruckt, muss man darauf achten, dass das Papier planar aufliegt, es darf sich
z.B. nicht wellen usw. Von diesem Muster macht man mit einer Kamera
mindestens drei Aufnahmen aus verschiedenen Blickrichtungen ohne die internen
Kameraparameter dabei zu verändern.\\
Wichtig:\\
-die internen Parameter dürfen sich nicht ändern, z.B. nicht zoomen von
einer Aufnahme zur anderen!\\
-mindestens 3 Aufnahmen aus 3 verschiedenen Blickrichtungen. Dabei müssen
die Blickrichtungen verschieden bez. 2 Rotationsachsen sein. Liegt z.B. das
Muster auf einem Tisch, so reicht es nicht nur Aufnahmen zu machen, indem man
um den Tisch geht und aus gleicher Höhe das Muster aufnimmt, sondern man muss
auch die Höhe der Kamera noch variieren, sonst entstehen numerische Instabilitäten.\\
 Weiterhin ist bei den Aufnahmen zu beachten, dass das Muster einen großen
Teil des Bildes einnimmt. Mit der Funktion \see{Calibrate} kann man dann
einfach die inneren und äußeren Kameraparameter bestimmen. Falls es
dabei oder bei den anderen Funktionen zu Fehlermeldungen kommt, kann man den
Prekompilerbefehle \#define selfcalib\_debug in der selfcalib.h setzten und
erhält somit eine genauere Textausgabe in der Konsole sowie eine
Visualisierung der kritischen Zwischenschritte mittels zweier Images, die als
Defaulteinstellung als ungültig gesetzt sind. Nach jedem relevanten
Zwischenschritt bestätigt man mit $<$Enter$>$. Dabei kann man vor dem
Aufruf der folgenden Funktionen ein Textfenster mit der Funktion
\see{OpenAlpha} und ein Visualisierungsfenster mit der Funktion \see{Display}
bereitstellen und die beiden Bilder $debug\_image$ und $debug\_mark$ mit den
gleichen Dimensionen wie die Aufnahmen initialisieren. Mittels dem Aufruf
Show(OVERLAY,debug\_image,debug\_mark) bekommt man die Bilder überlagert
angezeigt. Für Verzeichnungen gibt es verschiedene Modelle, es wird immer
das Modell verwendet, das im Camera object festgelegt wurde, entweder
explizit, oder der Standardkonstruktur setzt einen DEFAULT-Typ.
\\
Im Verzeichnis applications findet man ein Rahmenprogramm
calib\_zhang.cpp
\\

\proch{int}{Calibrate}{vector$<$Image$>$ \&images, Camera \&c, bool dist=true, Image debug\_image = Image(), Image debug\_mark = Image()}{selfcalib.h}
\descr{Kalibrierung aus mindestens 3 gleichgroßen Aufnahmen des Testmusters. Mit $images$ werden diese Bilder als ein Vektor übergeben. $c$ ist vom Typ Camera und es werden die inneren Kameraparameter zurückgegeben. Wenn $dist=true$ ist, dann werden die Verzeichnungen berücksichtigt und mit zurückgegeben.}

\proch{int}{Calibrate}{vector$<$Image$>$ \&images, vector$<$Camera$>$ \&cv, bool dist=true, Image debug\_image = Image(), Image debug\_mark = Image()}{selfcalib.h}
\descr{Kalibrierung aus mindestens 3 gleichgroßen Aufnahmen des Testmusters. Mit $images$ werden diese Bilder als ein Vektor übergeben. $cv$ ist ein Vektor aus Kameras und es werden innere und aüßere Kameraparameter zurückgegeben, wobei die Dimensionen der beiden Vektoren gleich sein muss. Wenn $dist=true$ ist, dann werden die Verzeichnungen berücksichtigt und mit zurückgegeben.}

\proch{int}{AssignCalibPattern}{Image \&image, Matrix \&imagepoints, Matrix \&worldpoints, Image debug\_image = Image(), Image debug\_mark = Image()}{selfcalib.h}
\descr{Bestimmung der Koordinaten des Musters in der Aufnahme und Rückgabe der theoretischen Koordinaten des Musters in Bezug auf die Bilddimensionen ohne Berücksichtigung einer Verzeichnung. Mit $image$ wird eine Aufnahme des Testmussters übergeben. Mit $imagepoints$ wird eine Matrix(50,2) der ermittelten Bildkoordinaten und mit $worldpoints$ wird eine Matrix(50,3) der Weltkoordinaten des Testmusters zurückgegeben.}

\proch{int}{AssignCalibPattern}{Image \&image, Matrix \&imagepoints, Matrix \&worldpoints, Camera \&c, Image debug\_image = Image(), Image debug\_mark = Image()}{selfcalib.h}
\descr{Bestimmung der Koordinaten des Musters in der Aufnahme und Rückgabe der theoretischen Koordinaten des Musters in Bezug auf die Bilddimensionen mit Berücksichtigung einer Verzeichnung gegeben durch $c$. Mit $image$ wird eine Aufnahme des Testmussters übergeben. Mit $imagepoints$ wird eine Matrix(50,2) der ermittelten Bildkoordinaten und mit $worldpoints$ wird eine Matrix(50,3) der Weltkoordinaten des Testmusters zurückgegeben.}

\proch{int}{ComputeHomography}{Matrix \&imagepoints, Matrix \&worldpoints, Trafo \&H}{selfcalib.h}
\descr{Bestimmung der Homographie aus den Koordinaten des Musters im Bild und der theoretischen Koordinaten des Musters. Mit $imagepoints$ wird eine Matrix(50,2) der ermittelten Bildkoordinaten und mit $worldpoints$ wird eine Matrix(50,3) der Weltkoordinaten des Testmusters übergeben. Mit $H$ bekommt man die Homographie zurück.}

\proch{int}{CalibrateWithPattern}{vector$<$Matrix$>$ \&imagepoints, vector$<$Matrix$>$ \&worldpoints, Camera \&c}{selfcalib.h}
\descr{Kalibrierung aus Koordinatenpaaren gegeben als jeweils zwei Felder von mindestens 3 Aufnahmen des Testmusters. Mit einem Vektor aus $imagepoints$ der Matrizen(50,2) werden die ermittelten Bildkoordinaten aus verschiedenen Bildern des Testmusters und mit einem Vektor aus $worldpoints$ der Matrizen(50,3) werden die Weltkoordinaten des Testmusters übergeben. $c$ ist vom Typ Camera und es werden die inneren Kameraparameter zurückgegeben.}

\proch{int}{CalibrateWithPattern}{vector$<$Matrix$>$ \&imagepoints, vector$<$Matrix$>$ \&worldpoints, vector$<$Camera$>$ \&cv}{selfcalib.h}
\descr{Kalibrierung aus Koordinatenpaaren gegeben als jeweils zwei Felder von mindestens 3 Aufnahmen des Testmusters. Mit einem Vektor aus $imagepoints$ der Matrizen(50,2) werden die ermittelten Bildkoordinaten aus verschiedenen Bildern des Testmusters und mit einem Vektor aus $worldpoints$ der Matrizen(50,3) werden die Weltkoordinaten des Testmusters übergeben. $cv$ ist ein Vektor aus Kameras, wobei die Dimensionen aller Vektoren gleich sein muss, und es werden innere und aüßere Kameraparameter zurückgegeben.}

\proch{int}{CalibrateWithHomographies}{vector$<$Trafo$>$ \&H, Camera \&c}{selfcalib.h}
\descr{Kalibrierung aus mindestens 3 Homographien die als Vektor $H$ übergeben werden. $c$ ist vom Typ Camera und es werden die inneren Kameraparameter zurückgegeben.}

\proch{int}{CalibrateWithHomographies}{vector$<$Trafo$>$ \&H, vector$<$Camera$>$ \&cv}{selfcalib.h}
\descr{Kalibrierung aus mindestens 3 Homographien die als Vektor $H$ übergeben werden. $cv$ ist ein Vektor aus Kameras, wobei die Dimensionen der beiden Vektoren gleich sein muss, und es werden innere und aüßere Kameraparameter zurückgegeben.}

\proch{Image}{DrawPattern}{int dimx, int dimy}{selfcalib.h}
\descr{Es wird ein Bild der Größe $dimx$ mal $dimy$ zurückgegeben, welches 
das Testmuster für die Kalibrierfunktionen enthält. Das Bild kann 
dann z.B. ausgedruckt werden. Eine geeignete Größe ist z.B. 1200x800.}

 
\newpage
\makeatletter{}\nsection{Momente und Standardlagen}{moments}

\subsection{Momente}
\label{Moments}
\hypertarget{Moments}{}

Die Klasse \class{Moments} dient in ICE der Behandlung der Momente bis zur
4. Ordnung. Die Klasse ersetzt die veraltete Speicherung der Momente in
Feldern vom Typ $double$. 

Normalerweise werden Momente durch Aufruf eines Konstruktors angelegt und die
Werte der Momente eines übergebenen Objektes berechnet.

\subsubsection{Konstruktoren}

Konstruktoren legen eine Instanz der Klasse \class{Moments} an und 
berechnen in der Regel Momente eines übergebenen Objektes.

\proch{}{Moments::Moments}{}{momente.h}
\descr{Legt eine Datenstruktur an und belegt alle Momente mit 0.0.}
      
\proch{}{Moments::Moments}{double m[15]}{momente.h}
\descr{Legt eine Datenstruktur an und belegt alle Momente mit den Werten aus
dem Feld $m$ von $double$-Werten. Die Momente müssen in $m$ 
in der Reihenfolge $m_{00}$ ,$m_{10}$, $m_{01}$, $m_{20}$, $m_{11}$, $m_{02}$,
$m_{30}$, $m_{21}$, $m_{12}$, $m_{03}$, $m_{40}$, $m_{31}$, $m_{22}$,
$m_{13}$, $m_{04}$ abgelegt sein.}

\proch{}{Moments::Moments}{const Region \&r}{momente.h}
\procf{}{Moments::Moments}{const Contur \&c}
\descr{Die Momente des übergebenen Objektes werden berechnet. 
Diese Konstruktoren müssen explizit aufgerufen werden.}

\proch{}{Moments::Moments}{const Matrix \&p}{momente.h}
\descr{Die als Matrix angelegte Punktliste (mit einem Punkt pro Zeile) 
wird als Polygon getrachtet und die Flächen-Momente berechnet. Dieser Konstruktor
muß explizit aufgerufen werden.}

\proch{}{Moments::Moments}{PointList p}{momente.h}
\procf{}{Moments::Moments}{PointList p,int a1,int a2}
\descr{Es werden die Flächen-Momente eines in der Punktliste abgelegten Polygons
berechnet. In der zweiten Version des Aufrufes werden nur die Punkte mit den
Indizes von $a_1$..$a_2$ betrachtet. {\bf Achtung: Die Datenstruktur 
$PointList$ ist veraltet.}}

\subsubsection{Elementzugriff und einfache Werte}
Auf die Elemente der Datenstruktur $Moments$ kann über Methoden zugegriffen
werden.

\proch{double *}{Moments::Mom}{}{moments.h}
\descr{Liefert einen Zeiger auf ein Feld von $double$-Werten, das die Momente
in der Reihenfolge $m_{00}$,
$m_{10}$, $m_{01}$, $m_{20}$, $m_{11}$, $m_{02}$, $m_{30}$, $m_{21}$,
$m_{12}$, $m_{03}$, $m_{40}$, $m_{31}$, $m_{22}$, $m_{13}$, $m_{04}$
enthält.}

\proch{double \&}{operator ()}{int xi,int yi}{moments.h}
\descr{Liefert eine Referenz auf das Moment mit den entsprechenden 
Indizes/Potenzen. Dadurch können einzelne Momente gelesen oder 
geschrieben werden.}

Schwerpunkt

\proch{void}{Moments::getCentroid}{double \&xc,double \&yc}{moments.h}
\descr{
Berechnet den Schwerpunkt aus den Momenten und gibt ihn auf $xc,yc$ zurück.
}

\subsubsection{Transformationen}

Die Anwendung von geometrischen Transformationen auf Momente bedeutet, dass die
Momente bestimmt werden, wie sie das entsprechende transformierte Objekt
aufweisen würde. Die neuberechneten Momente werden zurückgegeben.

\proc{Moments}{Moments::CentralMoments}{}
\descr{Berechnet die zentrale Momente (auf den Schwerpunkt normiert).}

\proc{Moments}{Moments::Translate}{double dx,double dy}
\descr{Translation in der Richtung (dx,dy)}

\proc{Moments}{Moments::Rotate}{double phi}
\descr{Anwendung einer Rotation um den Winkel $phi$ um den Ursprung.}

\proc{Moments}{Moments::XShear}{double s}
\procf{Moments}{Moments::YShear}{double s}
\descr{Anwendung einer Scherung in X- bzw. Y-Richtung mit dem Parameter $s$.}

\proc{Moments}{Moments::Scale}{double a}
\procf{Moments}{Moments::Scale}{double a,double b}
\descr{Anwendung einer Skalierung um den Ursprung. Im ersten Fall ist die
Skalierung isotrop, im zweiten Fall bestimmen die zwei Parameter $a$ und $b$
die Skalierungen in X- bzw. Y-Richtung.}

\proc{Moments}{Moments::AffineTransform}{const Trafo \&tr}
\descr{Wendet eine {\bf affine} Transformation $tr$ an.}

\subsubsection{Invarianten}

\proc{Vector}{Moments::AffineAlgebraicInvariants}{} 
\descr{Aus den Momenten werden algebraische Invarianten nach Flusser
  berechnet und als Vector mit 4 Elementen zurückgegeben.}  
\proc{Vector}{Moments::HuInvariants}{}
\descr{Es werden aus den Momenten 7 Invarianten nach Hu berechnet
und als Vector mit 7 Elementen zurückgegeben.}
\proc{Vector}{Moments::AffineHuInvariants}{}
\descr{Es werden aus den Momenten 7 affine Invarianten nach Hu berechnet
und als Vector mit 7 Elementen zurückgegeben.
Dazu erfolgt eine Normalisierung von Translation, Scherung und Skalierung,
wonach die Invarianten nach Hu berechnet werden.}
Zu invarianten Momenten, die durch Normalisierung gewonnen werden, siehe auch
\bsee{Invariante Momente}.

\subsubsection{Affine Standardlagen und invariante Momente}
\label{Invariante Momente}

Normalisierung bestimmt eine Transformation, die ein Objekt in
eine Standardlage überführt. Die Standardlage wird durch festgelegte Werte
bestimmter Momente definiert. Das transformierte Objekt in Standardlage 
ist dann ein ausgezeichneter Repräsentant für die Objekte der Klasse 
(bezüglich affiner Transformationen). 
Ergebnisse dieser Methoden sind die Transformation (\see{Trafo}) und 
die Momente des Objekts in Standardlage. Diese Informationen können zum
Beispiel genutzt werden, um Objekte zu vergleichen. Die Momente des Objektes
in Standardlage stellen affininvariante Merkmale des Objektes dar 
(Invariante Momente).

\proch{Moments}{Moments::NormalizeSign}{}{moments.h}
\descr{
Alle Momente werden negiert, wenn das Moment $m_{0,0}$ negativ ist.
}

\proch{Moments}{Moments::NormalizeTranslation}{}{moments.h}
\procf{Moments}{Moments::NormalizeTranslation}{double \&x,double \&y}
\descr{
Normalisiert die Momente bezüglich der Translation. Die normalisierten 
Momente (zentrale Momente) werden zurückgegeben. Die Parameter der 
Translation werden den optionalen Parametern zugewiesen.
}

\proch{Moments}{Moments::NormalizeXShearing}{}{moments.h}
\procf{Moments}{Moments::NormalizeXShearing}{double \&beta}
\descr{Normalisiert die Momente bezüglich der X-Scherung 
$x' = x + \beta \cdot y$. Die normalisierten 
Momente werden zurückgegeben. Der Parameter der Scherung
 wird dem optionalen Parameter zugewiesen.
}

\proch{Moments}{Moments::NormalizeYShearing}{}{moments.h}
\procf{Moments}{Moments::NormalizeYShearing}{double \&beta}
\descr{
Normalisiert die Momente bezüglich der Y-Scherung 
$y' = y + \beta \cdot x$. Die normalisierten 
Momente werden zurückgegeben. Der Parameter der Scherung
 wird dem optionalen Parameter zugewiesen.
}

\proch{Moments}{Moments::NormalizeScaling}{scalemode mode=anisotropic}{moments.h}
\procf{Moments}{Moments::NormalizeScaling}{double \&alpha}
\procf{Moments}{Moments::NormalizeScaling}{double \&alpha,double \&beta}
\descr{
Normalisiert die Momente bezüglich der Skalierung. Die normalisierten 
Momente werden zurückgegeben. Der Parameter $mode$ kann die Werte  
$isotropic$ oder $anisotropic$ annehmen und entscheidet über die Verwendung 
einer isotropen oder anisotropen Skalierung. Alternativ wird einem Parameter 
$alpha$ der Skalierungsfaktor zugewiesen (isotrope Skalierung) bzw. den 
Parametern $alpha$ und $beta$ die Skalierungsfaktoren in X- und Y-Richtung 
(anisotrope Skalierung).
}

\proch{Moments}{Moments::NormalizeRotation}{}{moments.h}
\procf{Moments}{Moments::NormalizeRotation}{double \&phi}
\procf{Moments}{Moments::NormalizeRotation}{double \&c,double \&s}
\descr{
Normalisiert die Momente bezüglich der Rotation. Die normalisierten 
Momente werden zurückgegeben. Bei Verwendung des Parameters $phi$ wird 
darauf der Winkel der Rotation zurückgegeben. Die Parameter $c$ und $s$ 
stehen für den Cosinus beziehungsweise den Sinus des Rotationswinkels.
}

\proch{Moments}{Moments::Normalize}{Trafo \&tr,nmode mode=Moments::standard}{moments.h}
\procf{Moments}{Moments::Normalize}{nmode mode=Moments::standard}
\descr{Führt eine Normalisierung bezüglich affiner Transformationen aus. 
Je nach dem Parameter $mode$ wird 
eine Normalisierung nach Standard-Methode (mode=Moments::standard),  
eine Normalisierung nach der Polynommethode (mode=Moments::polynom) oder
eine Normalisierung nach der Iterationsmethode (mode=Moments::iteration)
durchgeführt. Die Momente nach der Normalisierung werden als Rückgabewert
zurückgegeben, die Transformation wird im Parameter $tr$ abgelegt.}

\subsubsection{Fitting mit Momenten}
Fitting mit Momenten beruht darauf, die Momente des zu fittenden Objektes 
und des Referenzobjektes durch Normalisierung in eine Standardlage zu 
überführen. Die ermittelten Transformationen erlauben eine Transformation 
des Referenzobjektes in die Lage des gegebenen Objektes und liefern somit 
ein angepasstes Objekt der gewählten Klasse. Viele dieser Funktionen liefern
optional als Ergebnis ein Gütemass, welches die Abweichung von der idealen Form 
beschreibt. Der Wert von 0 stellt also eine ideale Anpassung dar.

\proc{Trafo}{AffineFit}{const Moments \&m1,const Moments \&m2}
\descr{Bestimmt eine affine Transformation (\see{Trafo}), die die Momente 
in die übergebenen Momente $m2$ überführt.}

\proc{Matrix}{FitTriangle}{const Moments \&m}
\descr{Passt ein Dreieck an, so dass dessen Momente den gegegebenen Momenten
entsprechen. Die Rückgabe der Eckpunktkoordinaten erfolgt als Zeilen einer
Matrix (``Punktliste'').} 

\proc{Matrix}{FitEquilateralTriangle}{const Moments \&m}
\procf{Matrix}{FitEquilateralTriangle}{const Moments \&m,double \&guetemass}
\descr{Passt ein gleichseitiges Dreieck an, so dass dessen Momente den 
gegegebenen Momenten entsprechen. Die Rückgabe der Eckpunktkoordinaten 
erfolgt als Zeilen einer Matrix (``Punktliste'').} 

\proc{Matrix}{FitIsoscelesTriangle}{const Moments \&m}
\procf{Matrix}{FitIsoscelesTriangle}{const Moments \&m,double \&guetemass}
\descr{Passt ein gleichschenkliges Dreieck an, so dass dessen Momente den 
gegegebenen Momenten entsprechen. Die Rückgabe der Eckpunktkoordinaten 
erfolgt als Zeilen einer Matrix (``Punktliste'').} 

\proc{Matrix}{FitSquare}{const Moments \&m}
\procf{Matrix}{FitSquare}{const Moments \&m,double \& guetemass}
\descr{Passt ein Quadrat an, so dass dessen Momente den gegegebenen 
Momenten entsprechen. Die Rückgabe der Eckpunktkoordinaten erfolgt als 
Zeilen einer Matrix (``Punktliste'').} 

\proc{Matrix}{FitRectangle}{const Moments \&m}
\procf{Matrix}{FitRectangle}{const Moments \&m,double \&guetemass}
\descr{Passt ein Rechteck an, so dass dessen Momente den gegegebenen 
Momenten entsprechen. Die Rückgabe der Eckpunktkoordinaten 
erfolgt als Zeilen einer Matrix (``Punktliste'').}

\proc{Matrix}{FitParallelogram}{const Moments \&m}
\procf{Matrix}{FitParallelogram}{const Moments \&m,double \& guetemass}
\descr{Passt ein Parallelogramm an, so dass dessen Momente den gegegebenen 
Momenten entsprechen. Die Rückgabe der Eckpunktkoordinaten erfolgt als 
Zeilen einer Matrix (``Punktliste'').} 

\proc{Matrix}{FitQuadrangle}{const Moments \&m}
\descr{Passt ein allgemeines Viereck an, so dass dessen Momente den 
gegegebenen Momenten entsprechen. Die Rückgabe der Eckpunktkoordinaten 
erfolgt als Zeilen einer Matrix (``Punktliste'').} 

\proc{Matrix}{FitPolygon}{const Moments \&m,const Matrix \&pl}
\procf{Matrix}{FitPolygon}{const Moments \&m,const Matrix \&pl,double \&guetemass}
\descr{Passt ein Polygon an, so dass dessen Momente den gegebenen Momenten 
entsprechen. Als Startlösung ist das Polygon $pl$ zu übergeben, welches dadurch 
auch die Anzahl der Ecken festlegt.}

\proc{int}{FitCircle}{const Moments \&m,double \&x0,double \&y0,double \&radius}
\proc{Circle}{FitCircle}{const Moments \&m}
\descr{Passt einen Kreis an, so dass dessen Momente den gegegebenen 
Momenten entsprechen. Die Rückgabe der Parameter des Kreises erfolgt über 
die Variablen-Parameter $x0$, $y0$, $radius$. Alternativ wird eine
Datenstruktur \see{Circle} zurückgegeben.}

\proc{Ellipse}{FitEllipse}{const Moments \&m}
\descr{Passt eine Ellipse an, so dass deren Momente den gegegebenen 
Momenten entsprechen. Es wird wird eine Datenstruktur \see{Ellipse} 
zurückgegeben.}

\proc{double}{Orientation}{const Moments \&m}
\descr{Liefert einen Winkel (im Bogenmaß), der die Orientierung
des Objekts beschreibt. Dieser Winkel kann zur Beschreibung der 
Orientierung im Vergleich mit gleichartigen Objekten dienen.}
 
\newpage
\makeatletter{}\nsection{Statistik}{statistics}
\subsection{Erzeugung von Zufallszahlen}

\proc{void}{Randomize}{}
\descr{Initialisierung des Zufallszahlengenerators}
\proc{int}{Random}{int val}
\descr{Es wird eine Realisierung einer im Intervall [0,$val$] gleichverteilten
Zufallsvariablen erzeugt.}
\proc{double}{RandomD}{}
\descr{Es wird eine Realisierung einer im Intervall [0,1] gleichverteilten
Zufallsvariablen erzeugt.}
\proc{double}{GaussRandom}{double sigma}
\descr{Es wird eine Realisierung einer normalverteilten Zufallsvariablen 
mit dem Erwartungswert Null und der Standardabweichung $sigma$ erzeugt}

\subsection{Multivariate Statistik}
\label{Statistics}
\hypertarget{Statistics}{}

Zur Ermittlung statistischer Maßzahlen dient die Klasse $Statistics$,
die einen Datenbereich und Methoden zur Erfassung statistischer 
Eigenschaften bereitstellt.

\proc{}{Statistics::Statistics}{}
\descr{
Standard-Konstruktor. Bevor ein derart angelegter Statistikbereich
genutzt werden kann, muß dieser mit Init() initialisiert werden. 
}
\proc{}{Statistics::Statistics}{int dim}
\descr{
Ein Statistikbereich für $dim$ Zufallsvariablen wird angelegt 
und initialisiert.
}
\proc{int}{Statistics::Init}{}
\descr{
Reinitialisieren eines Statistikbereiches. Alle akkumulierten
Werte werden zurückgesetzt.
}
\proc{int}{Statistics::Init}{int dim}
\descr{
Der Statistikbereich wird für $dim$ Zufallsvariablen eingerichtet
und initialisiert.
}

\proc{int}{Put}{Statistics \&st,const Vector \&val,double weight=1.0}
\descr{
Der Zufallsvariablenvektor $val$ wird in den Statistikbereich $st$
mit einem Gewicht von $weight$ aufgenommen
}

\proc{Vector}{Mean}{const Statistics \&st}
\descr{
Liefert den Mittelwert-Vektor des Statistikbereiches $st$.
}

\proc{double}{Weight}{const Statistics \&st}
\descr{
Liefert das Gesamtgewicht aller eingtragenen Werte des 
Statistikbereiches $st$.
}

\proc{Matrix}{Covariance}{const Statistics \&st}
\descr{
Liefert die Covarianz-Matrix des Statistikbereiches $st$.
}

\proc{Matrix}{Correlation}{const Statistics \&st}
\descr{
Liefert die Korrellations-Matrix des Statistikbereiches $st$.
}

\proc{int}{Write}{const Statistics \&st,const string \&fn}
\descr{
Schreibt den Statistikbereich $st$ in die Datei $fn$.
}

\proc{int}{Read}{Statistics \&st,const string \&fn}
\descr{
Lädt den Statistikbereich $st$ aus der Datei $fn$.
}

\proc{ostream \&}{operator <<}{ostream \&s,const Statistics \&t}
\descr{
Schreibt den Statistikbereich $st$ in den Stream $s$.
}

\proc{istream \&}{operator >>}{istream \&s,Statistics \&st}
\descr{
Liest den Statistikbereich $st$ aus dem Stream $s$.
}

Das folgende Beispiel bestimmt die Statistik der Farbwerte in einem
Farbbild:

\begprogr\begin{verbatim}
void Stat(Image ri,Image gi,Image bi)
{
 int x,y, r,g,b, cl;
 Statistics st(3); // Statistikbereich mit 3 Zufalls-Größen
 wloop(mi,x,y)
  {
    r=GetVal(ri,x,y); // Größen abfragen
    g=GetVal(gi,x,y);
    b=Getval(bi,x,y);
    Put(st,Vector(r,g,b)); // Eintragen (mit Gewicht 1)
  }
 // Ergebnisse ausgeben
 cout << "Mittelwerte" << endl << Mean(st) << endl;
 cout << "Kovarianz" << endl << Covariance(st) << endl;
 cout << "Korrelation" << endl << Correlation(st) << endl;
 return clf;
}
\end{verbatim}\endprogr

\subsection{Karhunen-Loewe-Transformation}

Die Karhunen-Loewe-Transformation kann aus einer bereits ermittelten
Statistik berechnet werden oder auch anhand einer Liste von
Merkmalsvektoren.

\proc{Matrix}{KLT}{const Matrix \&m}
\procf{Matrix}{KLT}{const Matrix \&m,Vector \&r}
\descr{Für die Stichprobe von Merkmalsvektoren (Zeilenvektoren der 
Matrix $m$) wird die Karhunen-Loewe-Transformation berechnet. Wird
der Vektor $r$ als Parameter angegeben, so wird auf dem Vektor $r$
für jedes transformierte Merkmal ein Relevanzmaß zurückgegeben.
}

\proc{Matrix}{KLT}{const Statistics \&st}
\procf{Matrix}{KLT}{const Statistics \&st,Vector \&r}
\descr{Aus der Information im Statistikbereich $st$ wird die 
Karhunen-Loewe-Transformation berechnet. Wird
der Vektor $r$ als Parameter angegeben, so wird auf dem Vektor $r$
für jedes transformierte Merkmal ein Relevanzmaß zurückgegeben.
}

\subsection{Histogramme}
Die Klassen \class{Histogram} und \class{Hist} dienen der 
Berechnung von Histogrammen für eindimensionale Zufallsgrößen.
Während die Klasse \class{Histogram} eine direkt Zuordnung der Werte
im Interval 0 .. nClasses-1 zu den Klassen-Nummern verwendet, erlaubt 
die Klasse \class{Hist} die Aufteilung eines Intervalls in jeweils
gleichgroße Klassen.

\subsubsection{Die Klasse {\bf Histogram}}
\label{Histogram}
\hypertarget{Histogram}{}
Die Klasse \class{Histogram} stellt eine einfach und schnelle 
Histogramm-Klasse zur Verfügung. In die knumber Klassen des Histogrammes 
werden ganzzahlige Werte von 0 .. {\bf knumber-1} eingeordnet, wobei 
jedem Zahlenwert eine Klasse entspricht. Typische Anwendungen sind 
Histogramme von Grauwerten und Markierungen. Eine variablere 
Zuordnung von Werten zu Klassen ermöglicht die Klasse \class{Hist}.

\subtitle{Konstruktoren}

\ctor{Histogram}{}{histogram.h}
\descr{Legt ein Histogramm an. Dieses ist noch ungültig, da keine
Klassenanzahl bekannt ist (\see{Histogram::isValid}).}

\ctor{Histogram}{int knumber}{histogram.h}
\descr{Legt ein Histogramm mit $knumber$ Klassen an, wobei den Klassen
die ganzzahligen Werte 0..knumber zugeordnet sind.}

\ctor{Histogram}{const Image \&img,int diff=1}{histogram.h}
\descr{Erzeugt ein Histogramm des Bildes $img$. Zur Beschleunigung ermöglicht
  es der Parameter $diff$, in x- und y-Richtung nur jeden diff-ten Wert zu 
berücksichtigen.}

\subtitle{Elementare Methoden}
\method{int}{reset}{}
\descr{Setzt das Histogram zurück, es ist danach wieder ungültig
(\see{Histogram::isValid}).}

\method{int}{reset}{int knumber}
\descr{Setzt das Histogram zurück und legt $knumber$ Klassen neu an.}

\method{int}{isValid}{}
\descr{Gibt wahr zurück, wenn das Histogramm gültig ist. Ein Histogramm ist
  ungültig, wenn es mit dem Standard-Konstruktor angelegt wurde oder mittels
  parameterlosem \see{reset} zurückgesetzt wurde.}

\method{int}{nClasses}{}
\descr{Gibt die Zahl der Klassen im Histogramm zurück.
  Der Wert ist undefiniert für ungültige Histogramme (\see{Histogram::isValid}).}

\method{int}{addValue}{int val,int count = 1}
\descr{Trägt den Wert $val$ in das Histogramm ein. Der optionale 
  Parameter $count$ erlaubt das mehrfache Eintragen eines Wertes. 
  Durch negative Werte von $count$ können Werte wieder ausgetragen werden.
Werte außerhalb des Intervalles $[0,nClasses-1]$ werden ignoriert.
}

\method{int}{getCount}{int nr}
\methodf{int}{operator []}{int nr}
\descr{Gibt der Zahl der in die Klasse $nr$ eingetragenen Werte zurück.}

\method{\vector{int}}{getCount}{}
\methodf{void}{getCount}{\vector{int} \&v}
\descr{Gibt die gezählten Werte pro Klasse in einem int-Vektor zurück.} 

\method{double}{getRelative}{int nr}
\descr{Gibt den Anteil der in die Klasse $nr$ eingetragenen Werte zurück.}

\method{\vector{double}}{getRelative}{}
\methodf{void}{getRelative}{\vector{double} \&v}
\descr{Gibt den Anteil der in die Klassen eingetragenen Werte als 
double-Vektor zurück.}

\subtitle{Komplexe Abfragen}

\method{int}{getLimits}{int \&min, int \&max}
\descr{Ermittelt den kleinsten und den größten Wert, für den Eintrage
  im Histogramms existieren.}

\method{int}{getLimits}{int \&min, int \&max, double quantil}
\descr{Ermittelt den kleinsten und den größten Wert, für den Eintrage
  im Histogramms existieren. Dabei bleiben die jeweils 
  $quantil \cdot sum$ größten und kleinsten Werte unberücksichtigt (Ausreißer).
}

\method{int}{Statistic}{int \&sum}
\methodf{int}{Statistic}{int \&sum,double \&xm,double \&xs}
\methodf{int}{Statistic}{int \&sum,double \&xm,double \&xs,double \&skew}
\descr{Ermittelt eine Schätzung der statistischem Maßzahlen für die in das
Histogramm eingetragenen Werte.
\begin{itemize}
\item sum - Anzahl der eingetragenen Werte
\item xm - Mittelwert
\item xs - Standardabweichung
\item skew - Schiefe
\end{itemize}
}

\proch{double}{Distance}{const Histogram \&h1,const Histogram \&h2}{histogram.h}
\descr{Berechnet die ''Earth Mover's Distance'' zwischen den beiden gegebenen
  Histogrammen. Die Implementierung ist beschränkt auf Histogramme mit gleicher
  Klassen-Anzahl.}

\subtitle{Ausgabe}

\method{int}{Vis}{int val,const Image \&img}
\descr{Stellt das Histogram im Bild $img$ mit dem Wert $val$ grafisch dar.}

\proch{int}{PrintHistogram}{const Histogram \& h}{histogram\_vis.h}
\descr{Gibt das Histogramm $h$ auf dem alphanumerischen Bildschirm aus.}

\subsubsection{Die Klasse {\bf Hist}}
\label{Hist}
\hypertarget{Hist}{}

Im Unterschied zu \class{Histogram} verwendet die Klasse \class{Hist}
Gleitkommawerte für die in die Klassen einzutragenden Werte. Dies ermöglicht
eine variablere Zuordnung. Wo dies nicht nötig ist, sollte aus
Effizienzgründen die Klasse \class{Histogram} verwendet werden.

\proch{}{Hist::Hist}{}{hist.h}
\descr{
  Es wird ein Histogramm angelegt. Dieses ist wegen fehlender
  Initialisierung noch ungültig ($valid=false$).
}

\proc{}{Hist::Hist}{const Hist \&h}
\descr{
  Es wird ein Histogramm als Kopie des Histogramms $h$ angelegt. 
}

\proc{}{Hist::Hist}{int knumber,double diff=1.0,double lower=-0.5}
\descr{
  Es wird ein Histogramm mit $knumber$ Klassen, der Klassenbreite $diff$ und der
  unteren Schranke $lower$ der untersten Histogrammklasse angelegt und
  initialisiert.
}

\proc{int}{Hist::Reset}{}
\descr{
  Das Histogramm wird zurückgesetzt und Speicher wird freigegeben. Es 
  ist damit (wieder) ungültig ($valid=false$).
}

\proc{int}{Hist::Reset}{int knumber,double diff=1.0,double lower=-0.5}
\descr{
  Das Histogramm wird zurückgesetzt und neu mit $knumber$ Klassen, der 
  Klassenbreite $diff$ und der unteren Schranke $lower$ der untersten 
Histogrammklasse angelegt und initialisiert.
}

\proc{int}{Hist::Add}{double val}
\descr{
Der Wert $val$ wird in das Histogramm eingetragen.
}

\proc{int}{Hist::Count}{int index}
\descr{
Die Zahl der in die Klasse $index$ einsortierten Werte
wird zurückgegeben.
}

\proc{double}{Hist::Rel}{int index}
\descr{
Die relative Zahl der in die Klasse $index$ einsortierten Werte
wird zurückgegeben.
}

\proc{int}{Hist::Limits}{double \&min,double \&max}
\descr{Der kleinste und der größte in das Histogramm eingetragene
Wert werden auf $min$ bzw. $max$ zurückgegeben.
}

\proc{int}{Hist::Limits}{double \&min,double \&max,double quant}
\descr{
Es wird ein Intervall von Klassen ermittelt, so daß der Anteil
der unterhalb bzw. oberhalb liegenden Werte im Histogram einen 
Anteil unter quant an der Gesamtzahl der Werte hat. Der mittlere
Wert der minimalen bzw. maximalen Klasse wird auf $min$ bzw. $max$
zurückgegeben.
}

\proc{Hist}{HistImg}{Image img,int diff=1,int clw=1}
\descr{
Es wird ein Grauwerthistogramm für das Bild $img$ angelegt, wobei für jeden
möglichen Grauwert eine Klasse vorgesehen wird. Für das Histogramm werden
Bildpunkte aus einem Raster mit dem Abstand $diff$ ausgewertet. Jede Klasse
des Histogramms hat die Breite $clw$.
}

\proc{int}{Hist::Statistic}{int \&nbr,double \&mean,double \&dispers}
\descr{
Für das Histogramm wird die Anzahl der eingetragenen Werte $nbr$, 
der Mittelwert $mean$ und die empirische Standardabweichung $dispers$
bestimmt.
}

\proch{int}{PrintHist}{const Hist \& h}{hist\_vis.h}
\descr{Das Histogramm $h$ wird auf dem Text-Bildschirm ausgegeben.}

\proc{int}{Hist::Vis}{int val,Image img}
\descr{
In das Bild $img$ wird das Histogramm $h$ eingezeichnet.
}

Die folgenden Werte können zur Abfrage der Histogramm-Eigenschaften
verwendet werden:

\begin{tabular}{ll}
int valid & Boolscher Wert Gültigkeit des Histogramms\\
int number & Zahl der Klassen des Histogramms \\
double minval & Untere Schranke der ersten Klasse \\
double diff & Klassenbreite \\
\end{tabular}

\subsection{Akkumulation}
Unter Akkumulation werde hier verstanden, dass eine große Zahl von Werten erfasst und
am Ende der häufigste Wert ermittelt werde. Dies ähnelt der Eintragung von Werten 
in ein Histogramm und nachfolgender Maximumsuche. Die Akkumulatorklassen enthalten 
eine effizientere Implementierung für die spezielle Aufgabe und reduzieren die 
Quantisierungseffekte: Dazu werden Einträge neben der eigentlichen Klasse mit 
geringerem Gewicht in die Nachbarklassen eingetragen.

Die Klasse {\bf accu1} realisiert eine eindimensionale Akkumulation über einen skalaren Wert. 
{\bf accu2} akkumuliert über 2-dimensionale Werte.

\subtitle{Konstruktoren und Initialisierung}
\label{accumulation}
\hypertarget{accumulation}{}

\proch{}{accu1::accu1}{}{accu.h}
\procf{}{accu2::accu2}{}
\descr{Der Standardkonstruktor legt einen noch ungültigen Akkumulator an. 
Vor einer weiteren Nutzung müssen die Parameter mittels \bsee{accu1::setDim} 
festgelegt werden.}

\proch{}{accu1::accu1}{int n,double min=0.0,double max=1.0,bool mod=false}{accu.h}
\procf{}{accu2::accu2}{int n1,double min1,double max1,bool mod1,
int n1,double min2, double max2,bool mod2,int smear=1}
\descr{Diese Konstruktoren legen ein Akkumulatorobjekt an und initialisieren es.
Die Parameter beschreiben die Zahl der Klassen ($n$ bzw. $n1$ und $n2$), den Wertebereich 
der zu berücksichtigenden Werte ($min$ ... $max$) und legen fest, ob die Eingangsgröße
zyklisch behandelt werden soll, wie zum Beispiel Winkelgrößen.
Der Parameter smear legt fest, dass ein Wert neben der eigenen Klasse 
auch in die Nachbarklassen in einer smear*smear-Umgebung einzutragen ist. Das Gewicht 
fällt dabei proportional zum Abstand ab.
}

\proch{void}{accu1::setDim}{int n,double min=0.0,double max=1.0,bool mod=false}{accu.h}
\descr{Diese Methode legt die Parameter für die Eingangsgröße fest.
Die Parameter beschreiben die Zahl der Klassen ($n$), den Wertebereich 
der zu berücksichtigenden Werte ($min$ ... $max$) und legen fest, ob die Eingangsgröße
zyklisch behandelt werden soll, wie zum Beispiel Winkelgrößen.
}

\proch{void}{accu2::setDim}{int dim,int n,double min=0.0,double max=1.0,bool mod=false}{accu.h}
\descr{Diese Methode legt die Parameter für eine Dimension der Eingangsgröße fest.
Für dim sind die Werte 0 und 1 möglich.
Die Parameter beschreiben die Zahl der Klassen ($n$), den Wertebereich 
der zu berücksichtigenden Werte ($min$ ... $max$) und legen fest, ob die Eingangsgröße
zyklisch behandelt werden soll, wie zum Beispiel Winkelgrößen.
}

\subtitle{Eintrag von Werten}

\proch{void}{accu1::Add}{double val}{accu.h}
\descr{Trägt den Wert $val$ in das Akkumulatorobjekt ein.}

\proch{void}{accu2::Add}{double val1,double val2}{accu.h}
\procf{void}{accu2::Add}{const Vector \&v}
\procf{void}{accu2::Add}{Point v}
\descr{Trägt das Wertpaar $val1$/$val2$ in das Akkumulatorobjekt ein. Alternativ können die Werte 
als \bsee{Vector} oder als \bsee{Point} angegeben werden.}

\subtitle{Abfrage}

\proch{void}{accu1::getMax}{double \&val}{accu.h}
\procf{void}{accu1::getMax}{double \&val,double \&ct}
\descr{Ermittelt den am häufigsten aufgetretenen Wert und gibt ihn auf $val$ zurück. $ct$ wird
auf den akkumulierten Wert, ein Maß für die Häufigkeit, gesetzt.}

\proch{void}{accu2::getMax}{double \&val1,double \&val2}{accu.h}
\procf{void}{accu2::getMax}{double \&val1,double \&val2,double \&ct}
\procf{Point}{accu2::getMax}{}
\procf{Point}{accu2::getMax}{double \&ct}
\descr{Ermittelt den am häufigsten aufgetretenen Wert und gibt ihn auf $val1$/$val2$ zurück. $ct$ wird
auf den akkumulierten Wert, ein Maß für die Häufigkeit, gesetzt. Alternativ kann der Wert (das Wertepaar) 
als \bsee{Point} zurückgegeben werden.}

\subsection{Geradendetection durch Akkumulation}
Bei der Geradendetektion durch \hyperlink{accumulation}{Akkumulation} wird eine Liste von Punkten ausgewertet, die Kandidaten für 
Geradenpunkte darstellen. Für alle bzw. eine gegebene Anzahl von Paaren von diesen Punkten werden die 
Parameter der Gerade berechnet, die durch diese Punkte geht. Mittels \hyperlink{accumulation}{Akkumulation} wird 
die Gerade ermittelt, die am häufigsten aufgetreten ist und die damit durch die meisten Punkte geht.

\proch{LineSeg}{DetectLine}{const vector<Point> \&pointlist}{accu.h}
\procf{LineSeg}{DetectLine}{const vector<Point> \&pointlist,int pairs}
\procf{LineSeg}{DetectLine}{const Matrix \&pointlist}
\procf{LineSeg}{DetectLine}{const Matrix \&pointlist,int pairs}
\descr{Ermittelt durch Akkumulation eine Gerade, die durch möglichst viele Punkte der übergebenen 
Punktliste $pointlist$ geht. Im ersten Fall werden alle möglichen Punktpaare verwendet, im zweiten Fall wird die
Auswertung auf $pairs$ zufällig gewählte Punktpaare beschränkt.}

 
\newpage
\makeatletter{}\nsection{Klassifikation}{classification}

Alle Klassifikatoren bauen auf der abstrakten Basisklasse 
\class{Classifier} auf. Diese bestimmt das normale Interface
für die Verwendung von Klassifikatoren. 

Der typische Lebenszyklus eines Klassifikators besteht aus:
\begin{itemize}
\item Initalisierung und Konfiguration\\
Die Parameter eines Konstruktors werden im Konstruktor
oder in der Methode {\bf Init} festgelegt. Die 
Methode {\bf Init} erlaubt eine spätere Festlegung der 
Parameter, wenn zum Anlegen der Standard-Konstruktor 
verwendet werden soll.
\item Anlernen\\
Die Methoden {\bf Train} erlauben das Anlernen des Klassifikators
durch Vorgaben einzelner Stichproben oder einer Liste.
\item Abschluss des Lernvorganges\\
Methode {\bf Finish} verarbeitet die angelernten Stichproben. Bei 
den meisten Klassifikatoren erfolgt hier der Anlern-Vorgang, der 
die angelernten Stichproben verarbeitet.
\item Klassifizieren\\
Die Methoden {\bf Classify} kann nach dem Abschluss des Lernvorganges
genutzt werden, um anhand eines Merkmalsvektors zu klassifizieren. 
Einige Klassifikatoren verfügen über eine Methode {\bf SoftClassify}, 
die Wahrscheinlichkeiten für die Klassen zurückgibt.
\end{itemize}

\subsection{Klasse ClassSample}
Die Klasse \class{ClassSample} enthält die Merkmale einer Probe als 
\verb+vector<double>+ und die Klassen-Nummer. Die Klasse enthält die 
öffentlichen (public) Instanz-Variablen \verb+int classnr+ und 
\verb+vector<double> features+.

\ctor{ClassSample}{}{classc.h}
\descr{Standard-Konstruktor.}

\ctor{ClassSample}{int c, \cvector{double} f}{classc.h}
\descr{Legt eine Instanz von \class{ClassSample} mit den gegebenen
Werten an.}

\method{double \&}{operator[]}{int i}
\descr{Gibt das Merkmal $i$ zurück.}

\method{int}{size}{}
\descr{Gibt die Zahl der Merkmale zurück.}

\subsection{Abstrakte Klasse Classifier}
\hypertarget{Classifier}{}
Die abstrakte Klasse \class{Classifier} ist die Oberklasse zu allen 
Klassifikator-Klassen.

\ctor{Classifier}{}{classc.h}
\descr{
Standard-Konstruktor. Wird ein Klassifikator hiermit angelegt,
so muss die Methode Init verwendet werden, um die grundlegenden
Parameter vorzugeben.
}
\ctor{Classifier}{int classes,int dimension}{classc.h}
\descr{
Konstruktor, der den Klassifikator mit den notwendigen
Parametern initialisiert. Bei einzelnen Klassifikatoren sind 
mehr Parameter als die Zahl der Klassen $classes$ und die
Zahl der Merkmale $dimension$ möglich oder erforderlich.
}
\ctor{Classifier}{const Classifier \&c}{classc.h}
\descr{
Kopier-Konstruktor. Erzeugt ein Duplikat des übergebenen 
Klassifikators $c$. Das Kopieren sollte nur bei Notwendigkeit 
erfolgen, da dies bei einzelnen Klassifikatoren die Kopie großer
Datenmengen erfordert.
}

\method{int}{Init}{}
\descr{Rücksetzen des Klasifikators. 
Verwirft alle angelernten Werte und erlaubt das neue Anlernen 
mit den gleichen Parametern.}

\method{int}{Init}{int classes,int dimension}
\descr{
Initialisieren des Klassifikators mit den gegebenen Parametern.
Bei einzelnen Klassifikatoren sind mehr Parameter als die Zahl 
der Klassen $classes$ und die Zahl der Merkmale $dimension$ 
erforderlich.
}

\method{int}{Train}{const ClassSample \&sample}
\methodf{int}{Train}{int cl,const \vector{double} \&feat}
\methodf{int}{Train}{int cl,const Vector \&feat}
\descr{
Belehrt den Klassifikator mit einer Probe $sample$ oder einem einzelnen 
Merkmalsvektor $feat$, der der Klasse $cl$ zu zuordnen ist
}

\method{int}{Train}{const \vector{ClassSamples} \&samples}
\descr{
Belehrt den Klassifikator mit einer Liste von Stichproben $samples$.}

\method{int}{Train}{const Matrix \&m}
\descr{
Belehrt den Klassifikator mit einer klassifizierten Stichprobe.
Die Matrix $m$ ist eine (zeilenweise) Liste von Vektoren, die
die Merkmale und in der letzten Spalte die Klassennummer 
enthalten}

\method{int}{Train}{const Matrix \&features,const IVector \&classnr}
\descr{
Belehrt den Klassifikator mit einer Liste von Stichproben.
Die Matrix $features$ ist eine Liste von (zeilenweisen) Merkmalsvektoren,
der Integer-Vektor $classnr$ enthält die jeweilige Klassennummer.}

\method{int}{Finish}{}
\descr{Das Anlernen des Klassifikators wird beendet. Hier finden
Klassifikator-spezifische Berechnungen statt. 
Finish {\bf muss} vor der Verwendung des Klassifikators aufgerufen werden.}

\method{double}{Test}{const \vector{ClassSample} \&samples}
\method{double}{Test}{const Matrix \&m}
\method{double}{Test}{const Matrix \&features,const IVector \&classnr}
\descr{
Verifiziert den Klassifikator anhand der Stichprobe.
Der Rückgabe-Wert enthält den relativen Anteil korrekt
klassifizierter Proben.
}

\method{double}{Test}{const Matrix \&m,Matrix \&f}
\descr{
Verifiziert den Klassifikator anhand der klassifizierten 
Stichprobe in der Matrix $m$. Der Rückgabe-Wert enthält den
relativen Anteil richtig klassifizierter Proben. In der 
zurückgegebenen Matrix f werden für jede Objektklasse
(Zeilen) angegeben, welcher Anteil von Objekten dieser
Klasse in die jeweiligen Klassen (Spalten) klassifiziert 
wurden.
}

\method{int}{Classify}{const \vector{double} \&feat}
\methodf{int}{Classify}{const Vector \&feat}
\descr{
Klassifiziert den Merkmalsvektor $feat$ und liefert die Klassennummer 
zurück. Rückweisungen erster Art (das Muster gehört zu keiner Klasse) 
werden durch den Wert Classifier::rejected == -1 gekennzeichnet. 
Bei Rückweisungen zweiter Art (das Muster gehört zu mehreren Klassen) 
ist der Rückgabewert Classifier::ambiguous == -2.
}

\proc{int}{Classifier::Classify}{Matrix \&m}
\descr{
Klassifiziert die Liste von Merkmalsvektoren (Zeilen) in der
Matrix $m$. Das Ergebnis wird als zusätzliche Spalte an die
Matrix angehängt.
}

\proc{int}{Classifier::Classify}{const Matrix \&m,IVector \&cl}
\descr{
Klassifiziert die Liste von Merkmalsvektoren (Zeilen) in der
Matrix $m$. Das Ergebnis wird in Integer-Vektor $cl$ 
eingetragen.
}

\proc{int}{Classifier::Write}{const string \&fn}
\descr{
Speichert den Klassifikator in der Datei $fn$. Der Klassifikator muss
angelernt und mit \bsee{Classifier::Finish} verarbeitet worden sein.
}

\proc{int}{Classifier::Read}{const string \&fn}
\descr{
Liest den Klassifikator aus der Datei $fn$ ein.
}

\subsection{Abstrakte Klasse ClassifierNormal}
Die abstrakte Klasse \class{ClassifierNormal} dient der Implementierung
von Klassifikatoren, die
\begin{itemize}
\item alle Stichproben während des Anlernen aufsammeln und
innerhalb von {\bf Finish} verarbeiten,
\item (optional) eine Normalisierung der Merkmalswerte vornehmen wollen.
\end{itemize}

\ctor{ClassifierNormal}{}{classnormal.h}
\descr{
Standard-Konstruktor. Wird ein Klassifikator hiermit angelegt,
so muss die Methode Init verwendet werden, um die grundlegenden
Parameter vorzugeben.
}

\ctor{ClassifierNormal}{int classes,int dimension}{classnormal.h}
\descr{
Konstruktor, der den Klassifikator mit $classes$ Klassen und
jeweils $dimension$ Merkmalen initialisiert.
}

\method{void}{doNormalization}{int mode = normalizeCenter $|$ normalizeScaling $|$ normalizeIsotropic}
\descr{Die Methode wird von abgeleiteten Klassen in {\bf Finish} 
aufgerufen, um eine Normalisierung zu ermitteln und die Stichprobe 
zu normalisieren. Der Parameter $mode$ steuert die vorzunehmenden
Normalisierung:}
\begin{tabular}{|l|l|} \hline
Konstante: & Normalisiert ... \\ \hline
ClassifierNormal::normalizeCenter & ... die Mittelwerte auf 0.0 \\ \hline
ClassifierNormal::normalizeScaling & ... die Standardabweichung der
einzelnen Merkmale auf 1.0 \\ \hline
ClassifierNormal::normalizeIsotropic & ... die Standardabweichung 
aller Merkmale auf 1.0 \\ \hline
\end{tabular}

\method{void}{normalize}{\vector{double} \&feat}
\descr{Die Methode wird in der Klassifiaktion in abgeleiteten Klassen
aufgerufen, um den Merkmalsvektor mit der ermitteleten Klassifikation 
zu normalisieren.}

\subsection{Minimum-Distanz-Klassifikator}
\hypertarget{ClassifierMD}{}
Der Minimum-Distanz-Klassifikator ermittelt für jede Klasse einen
Repräsentanten, der dem Mittelwert der angelernten Stichprobe 
entspricht. Zur Klassifikation einer Probe wird die Klasse ermittelt, 
deren Repräsentant den geringsten Abstand zur Probe hat.

\ctor{ClassifierMD}{}{classmd.h}
\descr{
Standard-Konstruktor. Wird ein Klassifikator hiermit angelegt,
so muss die Methode Init verwendet werden, um die grundlegenden
Parameter vorzugeben.
}

\ctor{ClassifierMD}{int classes,int dimension}{classmd.h}
\descr{
Konstruktor, der den Klassifikator bereits mit den notwendigen
Parametern initialisiert. Parameter sind die Zahl der 
Klassen $classes$ und die Zahl der Merkmale $dimension$.
}
\ctor{ClassifierMD}{const ClassifierMD \&c}{classmd.h}
\descr{
Kopier-Konstruktor. Erzeugt ein Duplikat des übergebenen 
Klassifikators $c$.
}

Alle Methoden dieser Klasse entsprechen in Ihrem Verhalten dem
im Abschnitt für die Klasse $Classifier$ beschriebenen.

\subsection{Nearest-Neighbour-Klassifikator}
\hypertarget{ClassifierNN}{}

Der Nearest-Neighbour-Klassifikator klassifiziert anhand aller 
beim Anlernen gesehenen Proben. Dabei wird die Probe gesucht, die
vom aktuellen Merkmalsvektor den geringsten Abstand hat. 
Resultat ist dann dessen Klassenzugehörigkeit.

\ctor{ClassifierNN}{}{classnn.h}
\descr{
Standard-Konstruktor. Wird ein Klassifikator hiermit angelegt,
so muss die Methode Init verwendet werden, um die grundlegenden
Parameter vorzugeben.
}

\ctor{ClassifierNN}{int classes,int dimension,bool norm=false}{classnn.h}
\descr{
Konstruktor, der einen Klassifikator mit $classes$ Klassen und
$dimension$ Merkmalen initialisiert. Ist $norm$ gleich $true$ werden die 
Merkmale bezüglich anisotroper Skalierung normalisiert.
}

\ctor{ClassifierNN}{const ClassifierNN \&c}{classnn.h}
\descr{
Kopier-Konstruktor. Erzeugt ein Duplikat des übergebenen 
Klassifikators $c$.
}

\method{void}{Init}{int classes,int dimension,bool norm = false}
\descr{[Re-]Initialisiert den Klassifikator mit den gegebenen Werten
für die Zahl der Klassen $classes$ und die Zahl der Merkmale $dimension$.
Ist $norm$ gleich $true$ wird eine Normalisierung eine anisotropen Skalierung 
aktviert.}

Alle Methoden dieser Klasse entsprechen in Ihrem Verhalten dem
im Abschnitt für die Klasse $Classifier$ beschriebenen.

\subsection{K-Nearest-Neighbour-Klassifikator}
\hypertarget{ClassifierKNN}{}
Der K-Nearest-Neighbour-Klassifikator klassifiziert anhand aller 
beim Anlernen gesehenen Proben. Dabei werden K Proben gesucht, 
die vom aktuellen Merkmalsvektor den geringsten Abstand haben.
Durch Voting wird aus deren Klassenzugehörigkeit das 
Klassifikations-Ergebnis ermittelt.

\ctor{ClassifierKNN}{}{classknn.h}
\descr{
Standard-Konstruktor. Wird ein Klassifikator hiermit angelegt,
so muss die Methode Init verwendet werden, um die grundlegenden
Parameter vorzugeben.
}

\ctor{ClassifierKNN}{int classes,int dimension, int neighbours=3, bool norm=false, int voteMode=1}{classknn.h}
\descr{
Konstruktor, der einen Klassifikator mit $classes$ Klassen und
$dimension$ Merkmalen initialisiert. Ist $norm$ gleich $true$ werden die 
Merkmale bezüglich anisotroper Skalierung normalisiert. 
Mittels $VoteMode$ 
kann die Art des Voting (Ermitteln des Resultats aus den k Nachbarn) 
gewählt werden.
}

\method{void}{Init}{int classes,int dimension,bool norm = false,int voteMode=1}
\descr{[Re-]Initialisiert den Klassifikator mit den gegebenen Werten
für die Zahl der Klassen $classes$ und die Zahl der Merkmale $dimension$.
Ist $norm$ gleich $true$ wird eine Normalisierung eine anisotropen Skalierung 
aktviert.
Mittels $VoteMode$ 
kann die Art des Voting (Ermitteln des Resultats aus den k Nachbarn) 
gewählt werden.
}

Alle Methoden dieser Klasse entsprechen in Ihrem Verhalten dem
im Abschnitt für die Klasse $Classifier$ beschriebenen.

\subsection{Bayes-Klassifikator für zwei Klassen}
\hypertarget{ClassifierB2}{}
Der Bayes-Klassifikator für 2 Klassen ohne Rückweisung verlangt die Angabe der
Verwechslungskosten c01 von Klasse 0 mit Klasse 1 und c10 von Klasse 1 mit
Klasse 0. Weiterhin müssen die A priori-Klassenwahrscheinlichkeiten p0 für
Klasse 0 und p1 für Klasse 1 angegeben werden. Dieser Bayes-Klassifikator setzt
Normalverteilung voraus und arbeitet mit den Mittelwertvektoren und
den Kovarianzmatrizen aller Merkmale für jede Klasse. 
Die Trennfunktion für die beiden Klassen stellt eine Hyper-Fläche 2. Ordnung dar.

\ctor{ClassifierB2}{}{classb2.h}
\descr{
Standard-Konstruktor. Wird ein Klassifikator hiermit angelegt,
so muss die Methode Init verwendet werden, um die grundlegenden
Parameter vorzugeben.
}
\ctor{ClassifierB2}{int classes,int dimension,
double p0,double p1,double c01,double c10}{classb2.h}
\descr{
Konstruktor, der den Klassifikator bereits mit den notwendigen
Parametern initialisiert. Parameter sind die Zahl der 
Klassen $classes$ und die Zahl der Merkmale $dimension$,
die a priori-Wahrscheinlichkeiten $p0$,$p1$ für die Klassen 
0 und 1, sowie die Kosten für eine Fehlklassifikation eines
Objekts der Klasse 0 in die Klasse1 bzw. der Klasse 1 in die
Klasse 0.
}
\ctor{ClassifierB2}{const ClassifierB2 \&c}{classb2.h}
\descr{
Kopier-Konstruktor. Erzeugt ein Duplikat des übergebenen 
Klassifikators $c$.
}

\proc{int}{ClassifierB2::Init}{int classes,int dimension,double p0,double p0,double c01, double c10}
\descr{
Initialisieren des Klassifikators mit den gegebenen Parametern.
Parameter sind die Zahl der Klassen $classes$ und die 
Zahl der Merkmale $dimension$,
die a priori-Wahrscheinlichkeiten $p0$,$p1$ für die Klassen 
0 und 1, sowie die Kosten für eine Fehlklassifikation eines
Objekts der Klasse 0 in die Klasse1 bzw. der Klasse 1 in die
Klasse 0.
}

Alle weiteren Methoden dieser Klasse entsprechen in Ihrem 
Verhalten dem im Abschnitt für die Klasse $Classifier$ beschriebenen.

\subsection{Bayes-Klassifikator}
\hypertarget{ClassifierBayes}{}
Der Bayes-Klassifikator setzt Normalverteilung voraus und arbeitet 
mit den Mittelwertvektoren und den Kovarianzmatrizen aller Merkmale 
für jede Klasse. Der Klassifikator ist oft auch bei Abweichung von der
Normalverteilung noch einsetzbar. Die Gütebewertung
(\see{ClassifierBayes::SoftClassify}), die im Idealfall die 
Wahrscheinlichkeit der Zugehörigkeit zu der jeweiligen Klasse darstellt,
ist dann jedoch nicht zutreffend. Es werden deshalb zusätzliche Gütemaße zur
Verfügung gestellt.

\ctor{ClassifierBayes}{}{classb.h}
\descr{
Standard-Konstruktor. Wird ein Klassifikator hiermit angelegt,
so muss die Methode Init verwendet werden, um die grundlegenden
Parameter vorzugeben.
}

\ctor{ClassifierBayes}{int classes,int dimension,
bool rejection=false, int apm=APM\_EQUAL}{classb.h}
\descr{
Konstruktor, der den Klassifikator bereits mit den notwendigen
Parametern initialisiert. Parameter sind die Zahl der 
Klassen $classes$ und die Zahl der Merkmale $dimension$,
ein boolscher Wert $rejection$ für die anzulegende Rückweisungsklasse und ein
Modus $apm$ für die Behandlung der a priori-Wahrscheinlichkeiten.
Der Modus APM\_EQUAL setzt gleiche a priori-Wahrscheinlichkeiten für alle
Klassen an. APM\_CONSTRUCTOR erlaubt die explicite Festlegung der a
priori-Wahrscheinlichkeiten durch Benutzung eines speziellen
Konstruktors. Bei Angabe von APM\_TEACH wird die Statistik der Lernstichprobe
verwendet.
}

\ctor{ClassifierBayes}{int classes, \cvector{double} app, 
                       bool rejection}{classb.h}
\descr{
Konstruktor, der den Klassifikator bereits mit den notwendigen
Parametern initialisiert. Parameter sind die Zahl der 
Klassen $classes$, ein Vektor mit den a priori-Wahrscheinlichkeiten
und ein boolscher Wert $rejection$ für die anzulegende Rückweisungsklasse.
}

\ctor{ClassifierBayes}{const ClassifierBayes \&c}{classb.h}
\descr{
Kopier-Konstruktor. Erzeugt ein Duplikat des übergebenen 
Klassifikators $c$.
}

\method{int}{Init}{int classes,int dimension}
\descr{
Initialisieren des Klassifikators mit den gegebenen Parametern.
Parameter sind die Zahl der Klassen $classes$ und die 
Zahl der Merkmale $dimension$.
}

\proc{int}{ClassifierBayes::SoftClassify}{const Vector \&feat, Vector \&softclasses, int measure=1}
\descr{Führt eine normale Klassifikation anhand des Merkmalvektors $feat$
durch und gibt die wahrscheinlichste Klasse zurück. Zusätzlich wird auf
$softclasses$ eine Liste von wahrscheinlichen Klassen mit abfallender
Wahrscheinlichkeit bereitgestellt. Es werden so viele Paare von Klassennummer
und Bewertung abwechselnd eingetragen, wie in den vorhandenen Vektor 
$softclasses$ passen. Hat der vorgegebene Vektor die Größe 0, werden zwei
Klassen mit ihren Bewertungen abgelegt. Das Bewertungsmaß wird mit $measure$
festgelegt:
\begin{itemize}
\item measure=1 : Die Wahrscheinlichkeit der Zugehörigkeit zur Klasse unter der
Annahme einer Normalverteilung.
\item measure=2 : Ein Maß umgekehrt proportional zur Mahalanobis-Distanz zum
Klassen-Mittelwert.
\item measure=3 : Modifikation der Wahrscheinlichkeit durch Annahme einer
Verteilung mit einem Abfall von $e^{- \sqrt{x}}$.
\end{itemize}
}

Alle weiteren Methoden dieser Klasse entsprechen in Ihrem 
Verhalten dem im Abschnitt für die Klasse $Classifier$ beschriebenen.

\subsection{Ein Anwendungs-Beispiel}
Gegeben sei ein Farbbild mit den drei Farbauszügen in den Bildern
r, g und b. Im Bild \verb+label+ sei mit den Werten 1 und 2
eine Klassifizierung in zwei Klassen vorgenommen worden. Es ist 
ein Farb-Klassifikator anzulernen, der diese Klassen trennt.

\begprogr\begin{verbatim}
void Train(ClassifierMD &clf, const ColorImage &rgb, const Image &label)
{
 clf.Init(2, 3); // Klassifikator mit 2 Klassen und 3 Merkmalen
 vector<double> features(3); // Merkmals-Vektor
 for (int y=0; y<rgb.ysize; y++)
   for (int x=0; x<rgb.xsize; x++)
     {
       int cl=label.getPixel(x, y);
       if (cl!=0) // wenn Punkt klassifiziert ist, ...
       {
         cl--;    // Klassennummern im Bereich 0..1
         ColorValue cv=rgb.getPixel(x,y);
         features[0]=cv.red;
         features[1]=cv.green;
         features[2]=cv.blue;
         clf.Train(cl,features);  // Anlernen des Klassifikators
    }
  }
 clf.Finish(); // Lernvorgang beenden
}
\end{verbatim}\endprogr

Der Klassifikator soll nun angewendet werden:
\begprogr\begin{verbatim}
void Classify(const ClassifierMD &clf, const ColorImage &rgb, const Image &classimg)
{
  vector<double> features(3); // Merkmals-Vektor
  for (int y=0; y<rgb.ysize; y++)
    for (int x=0; x<rgb.xsize; x++)
     {
       ColorValue cv=rgb.getPixel(x, y);
       features[0]=cv.red;
       features[1]=cv.green;
       features[2]=cv.blue;
       int classnr = clf.Classify(features); // Klassifizieren
       classimg.setPixel(x, y, classnr+1);
     }
}
\end{verbatim}\endprogr

\subsection{Implementierungshinweise für weitere Klassifikator-Klassen}

Alle Klassifikatorklassen werden von der Klasse \class{Classifier} 
beziehungweise
\class{ClassifierNormal} abgeleitet.
Diese gemeinsame Basisklasse \class{Classifier} erlaubt einen alternativen 
Einsatz verschiedenster Klassifikatoren (Polymorphismus) und stellt 
außerdem verschiedene Grundfunktionen allgemein zur Verfügung.

\begin{itemize}
\item Die Konstruktoren der abgeleiteten Klasse sollten die passenden Konstruktoren der
Basisklasse aufrufen. Diese organisieren die Speicherung der Zahl der Klassen (Attribut \verb+nClasses+)
und der Zahl der Merkmale (Attribut \verb+nFeatures+).
\item Die abgeleitete Klasse sollte nicht die Methoden \verb+Train+ überschreiben, sondern die 
\verb+protected+-Methode \verb+_teach(int classNr,const std::vector<double> &features)+. Wenn die Methode 
\verb+Train+ der Basisklasse aufgerufen wird, testet sie zunächst die Parameter \verb+classNr+ und die Größe des 
\verb+vector<double>+ und zählt die Lernvorgänge pro Klasse (Attribut \verb+vector<int> classTrained+). 
Dann wird die \verb+_teach+ aufgerufen.
\item Die abgeleitete Klasse sollte nicht die Methode \verb+Finish+ überschreiben, sondern die 
\verb+protected+-Methode \verb+_finish()+. Wenn die Methode \verb+Finish+ der Basisklasse aufgerufen wird, 
prüft sie zunächst, ob alle Klassen angelernt wurden und leitet dann den Aufruf an \verb+_finish+ weiter.
\item Die abgeleitete Klasse sollte nicht die Methoden \verb+Classify+ überschreiben, sondern die 
\verb+protected+-Methode \verb+int _classify(const vector<double> &features)+. 
Wenn eine Methode \verb+Classify+ der Basisklasse aufgerufen wird, prüft diese ob das Anlernen korrekt
beendet wurde und ob die Zahl der Merkmale stimmt und reicht dann den Aufruf weiter an  
\verb+int _classify(const vector<double> &features)+. 
\end{itemize}
 
\newpage
\makeatletter{}\nsection{Funktionen}{functions}
\hypertarget{Funktionen}{}

\class{Function} und \class{Function2d} sind Klassen, die mittels 
des \verb+operator()+ skalare Funktionen von einem oder zwei Argumenten 
berechnen (''Funktoren''). Die in der Klassen-Hierarchie definierten 
Funktionen umfassen Polynome, geometrische Transformationen (analog 
\class{Trafo}), Verzeichnungen (analog \class{Distortion}) und erlauben 
die Verwendung von Bildern (\class{Image}, \class{ImageD}) als
zweidimensionale Funktionen.

Funktionshierarchie:
\begin{itemize}
\item \class{Function}
\begin{itemize}
\item \class{FunctionWithFitting}
\begin{itemize}
\item \class{Constant}
\item \class{Polynom1o}
\item \class{Polynom2o}
\item \class{Polynom}
\end{itemize}
\end{itemize}
\item \class{Function2d}
\begin{itemize}
\item \class{Function2dWithFitting}
\begin{itemize}
\item \class{Constant2d}
\item \class{Polynom2d1o}
\item \class{Polynom2d2o}
\item \class{Polynom2d}
\end{itemize}
\item \class{Function2dModifier}
\begin{itemize}
\item \class{Function2dParameterShift}
\item \class{Function2dValueTransform}
\item \class{Function2dParameterTransform}
\item \class{Function2dDistortion}
\end{itemize}
\item \class{ImageFunction}
\item \class{ImageDFunction}
\end{itemize}
\end{itemize}

\subsection{Fitting mit Funktionen}
\hypertarget{FittingWithFunctions}{}

Die von den Klassenhierarchien
\class{FunctionWithFitting} und \class{Function2dWithFitting} abgeleiteten 
Klassen erlauben die Bestimmung der Parameter dieser Funktionen mittels Fitting.

Fitting kann grundsätzlich über die Vorgabe einzelner Werte-Tupel erfolgen
oder durch Vorgabe einer Liste.
\begin{itemize}
\item Im Falle einzelner Werte-Tupel ist zunächst
das Fitting zu initialisieren \see{FunctionWithFitting::FitInit}, 
dann sind die Werte-Tupel mit \see{FunctionWithFitting::FitVal} einzutragen. 
Nach dem Abschluss mit \see{FunctionWithFitting::FitFinish} stehen die
gefitteten Parameter zur Verfügung.
\item Im Falle einer Liste erfolgt das komplette Fitting durch Aufruf der
 Methode \see{FunctionWithFitting::Fit}. Neben einer Wertetupel-Liste 
in Form einer \see{Matrix} können bei zweidimensionalen Funktionen auch 
Bilder zum Fitten übergeben werden.
\end{itemize}

\seealso{GaussFit}

\subsection{Eindimensionale Funktionen}
\label{Function}
\hypertarget{Function}{}
Die abstrakte Basisklasse \class{Function} beschreibt skalare 
Funktionen mit einem Parameter. Wesentliche Eigenschaft dieser
Klasse ist der \verb+operator()+, der mit einem Parameter vom Typ
\verb+double+ aufgerufen werden kann. 

\proch{double}{Function::operator()}{double x}{function.h}
\descr{Berechnet den Funktionswert der Funktion an der Stelle {\bf x}.}

\proch{void}{Function::getCoefficient}{\vector{double} \&c}{function.h}
\descr{Ermittelt die Parameter (Coefficienten) der Funktion. Diese werden
an den \vector{double} {\bf c} angehängt. Dies erlaubt das Aufsammeln 
der Parameter mehrerer Funktionen in einem \vector{double}.}

\proch{int}{Function::setCoefficient}{const \vector{double} \&para,int idx=0}{function.h}
\descr{Setzt die Parameter (Coefficienten) der Funktion. Diese werden
dem \vector{double} ab dem Index {\bf idx} entnommen. Die Funktion
gibt den Index nach dem letzten gelesenen Element zurück.
Dies erlaubt die Initialisierung mehrerer Funktionen aus einem 
\vector{double}.}

\subsection{Eindimensionale Funktionen mit Fitting}
\label{FunctionWithFitting}
\hypertarget{FunctionWithFitting}{}

Die von der Klasse \class{Function} abgeleitete abstrakte Klasse 
\class{FuntionWithFitting} beschreibt 
eindimensionale Funktionen, deren Parameter durch Fitting ermittelt werden
können. 

\proch{void}{FunctionWithFitting::FitInit}{void}{fitfn.h}
\descr{Die abstrakte Methode initialisiert das Fitten von Wertpaaren.}

\proch{void}{FunctionWithFitting::FitValue}{double x, double g, double w=1.0}{fitfn.h}
\descr{Die (abstrakte) Methode übergibt ein Wertepaar für das Fitting. Die
optionale Angabe des Gewichts $w$ erlaubt die Wichtung des Wertepaars,
negative Gewichte tragen quasi das Wertepaar wieder aus.}
\proch{int}{FunctionWithFitting::FitFinish}{}{fitfn.h}
\descr{Schließt den Prozess des Fitting ab. Danach sind die gefitteten 
Parameter der Funktion gültig.}

\proch{int}{FunctionWithFitting::Fit}{const Matrix \&m}{fitfn.h}
\descr{Die Funktion wird an die Wertepaare in der Matrix $m$ gefittet.
Dabei stellt jede Zeile der Matrix ein Wertepaar bereit: Die Matrix muss
 mindestens zwei Spalten haben. Diese Funktion umfasst alle Schritte von 
der Initialisierung (\see{FunctionWithFitting::FitInit}) über das 
Eintragen der Werte (\see{FunctionWithFitting::FitValue}) bis zum 
Abschluss des Fittens (\see{FunctionWithFitting::FitFinish}).
Vorher mit \bsee{FunctionWithFitting::FitValue} eingetragene Werte
gehen verloren.}

\proch{double}{FunctionWithFitting::operator()}{double x}{fitfn.h}
\descr{Gibt den Funktionswert der Funktion an der Stelle $x$ zurück}

\seebaseclass{Function}

\subsubsection{Konstante eindimensionale Funktionen}
\label{Constant}
\hypertarget{Constant}{}
Die Klasse Constant beschreibt konstante eindimensionale Funktionen der Form
$f(x) = a$ . Sie ist von der Klasse \class{FunctionWithFitting} abgeleitet. 

\proch{}{Constant::Constant}{void}{fitfn.h}
\descr{Standard-Konstruktor. Der Parameter $a$ wird mit $0$ initialisiert.}
\proch{}{Constant::Constant}{double a}{fitfn.h}
\descr{Konstruktor, der die Koeffizienten mit den übergebenen Werten initialisiert.}
\proch{}{Constant::Constant}{const \vector{double} \&v}{fitfn.h}
\descr{Konstruktor, der den Parameter a mit mit dem Wert $v[0]$ des Vektors $v$ initialisiert.}

\proch{}{Constant::Constant}{const Constant \&f}{fitfn.h}
\descr{Kopier-Konstruktor}

\proch{int}{Constant::setCoefficient}{double pa}{fitfn.h}
\descr{Setzt den Wert des Parameters a auf $pa$.}

\proch{int}{Constant::getCoefficient}{double \&pa}{fitfn.h}
\descr{Schreibt den Wert des Parameters auf $pa$.}

\seebaseclass{FunctionWithFitting}

\subsubsection{Lineare eindimensionale Funktionen}
\label{Polynom1o}
\hypertarget{Polynom1o}{}
Die Klasse Polynom1o beschreibt lineare eindimensionale Funktionen der Form
$ f(x) = a_1 \cdot x + a_0$ . Sie ist von der Basisklasse 
\class{FunctionWithFitting} abgeleitet.

\proch{}{Polynom1o::Polynom1o}{void}{fitfn.h}
\descr{Standard-Konstruktor. Die Koeffizienten werden mit $a_0=0$ und $a_1=0$ 
initialisiert.}
\proch{}{Polynom1o::Polynom1o}{double a0, double a1}{fitfn.h}
\descr{Konstruktor, der die Koeffizienten mit den übergebenen Werten initialisiert.}
\proch{}{Polynom1o::Polynom1o}{const \vector{double} \&v}{fitfn.h}
\descr{Konstruktor, der die Koeffizienten werden mit den Werten des 
\vector{double} $v[0]$ und $v[1]$ initialisiert.}
\proch{}{Polynom1o::Polynom1o}{const Polynom1o \&f}{fitfn.h}
\descr{Kopier-Konstruktor}

\proch{int}{Polynom1o::setCoefficient}{double a0, double a1}{fitfn.h}
\descr{Setzt die Werte der Parameter $a_0$ und $a_1$.}

\proch{int}{Polynom1o::getCoefficient}{double \&a0, double \&a1}{fitfn.h}
\descr{Schreibt die Koeffizienten-Werte auf $a0$ und $a1$.}

\seebaseclass{FunctionWithFitting}

\subsubsection{Quadratische eindimensionale Funktionen}
\label{Polynom2o}
\hypertarget{Polynom2o}{}

Die Klasse Polynom2o beschreibt quadratische eindimensionale Funktionen der 
Form $ f(x) = a_2 \cdot x^2 + a_1 \cdot x + a_0$ . Sie ist von der Basisklasse 
\class{FunctionWithFitting} abgeleitet.

\proch{}{Polynom2o::Polynom2o}{void}{fitfn.h}
\descr{Standard-Konstruktor. Die Koeffizienten werden mit $a_0=0$, $a_1=0$ und $a_2=0$ 
initialisiert.}
\proch{}{Polynom2o::Polynom2o}{double a0, double a1, double a2}{fitfn.h}
\descr{Konstruktor, der die Koeffizienten mit den übergebenen Werten initialisiert.}
\proch{}{Polynom2o::Polynom2o}{const Vector \&v}{fitfn.h}
\descr{Konstruktor, der die Koeffizienten werden mit den Werten des Vektors
$v[0]$, $v[1]$ und $v[2]$ initialisiert.}
\proch{}{Polynom2o::Polynom2o}{const Polynom2o \&f}{fitfn.h}
\descr{Kopier-Konstruktor}

\proch{int}{Polynom2o::setCoefficient}{double a0, double a1, double a2}{fitfn.h}
\descr{Setzt die Werte der Parameter $a_0$, $a_1$ und $a_2$.}

\proch{int}{Polynom2o::getCoefficient}{double \&a0, double \&a1, double \&a2}{fitfn.h}
\descr{Schreibt die Koeffizienten-Werte auf $a0$, $a1$ und $a2$.}

\seebaseclass{FunctionWithFitting}

\subsubsection{Allgemeine polynomiale Funktionen}
\label{Polynom}
\hypertarget{Polynom}{}

Die Klasse Polynom beschreibt allgemeine polynomiale Funktionen der Form
$ f(x) = \sum_{i=0}^n a_i \cdot x^i$ . Sie ist von der Basisklasse 
\class{FunctionWithFitting} abgeleitet.

\proch{}{Polynom::Polynom}{void}{fitfn.h}
\descr{Standard-Konstruktor. Polynomiale Funktion der Ordnung 0 - Konstante.}
\proch{}{Polynom::Polynom}{int ord}{fitfn.h}
\descr{Erzeugt eine Polynomiale Funktion der Ordnung $ord$. Die
Koeffizienten werden mit 0 initialisiert. }
\proch{}{Polynom::Polynom}{const \vector{double} \&v}{fitfn.h}
\descr{Konstruktor, der die Koeffizienten werden mit den Werten des Vektors
$v[i]$ initialisiert.}
\proch{}{Polynom::Polynom}{const Polynom \&f}{fitfn.h}
\descr{Kopier-Konstruktor}

\seebaseclass{FunctionWithFitting}

\subsection{Zweidimensionale Funktionen}
\label{Function2d}
\hypertarget{Function2d}{}

Die abstrakte Basisklasse \class{Function2d} beschreibt skalare 
Funktionen mit zwei Parametern. Wesentliche Eigenschaft dieser
Klasse ist der \verb+operator()+, der mit zwei Parameter vom Typ
\verb+double+ aufgerufen werden kann oder mit einem Parameter 
vom Typ \class{Point}.

\proch{double}{Function2d::operator()}{double x,doubel y}{function.h}
\procf{double}{Function2d::operator()}{Point p}
\descr{Berechnet den Funktionswert der Funktion an der Stelle {\bf x, y}
oder an der Stelle des Punkte {\bf p}.}

\proch{void}{Function2d::getCoefficient}{\vector{double} \&c}{function.h}
\descr{Ermittelt die Parameter (Koeffizienten) der Funktion. Diese werden
an den \vector{double} angehängt. 
Dies erlaubt das Aufsammeln der Parameter mehrerer Funktionen in 
einem \vector{double}.}

\proch{int}{Function2d::setCoefficient}{const \vector{double} \&para,int idx=0}{function.h}
\descr{Setzt die Parameter (Koeffizienten) der Funktion. Diese werden
dem \vector{double} ab dem Index {\bf idx} entnommen. 
Die Funktion gibt die Position nach dem letzten gelesenen Wert zurück.
Dies erlaubt die Initialisierung mehrerer Funktionen mit 
einem \vector{double}.}

\subsection{Zweidimensionale Funktionen mit Fitting}
\label{Function2dWithFitting}
\hypertarget{Function2dWithFitting}{}

Die abstrakte Klasse \class{Function2dWithFitting} ist von der Klasse
\class{Function2d} abgeleitet und beschreibt zweidimensionale Funktionen, 
deren Parameter durch Fitting ermittelt werden können.

\proch{int}{Function2dWithFitting::FitInit}{}{fitfn.h}
\descr{Die abstrakte Methode initialisiert das Fitten von Werttupeln.}
\proch{int}{Function2dWithFitting::FitVal}{double x, double y, double g, double w=1.0}{fitfn.h}
\descr{Die abstrakte Methode übergibt ein Wertetupel für das Fitten. Optional
ist es möglich, ein Gewicht $w$ des Typels anzugeben.}
\proch{int}{Function2dWithFitting::FitVal}{const Point \&p, double g, double w=1.0}{fitfn.h}
\descr{Die abstrakte Methode übergibt ein Wertetupel für das Fitten, wobei die
Koordinaten x und y von \see{Point} $p$ als Argument verwendet werden. Optional
ist es möglich, ein Gewicht $w$ des Typels anzugeben.}
\proch{int}{Function2dWithFitting::FitFinish}{}{fitfn.h}
\descr{Schließt den Prozess des Fitting ab. Danach sind die gefitteten 
Parameter der Funktion gültig.}

\proch{int}{Function2dWithFitting::Fit}{const Matrix \&m}{fitfn.h}
\descr{Die Funktion wird an die Wertetupel in der Matrix $m$ gefittet.
Dabei stellt jede Zeile der Matrix ein Wertetupel bereit. Die Matrix muß also
  mindestens drei Spalten haben.
Diese Funktion umfasst alle Schritte von 
der Initialisierung (\see{Function2dWithFitting::FitInit}) über das 
Eintragen der Werte (\see{Function2dWithFitting::FitValue}) bis zum 
Abschluss des Fittens (\see{Function2dWithFitting::FitFinish}).
Vorher mit \bsee{Function2dWithFitting::FitValue} eingetragene Werte
gehen verloren.}

\proch{int}{Function2dWithFitting::Fit}{Image img}{fitfn.h}
\proch{int}{Function2dWithFitting::Fit}{ImageD img}{fitfn.h}
\descr{Die Funktion wird an die Grauwerte des Bildes $img$ gefittet.}

\proch{double}{Func2d::operator()}{double x, double y}{fitfn.h}
\procf{double}{Func2d::operator()}{Point p}
\descr{Gibt den Funktionswert der Funktion an der Stelle $x,y$ zurück.}

\seebaseclass{Function2d}

\subsubsection{Konstante zweidimensionale Funktionen}
\label{Constant2d}
\hypertarget{Constant2d}{}

Die Klasse \class{Constant2d} beschreibt konstante 
zweidimensionale Funktionen der Form $ f(x,y) = a$ . 
Sie ist von der Basisklasse 
\class{Function2dWithFitting} abgeleitet.

\proch{}{Constant2d::Constant2d}{void}{fitfn.h}
\descr{Standard-Konstruktor. Der Parameter $a$ wird mit $0$ initialisiert.}
\proch{}{Constant2d::Constant2d}{double a}{fitfn.h}
\descr{Konstruktor, der den Parameter $a$ mit dem übergebenem Wert initialisiert.}
\proch{}{Constant2d::Constant2d}{const \vector{double} \&v}{fitfn.h}
\descr{Konstruktor, der Parameter $a$ wird mit dem Wert $v[0]$ des Vektors $v$
initialisiert.}
\proch{}{Constant2d::Constant2d}{const Constant2d \&f}{fitfn.h}
\descr{Kopier-Konstruktor}

\proch{void}{Constant2d::setCoefficient}{double a}{fitfn.h}
\descr{Setzt den Wert des Parameters $a$.}

\proch{void}{Constant2d::getCoefficient}{double \&a}{fitfn.h}
\descr{Schreibt den Wert des Parameters $a$ auf die übergebene 
Variable $a$.}

\seebaseclass{Function2dWithFitting}

\subsubsection{Lineare zweidimensionale Funktionen}
\label{Polynom2d1o}
\hypertarget{Polynom2d1o}{}

Die Klasse \class{Polynom2d1o} beschreibt lineare zweidimensionale 
Funktionen der Form
$ f(x,y) = a_{10} \cdot x + a_{01} \cdot y + a_{00}$ . Sie ist von der Basisklasse 
\class{Function2dWithFitting} abgeleitet.

\proch{}{Polynom2d1o::Polynom2d1o}{void}{fitfn.h}
\descr{Standard-Konstruktor. Die Koeffizienten werden mit $a_{00}=0$,
$a_{10}=0$ und $a_{01}=0$ initialisiert.}
\proch{}{Polynom2d1o::Polynom2d1o}{double a00, double a10, double a01}{fitfn.h}
\descr{Konstruktor, der die Koeffizienten mit den übergebenen Werten initialisiert.}
\proch{}{Polynom2d1o::Polynom2d1o}{const \vector{double} \&v}{fitfn.h}
\descr{Konstruktor, der die Koeffizienten werden mit den Werten des Vektors
$v[0]$,$v[1]$ und $v[2]$ initialisiert.}
\proch{}{Polynom2d1o::Polynom2d1o}{const Polynom2d1o \&f}{fitfn.h}
\descr{Kopier-Konstruktor}

\proch{void}{Polynom2d1o::setCoefficient}{double a00, double a10, double a01}{fitfn.h}
\descr{Setzt den Wert der Parameter $a_{00}, a_{10}$ und $a_{01} $.}

\proch{void}{Polynom2d1o::getCoefficient}{double \&a00, double \&a10, double \&a01}{fitfn.h}
\descr{Schreibt den Wert der Parameter auf die übergebene Variablen.}

\seebaseclass{Function2dWithFitting}

\subsubsection{Zweidimensionale Funktionen zweiter Ordnung}
\label{Polynom2d2o}
\hypertarget{Polynom2d2o}{}

Die Klasse \class{Polynom2d2o} beschreibt zweidimensionale 
Polynome zweiter Ordnung der Form 
$ f(x,y) = a_{20} \cdot x^2 + a_{11} \cdot x \cdot y + a_{02} \cdot y^2 + a_{10}
\cdot x + a_{01} \cdot y + a_{00}$ . 
Sie ist von der Basisklasse \class{Function2dWithFitting} abgeleitet.

\proch{}{Polynom2d2o::Polynom2d2o}{void}{fitfn.h}
\descr{Standard-Konstruktor. Alle Koeffizienten werden 0 initialisiert.}
\proch{}{Polynom2d2o::Polynom2d2o}{double a00, double a10, double a01, double a20, double
a11, double a02}{fitfn.h}
\descr{Konstruktor, der die Koeffizienten mit den übergebenen Werten initialisiert.}
\proch{}{Polynom2d2o::Polynom2d2o}{const \vector{double} \&v}{fitfn.h}
\descr{Konstruktor, der die Koeffizienten mit den Werten $v[0]$ bis $v[5]$ 
initialisiert.}
\proch{}{Polynom2d2o::Polynom2d2o}{const Polynom2d2o \&f}{fitfn.h}
\descr{Kopier-Konstruktor}

\proch{void}{Polynom2d2o::setCoefficient}{double a00, double a10, double a01, double a20, double a11, double a02}{fitfn.h}
\descr{Setzt den Wert der Parameter 
$a_{00}, a_{10}, a_{01}, a_{20}, a_{11}$ und $a_{20} $.}

\proch{void}{Polynom2d2o::getCoefficient}{double \&a00, double \&a10, double \&a01, double \&a20, double \&a11, double \&a02}{fitfn.h}
\descr{Schreibt den Wert der Parameter auf die übergebene Variablen.}

\seebaseclass{Function2dWithFitting}

\subsubsection{Allgemeine zweidimensionale polynomiale Funktionen}
\label{Polynom2d}
\hypertarget{Polynom2d}{}

Die Klasse \class{Polynom2d} beschreibt allgemeine polynomiale 
Funktionen der Form
$ f(x,y) = \sum_{i,j} a_{i,j} \cdot x^i y^j$ . 
Sie ist von der Basisklasse \see{Function2dWithFitting} abgeleitet. 
Die Ordnung $ord$ des Polynoms begrenzt die Potenzen auf
$i+j \le ord$.

\proch{}{Polynom2d::Polynom2d}{void}{fitfn.h}
\descr{Standard-Konstruktor, erzeugt eine konstante Funktion (Ordnung=0).}
\proch{}{Polynom2d::Polynom2d}{int ord}{fitfn.h}
\descr{Erzeugt eine Polynomiale Funktion der Ordnung $ord$. Die
Koeffizienten werden mit 0 initialisiert. }
\proch{}{Polynom2d::Polynom2d}{const \vector{double} \&v}{fitfn.h}
\descr{Konstruktor, der die Koeffizienten werden mit den Werten des Vektors
$v[i]$ initialisiert.}
\proch{}{Polynom2d::Polynom2d}{const Polynom2d \&f}{fitfn.h}
\descr{Kopier-Konstruktor}

\seebaseclass{Function2dWithFitting}

\subsection{Funktions-Modifizierer}
\label{Function2dModifier}
\hypertarget{Function2dModifier}{}

Die (abstrakte) Klasse \class{Function2dModifier} ist von der Basisklasse
\class{Function2d} abgeleitet und beschreibt Funktionen, die andere 
Funktionen modifizieren. Die Klassen \class{Function2dParameterShift},
\class{Function2dParameterTransform} und \class{Function2dDistortion}
transformieren die Parameter einer Funktion vor dem Aufruf.
Die Klasse \class{Function2dValueTransform} wendet auf den von einer
Funktion zurückgelieferten Wert eine lineare Funktion an.

\proch{}{Function2dModifier::Function2dModifier}{Function2d \&funcp}{trfunc.h}
\descr{Konstruktor, der als Parameter die zu modifizierende
Funktion erhält.}

\seebaseclass{Function2d}

\subsubsection{Verschiebung einer Funktion}
\label{Function2dParameterShift}
\hypertarget{Function2dParameterShift}{}
Die von der Klasse \class{Function2dModifier} abgeleitete 
Klasse \class{Function2dParameterShift} modifiziert eine
Funktion dadurch, dass auf von den Aufrufparametern x und y konstante
Werte dx und dy subtrahiert werden: $ g(x,y) = f ( x - dx, y - dy ) $.
Dies entspricht einer Verschiebung der Funktion um (dx,dy).

\proch{}{Function2dParameterShift::Function2dParameterShift}{Function2d \&funcp, double sx, double sy}{trfunc.h}
\descr{Konstruktor, der die zugrundeliegende Funktion und die Offset-Werte
für die Parameter übernimmt.}

\seebaseclass{Function2dModifier}

\subsubsection{Geometrische Transformation einer Funktion}
\label{Function2dParameterTransform}
\hypertarget{Function2dParameterTransform}{}
Die von der Klasse \class{Function2dModifier} abgeleitete 
Klasse \class{Function2dParameterTransform} unterwirft eine Funktion
einer Transformation $T$ der Klasse \class{Trafo}. Dazu werden die
Parameter x und y der entsprechenden inversen Transformation
unterworfen: $ g(x,y)=f(T^{-1}(x,y))$ .

\proch{}{Function2dParameterTransform::Function2dParameterTransform}{Function2d \&funcp, const Trafo \&tr}{trfunc.h}
\descr{Konstruktor, der die zugrundeliegende Funktion und die anzuwendende
Transformation übernimmt.}

\proch{Trafo \&}{Function2dParameterTransform::Tr}{}{trfunc.h}
\procf{const Trafo \&}{Function2dParameterTransform::Tr}{}
\descr{Zugriff auf die anzuwendende Transformation.}

\seebaseclass{Function2dModifier}

\subsubsection{Verzeichnung einer Funktion}
\label{Function2dDistortion}
\hypertarget{Function2dDistortion}{}
Die von der Klasse \class{Function2dModifier} abgeleitete 
Klasse \class{Function2dDistortion} unterwirft eine Funktion
einer Verzeichnung $D$ der Klasse \class{Distortion}. Dazu werden die
Parameter x und y der entsprechenden inversen Transformation
unterworfen: $ g(x,y)=f(D^{-1}(x,y))$ .

\proch{}{Function2dDistortion::Function2dDistortion}{Function2d \&funcp, Distortion \&tr}{trfunc.h}
\descr{Konstruktor, der die zugrundeliegende Funktion und die anzuwendende
Verzeichnung übernimmt. Die Verzeichnung wird als Referenz gespeichert. 
Die übergebene Instanz der Klasse \class{Distortion} muss deshalb
solange gültig bleiben, wie die Funktion genutzt wird. 
}

\seebaseclass{Function2dModifier}

\subsubsection{Transformation des Funktionswertes}
\label{Function2dValueTransform}
\hypertarget{Function2dValueTransform}{}
Die von der Klasse \class{Function2dModifier} abgeleitete 
Klasse \class{Function2dValueTransform} wendet auf den Funktionswert 
einer Funktion eine lineare Funktion an: $ g(x,y) = a_1 \cdot f(x,y) + a_0 $ .

\proch{}{Function2dValueTransform::Function2dValueTransform}{Function2d \&funcp, double a1, double a0}{trfunc.h}
\descr{Konstruktor, der die zugrundeliegende Funktion und die Parameter
der linearen Funktion übernimmt.}

\seebaseclass{Function2dModifier}

\subsection{Bilder als Funktionen}
\label{ImageFunction}
\label{ImageDFunction}
\hypertarget{ImageFunction}{}
\hypertarget{ImageDFunction}{}

Die von der Basisklasse \class{Function2d} abgeleiteten Klassen
\class{ImageFunction} und \class{ImageDFunction} stellen Bilder
der Klassen \class{Image} und \class{ImageD} als Funktion zur 
Verfügung. Dabei kann der Typ der Interpolation mittels
Parameter {\bf mode} gewählt werden:

\begin{tabular}{ll}
mode & Interpolation \\
DEFAULT & Nearest Neighbor \\
INTERPOL & Bilineare Interpolation \\
\end{tabular}

\proch{}{ImageFunction::ImageFunction}{const Image \&imgp, int mode = INTERPOL}{function.h}
\procf{}{ImageDFunction::ImageDFunction}{const ImageD \&imgp, int mode = INTERPOL}
\descr{Konstruktor für Bildfunktionen mit Übergabe des Bildes und Auswahl des
Interpolationstypes.}
 
\newpage
\makeatletter{}\nsection{Bildbearbeitung}{processing}
\label{Bildbearbeitung}

In diesem Abschnitt werden Operationen über Bilder beschrieben, deren Ergebnis
in der Regel wieder Bilder sind. \bsee{Filter} werden in einem eigenen 
Abschnitt beschrieben (\see{Filter}).
Alle Typen von Bildrepräsentationen werden hier, soweit es geht, gemeinsam 
abgehandelt (\class{Image}, \class{ImageD}, \class{ColorImage}). 
Auf die Besonderheiten bei bestimmten Typen wird speziell hingewiesen. 

\subsection{Grauwerttransformationen}

\proch{int}{BinImg}{const Image \&src,Image \&dest,int thr=1,int val=-1}{arith.h}
\procf{int}{BinImg}{Image \&src,int thr=1}
\descr{
Binarisierung des Bildes $src$. Im Zielbild $dest$ werden alle Bildpunkte, 
deren Grauwerte im Bild $src$ größer oder gleich $thr$ sind, auf $val$ 
gesetzt, alle anderen Bildpunkte auf Null. Wird $val$ auf -1 gesetzt (default),
wird der maximale Grauwert des Zielbildes verwendet.
Bei Aufruf ohne $dest$ wird das Ergebnis in $src$ geschrieben.
Die Bestimmung der Schwelle $thr$ kann durch \see{CalcThreshold} erfolgen.
}

\proch{int}{FindMin}{const Image \&img, int \&x, int \&y}{arith.h}
\procf{int}{FindMin}{const Image \&img, IPoint \&p}
\procf{int}{FindMin}{const Image \&img}
\procf{int}{FindMax}{const Image \&img, int \&x, int \&y}
\procf{int}{FindMax}{const Image \&img, IPoint \&p}
\procf{int}{FindMax}{const Image \&img}
\descr{Die Funktionen finden den minimalen/maximalen Wert im Bild $img$ und geben diesen
als Funktionwert zurück. Bei Angabe der Parameter $x$ und $y$ bzw. $p$ wird die Position,
an der dieser Wert gefunden wurde, darauf zurückgegeben.
\seealso{PeakValuation}
}

\proch{int}{GetGrayLimits}{const Image \&img,int \&min,int \&max, 
int mode=GV\_QUANTILE, bool cutMargExtr = false, 
double minq = 0.1, double maxq = 0.1}{lintrans.h}
\procf{int}{GetGrayLimits}{const Hist \& h, int\& min, int\& max, 
int mode=GV\_QUANTILE, bool cutMargExtr = false, 
double minq = 0.1, double maxq = 0.1 }
\descr{
Es werden aus dem Bild $img$ bzw. Histogramm $h$ die untere Grauwertgrenze
$min$ und obere Grenze $max$ bestimmt. Dieses Grauwertintervall kann zum
Beispiel für die lineare Grauwert-Transformation \see{GrayTransformLimits}
genutzt werden, um den vollen Grauwertbereich auszunutzen. 
Für $mode$ können gewählt werden
GV\_QUANTILE (default), GV\_MEAN, GV\_DERIVE\_NO\_SMOOTH, GV\_DERIVE\_SMOOTH,
GV\_TOTAL\_SMOOTH, GV\_SEC\_DER\_EN, GV\_ALL\_METH.
Bei $mode$=GV\_QUANTILE werden die Quantile $minq$ und $maxq$ (in Prozent)
für die Ermittlung der unteren und die oberen Grenze verwendet.
}

\proch{int}{GrayTransform}{const Image \&src, const Image \&dest, double a1, double a0}{lintrans.h}
\procf{int}{GrayTransform}{const Image \&src, double a1, double a0}
\descr{
Die Grauwerte des Bildes $src$ werden nach der Formel 
$g \prime  = a1 \cdot g + a0$
transformiert. 
Das Ergebnis steht in Bild $dest$ oder wird in $src$ eingetragen.
}

\proch{int}{GrayTransformLimits}{const Image \&src, const Image \& dest, int min, int max}{lintrans.h}
\procf{int}{GrayTransformLimits}{const Image \&src, int min, int max}
\descr{
Die Grauwerte des Bildes $src$ werden linear transformiert, so dass $min$ im
Zielbild den Wert 0 ergibt, $max$ den Wert $dst->maxval$. Das Ergebnis steht 
in Bild $dst$ oder wird in $src$ eingetragen.
}

\proch{int}{GrayNormalize}{const Image \&src,const Image \& dest, int mode=GV\_QUANTILE, 
bool cutMargExtr = false, double minq = 0.1, double maxq = 0.1}{lintrans.h}
\procf{int}{GrayNormalize}{const Image \&src, int mode=GV\_QUANTILE, bool cutMargExtr = false, double minq = 0.1, double maxq = 0.1}
\descr{Die Grauwerte des Bildes $src$ werden normalisiert, indem mittels
\see{GetGrayLimits} der Grauwertbereich ermittelt und mittels
\see{GrayTransformLimits} auf den Grauwertbereich 0..$dst->maxval$
transformiert wird.}

\proch{int}{HistogramEqual}{const Image \&img1,const Image \&img2}{icefunc.h}
\descr{
Es wird im Bild {\bf img1} ein Histogrammausgleich durchgeführt und 
das Ergebnis im Bild {\bf img2} abgespeichert.
}

\proch{int}{correctShading}{const Image \&img1,const Image \&img2, int ord=2}{shading.h}
\descr{
Es wird eine Shading-Korrektur des Bildes $img1$ durchgeführt und im Bild 
$img2$ abgespeichert. Dazu wird an das Bild eine polynomiale Funktion
angepasst. Die Ordnung des Polynoms wird durch den Parameter $ord$
bestimmt.
}

\proch{int}{correctShading}{const Image \&img1,const Image \&img2, Function2dWithFitting \&fn}{shading.h}
\descr{
Es wird eine Shading-Korrektur des Bildes $img1$ durchgeführt und im Bild 
$img2$ abgespeichert. Dazu wird die Funktion {\bf fn} an das Bild
angepasst.
}

\subsection{Bildarithmetik}
\subsubsection{Integer-Bilder}

Die Funktionen zur Bildarithmetik benötigen im allgemeinen zwei Quellbilder
und ein Zielbild. Bei fehlerfreier Abarbeitung wird der Wert $OK$
zurückgegeben, sonst ein Fehlercode. Die beteiligten Bilder müssen
die gleiche Größe haben.

\label{range}
\hypertarget{range}{}
Überschreitet der Wertebereich des Ergebnisses den Umfang des Zielbildes,
so sind mittels Parameter $mode$ folgende Strategien wählbar:

\begin{itemize}
\item MD\_NORMALIZE \\
Grauwerte werden auf den Bereich des Zielbildes linear transformiert.
\item MD\_LIMIT \\
Grauwerte werden auf den Bereich des Zielbildes begrenzt.
\item MD\_MODULO \\
Grauwerte werden durch Verwendung des Modulo-Operators auf den Bereich 
des Zielbildes begrenzt.
\end{itemize}

\proch{int}{ClearImg}{const Image \&img}{arith.h}
\descr{Alle Bildpunkte werden auf Null gesetzt.
}
\proch{int}{setImg}{const Image \&img,int val}{base.h}
\descr{Alle Bildpunkte werden auf den konstanten Wert $val$ gesetzt.
}
\proch{int}{setImg}{const Image \&img,const Function2d \& fn}{fitfn.h}
\descr{Alle Bildpunkte (x,y) werden auf den Wert der Funktion $fn(x,y)$ 
  gesetzt (\see{Func2D}). Überschreitet der Funktionswert den Bereich 
  [0..img->maxval], so wird der Wert begrenzt.
}
\proc{int}{CopyImg}{const Image \&src,const Image \&dest}
\descr{Das Bild $src$ wird nach $dest$ kopiert.}

\proch{int}{AddImg}{const Image \&img1,const Image \&img2,
  const Image \&dest,int mode=MD\_NORMALIZE}{arith.h}
\descr{
Punktweise Addition der Bilder $img1$ und $img2$:
$$vd=v1+v2$$
\hyperref{range}{}{}{{\bf mode}} steuert die Behandlung von 
Wertebereichsüberschreitungen.
}
\proc{int}{SubImg}{const Image \&img1,const Image \&img2,int smode,const Image \&dest,int mode=MD\_NORMALIZE}
\procf{int}{SubImg}{const Image \&img1,const Image \&img2,const Image \&dest,int smode=SMD\_ABSOLUTE,int mode=MD\_NORMALIZE}
\descr{
Punktweise Subtraktion der Bilder $img1$ und $img2$.

\begin{tabular}{|c|c|} \hline
smode & Wert \\ \hline
SMD\_ABSOLUTE & $vd=\vert v1-v2 \vert$ \\
SMD\_POSITIVE & $vd=max(v1-v2,0)$ \\
SMD\_SHIFT & $vd=v1-v2+max/2$ \\ \hline
\end{tabular}

\hyperref{range}{}{}{{\bf mode}} steuert die Behandlung von 
Wertebereichsüberschreitungen.
}

\proc{int}{MaxImg}{const Image \&img1,const Image \&img2,const Image \&dest,int mode=MD\_NORMALIZE}
\descr{Es wird punktweise das Maximum der Bilder $img1$ und $img2$ gebildet:
$$vd=max(v1,v2)$$
\hyperref{range}{}{}{{\bf mode}} steuert die Behandlung von 
Wertebereichsüberschreitungen.
}
\proc{int}{MinImg}{const Image \&img1,const Image \&img2,const Image \&dest,int mode=MD\_NORMALIZE}
\descr{Es wird punktweise das Maximum der Bilder $img1$ und $img2$ gebildet
$$vd=min(v1,v2)$$
\hyperref{range}{}{}{{\bf mode}} steuert die Behandlung von 
Wertebereichsüberschreitungen.
}
\proc{int}{InvertImg}{const Image \&img, const Image \&dest}
\procf{int}{InvertImg}{const Image \&img}
\descr{Bildinvertierung:
$$vd=(max1-vs)\cdot{maxd \over max1}$$
Bei Aufruf ohne $dest$ wird das Ergebnis in $img$ geschrieben.
}
\proch{int}{RenormImg}{const Image \&img,const Image \&dest}{arith.h}
\descr{
Das Bild $src$ wird auf die Größe und den Grauwertumfang von $dest$
umgerechnet und in $dest$ abgelegt.
}

\subsubsection{Gleitkommabilder}

\proch{int}{ClearImgD}{ImageD img}{darith.h}
\descr{Die Werte des Gleitkommabildes $img$ werden auf 0.0 gesetzt.}
\proc{int}{SetImgD}{ImageD img,double val}
\descr{Alle Bildpunkte werden auf den konstanten Wert $val$ gesetzt.}
\proc{int}{MoveImgD}{ImageD src,ImageD dest}
\descr{Das Bild $src$ wird nach $dest$ transportiert.}
\proc{int}{AddImgD}{ImageD img1,ImageD img2,ImageD dest}
\descr{Punktweise Addition der Bilder $img1$ und $img2$}
\proc{int}{MulImgD}{ImageD img1,ImageD img2,ImageD dest}
\descr{Punktweise Multiplikation der Bilder $img1$ und $img2$}
\proc{int}{LogImgD}{ImageD src,ImageD dest}
\descr{Punktweise Logarithmierung des Bildes $src$}

\subsection{Polar-Darstellung}

\proc{int}{PolarImgD}{ImageD src,ImageD dest,double r1=1,double r2=0,int sym=2}
\procf{int}{PolarImg}{const Image \&src,const Image \&dest,double r1=1,double r2=0,int sym=2}
\descr{
Transformiert das Bild $src$ in die Polar-Darstellung. Dazu werden die
Koordinaten jedes Punktes des Bildes $src$ bezüglich des Mittelpunktes
in die Betrag- und Phasenwinkel-Darstellung (r,phi) umgerechnet und der
Grauwert des jeweiligen Bildpunktes unter den Koordinaten (x=r,y=phi) 
im Bild $dest$ gespeichert.
Die Parameter $r1$ und $r2$ bestimmen den minimalen und den maximalen zu
verwendenden Radius. $r2==0$ veranlasst die Verwendung des maximal
möglichen Radius. 
Der Parameter $sym$ charakterisiert die $sym$-zählige Symmetrie des
Originalbildes (Standard sym=2 z.B. bei Amplituden-Spektren). 
Liegt mit sym>1 eine mehrzählige Rotations-Symmetrie vor, so wird 
in X-Richtung nur ein Winkelbereich von 0..360/sym erfasst.
}

\proc{int}{PolarC}{ImageD src,ImageD dest,double x,double y,double \&r,double \&phi,double r1=1,double r2=0,int sm=2}
\descr{
Berechnet Winkel $phi$ und Radius $r$, der einem bestimmten Koordinatenpaar
($x,y$) im Polarbild $dest$ entspricht. Alle anderen Parameter sind
genauso anzugeben, wie sie zur Erzeugung des Polarbildes verwendet
wurden. 
\seealso{PolarImg}
}
 
\proc{int}{LogPolarImgD}{ImageD src,ImageD dest,double r1=1,double r2=0,int sym=2}
\procf{int}{LogPolarImg}{const Image \&src,
  const Image \&dest,double r1=1,double r2=0,int sym=2}
\descr{
Transformiert das Bild src in die Polar-Darstellung. Dazu werden die
Koordinaten jedes Punktes des Bildes img1 bezüglich des Mittelpunktes
in die Betrag- und Phasenwinkel-Darstellung (r,phi) umgerechnet und der
Grauwert des jeweiligen Bildpunktes unter den Koordinaten (x=r,y=phi) 
im Bild img2 gespeichert.
Die Parameter r1 und r2 bestimmen den minimalen und den maximalen zu
verwendenden Radius. $r2==0$ veranlasst die Verwendung des maximal
möglichen Radius. 
Der Parameter sym charakterisiert die sym-zählige Symmetrie des
Originalbildes (Standard sym=2 z.B. bei Amplituden-Spektren). 
Liegt mit sym>1 eine mehrzählige Rotations-Symmetrie vor, so wird 
in X-Richtung nur ein Winkelbereich von 0..360/sym erfasst.
}

\proc{int}{LogPolarC}{ImageD src,ImageD dest,double x,double y,double \&r,double \&phi,double r1=1,double r2=0,int sym=2}
\descr{
Berechnet Winkel $phi$ und Radius $r$, der einem bestimmten Koordinatenpaar
($x,y$) im Log-Polarbild $dest$ entspricht. Alle anderen Parameter sind
genauso anzugeben, wie sie zur Erzeugung des Log-Polarbildes verwendet
wurden. 
\seealso{LogPolarImg}
}

\subsection{Farbraum-Transformationen}
Bilder der Klasse \class{ColorImage} speichern Farbwerte im RGB-Format.
Neben Funktionen zur Farbraum-Transformation einzelner 
Farbwerte (\see{RgbToHsi}) gibt es Funktionen zur Transformation von 
Bildern. Im Farbraum RGB werden Bilder der Klasse \class{ColorImage} 
verwendet, in anderen Farbräumen werden die einzelnen Komponenten in 
jeweils eigenen Bildern der Klasse \class{Image} abgelegt. Der 
Wertebereich der jeweiligen Farbkomponente wird dabei auf den 
Wertebereich des Bildes gestreckt.

\proch{int}{ColorImageToHsi}{const ColorImage \&src, const Image \&hue, const Image \&saturation, const Image \&intensity}{ColorSpace.h}
\procf{int}{HsiToColorImage}{const Image \&hue, const Image \&saturation, const Image \&intensity, const ColorImage \&dst}
\procf{int}{ColorImageToLab}{const ColorImage \&src,
  const Image \&lImg, const Image \&aImg, const Image \&bImg}
\procf{int}{LabToColorImage}{const Image \&lImg, const Image \&aImg, const Image \&bImg, const ColorImage \&src}
\procf{int}{ColorImageToYuv}{const ColorImage \&src, const Image \&y, const Image \&u, const Image \&v}
\procf{int}{YuvToColorImage}{const Image \&y, const Image \&u, const Image \&v, const ColorImage \&dst}
\descr{Farbraum-Transformation von RGB als \class{ColorImage} in die Farbräume YUV, HSI und Lab und zurück.}

 
\newpage
\makeatletter{}\nsection{Matrix-Algebra}{matrixAlgebra}
\label{Matrix-Algebra}

\subsection{Operationen mit Matrizen, Determinanten}
Zur Lösung von Gleichungssystemen siehe Abschnitt \see{Gleichungssysteme}.

\proc{Matrix}{Inverse}{const Matrix \&m}
\descr{
Berechnet die Inverse der Matrix $m$.
}

\proc{Matrix}{CholeskyInverse}{const Matrix \&m}
\descr{
Berechnet die Inverse der positiv definiten Matrix $m$ mit dem 
Cholesky-Verfahren.
}

\proc{Matrix}{CholeskyDecomposition}{const Matrix \&m}
\descr{Berechnet die Cholesky-Zerlegung $M=L*L^T$ der 
positiv-definiten Matrix $m$. L wird zurückgegeben. 
Falls $m$ nicht positiv-definit ist, wird ein Fehler ausgelöst!
}

\proc{bool}{IsPositivDefinit}{const Matrix \&m}
\descr{Prüft, ob die Matrix $m$ positiv definit ist.
Dies ist sehr zeitaufwendig. Sollen Funktionen wie die Cholesky-Zerlegung zur
Anwendung kommen, die positiv definite Matrizen erfordern, so ist es
effektiver, die entsprechende Funktion ohne vorherigen Test aufzurufen und auf
den Fehler zu reagieren, wenn die Matrix nicht positiv definit ist.
}

\proc{double}{Determinant}{const Matrix \&m}
\descr{
Berechnet die Determinante der Matrix $m$.
}

\proc{double}{CholeskyDeterminant}{const Matrix \&m}
\descr{
Berechnet die Determinante der positiv definiten Matrix $m$.
}

\subsection{Gleichungssysteme}
\label{Gleichungssysteme}

\proc{Vector}{SolveLinEqu}{const Matrix \&M,const Vector \&i}
\descr{
Löst das Gleichungssystem $M \cdot x=i$ und gibt den Lösungsvektor
$x$ zurück. Das Gleichungssystem darf auch überbestimmt sein.
Für die Lösung wird eine LU-Zerlegung der Matrix $M$ angewendet. 
Wenn viele Gleichungssysteme mit gleichem $M$ (und unterschiedlicher
Inhomogenität $i$) zu lösen sind, sollte dies direkt mit der LU-Zerlegung
(\see{LUDecompositionPacked}) realisiert werden.
}
\seealso{Solve2}

\proch{int}{LUDecomposition}{const Matrix \&a,Matrix \&L,Matrix \&U}{ludecomp.h}
\descr{Führt eine LU-Zerlegung der Matrix $a$ durch und gibt eine untere
Dreiecksmatrix L und eine obere Dreiecksmatrix U zurück, so daß gilt:
$a=L \cdot U$. {\it Sollen mittels LU-Zerlegung Gleichungssysteme gelöst
werden, so ist die Variante \see{LUDecompositionPacked} vorzuziehen.}
}

\proc{int}{LUDecompositionPacked}{const Matrix \&a,Matrix \&LU,IVector \&indx,bool pivot=true}
\descr{Führt eine LU-Zerlegung der Matrix $a$ durch und gibt eine untere und 
eine obere Dreiecksmatrix in gepackter Form zurück. Mit $pivot=true$ wird eine
Pivotisierung durchgeführt, der Vector $indx$ enthält dann die Informationen
über die nötigen Vertauschungen. $LU$ und $indx$ enthalten die nötigen
Informationen, um mittels \see{LUSolve} Gleichungssysteme der Form $M \cdot
x=i$ zu lösen.}

\proc{Vector}{LUSolve}{const Matrix \&LU,const IVector \&indx,const Vector
\&i}
\descr{Löst das Gleichungssystem $M \cdot x=i$, nachdem die Matrix $M$ mittels
\see{LUDecompositionPacked} in die Matrix LU überführt wurde. $indx$ ist die
ebenfalls von LUDecompositionPacked gelieferte Information über Vertauschungen
bei der Pivotisierung. 
}

Durch Kombination der Funktionen LUDecompositionPacked und LUSolve ist es
möglich, Gleichungssysteme der Form $M \cdot x=i$ zu lösen. Dies ist besonders 
effektiv, wenn mehrere Gleichungssysteme mit gleicher Matrix $M$ und 
unterschiedlicher Inhomogenität $i$ zu lösen sind:
\begin{verbatim}
/* Lösung linearer Gleichungssysteme mit LU-Zerlegung */

Matrix M=
     Vector(3,2,1) &&
     Vector(1,-2,-1) &&
     Vector(-2,1,1);

Vector i1(1,2,3); // Inhomogenitäten
Vector i2(3,-1,-2);
Vector i3(-1,-1,-1);

Vector x1,x2,x3; // Lösungsvektoren

Matrix LU;
IVector indx;

// LU-Zerlegung mit Pivotisierung
LUDecompPacked(M,LU,ind,true);

// Lösung M*x1=i1
x1 = LUSolve(LU,indx,i1);

// Lösung M*x2=i2
x2 = LUSolve(LU,indx,i2);

// Lösung M*x1=i1
x3 = LUSolve(LU,indx,i2);

\end{verbatim}

\proch{bool}{Solve2}{double a1,double b1,double i1,double a2,double b2,double i2,double \&x1,double \&x2}{numbase.h}
\descr{Es wird das lineare Gleichungssystem 
\[
\begin{array}{c@{+}c@{=}c}
  a_1 \cdot x_1 & b_1 \cdot x_2 & i_1 \\
  a_2 \cdot x_1 & b_2 \cdot x_2 & i_2 \\
\end{array}
\]
gelöst.}
\seealso{SolveLinEqu}

Die folgenden Funktionen sind überholt und sollten nicht mehr genutzt werden:

\proc{int}{EquationSys}{MatrixStruct A,double *b,double *x}
\descr{
Es wird der Lösungsvektor $x$ des linearen Gleichungssystems $A x = b$
bestimmt. $A$ muß eine quadratische Matrix sein.
}

\proc{int}{NormalEquationSys}{MatrixStruct A,double *b,double *x}
\descr{
Für das überbestimmte lineare Gleichungssystem $A x = b$ wird ein
Lösungsvektor $x$ im Sinne der kleinsten Quadrate bestimmt, so 
daß $\Vert Ax-b \Vert \to Min.$ gilt. Die Anzahl der Zeilen der 
Matrix $A$ muß mindestens so groß wie die Anzahl der Spalten sein.
}

\proc{int}{NonLinEquSys}{FuncD *func,int dim,int *step,double *mse,double *x}
\descr{
Es wird die Lösung eines nichtlinearen Gleichungssystems der Form $func(x)=0$
mit dem Verfahren von Newton-Raphson bestimmt. $func$ ist ein Feld von
Funktionspointern mit dem Typ $FuncD$. Auf $x$ muß eine geeignete
Anfangslösung bereitgestellt werden. $step$ gibt beim Aufruf die maximale
Anzahl von Iterationsschritten an und nach der Abarbeitung die Anzahl der
tatsächlich ausgeführten Iterationen. $mse$ gibt beim Funktionsaufruf eine
obere Schranke für den mittleren quadratischen Fehler als Abbruchkriterium an
und nach der Abarbeitung den tatsächlich erreichten Wert. Die Verwendung der
Funktion soll mit dem folgenden Beispiel demonstriert werden:
}
\begin{verbatim}
/* Lösung nichtlinearer Gleichungssysteme */
#include <stdio.h>
#include <math.h>
#include <image.h>
/* Funktionsdefinitionen */
double func1 (double *ptrd)
{ return ( -0.5*Sqr(ptrd[0]) + Sqr(ptrd[1])-sin(ptrd[0]) );}
double func2 (double *ptrd)
{ return ( -0.7*Cub(ptrd[1]) - ptrd[0] -10 );}

void main(void)
{
  FuncD f[2]={&func1,&func2};                /* Funktionenvektor */
  double sol[2]={ 1.0, 1.0 };                /* Startlösung */
  double eps=1e-20;                          /* Abbruchkriterium */
  int step=100;
  NonLinEquSys (f,2,&step,&eps,sol);
  printf("step   PrintVecRn("sol",sol,2);
}
\end{verbatim}
\seealso{LMDif}

\subsection{Eigenwerte, Zerlegungen}

\proch{int}{Eigenvalue}{const Matrix \&a,Vector \&eval,Matrix \&evect}{mateigen.h}
\procf{int}{Eigenvalue}{const Matrix \&a,Matrix \&eval,Matrix \&evect}
\descr{Berechnet die Eigenwerte der Matrix $a$ und speichert diese im Vektor 
$eval$. Die Spalten der Matrix $evect$ enthalten die zugehörigen Eigenvektoren.
Alternativ können die Eigenwerte auch als Diagonalmatrix abgelegt werden.
}

\proch{int}{Eigenvalue}{double a,double b,double c,
  double \&lambda1,double \&lambda2,Point \&eigen1,Point \&eigen2}{mateigen.h}
\descr{Diese spezielle Variante von \bsee{Eigenvalue} berechnet die Eigenwerte 
$lambda1$ und $lambda2$ und die Eigenvektoren $eigen1$ und $eigen2$ der Matrix 
\[ m = \left( \begin{array}{cc}
a & b \\
b & c \\
\end{array} \right) \]
}

\proc{int}{SingularValueDcmp}{const Matrix \&A,Matrix \&U,Matrix \&S,Matrix \&V}
\procf{int}{SingularValueDcmp}{const Matrix \&A,Matrix \&U,Vector \&S,Matrix \&V}
\descr{
Für die Matrix $A$ wird die Singulärwertzerlegung $A=USV^T$ mit der 
Diagonalmatrix $S$ der Singulärwerte berechnet. Alternativ können die
Singulärwerte auch als Vector abgelegt werden. Die Anzahl der Zeilen 
der Matrix $A$ muß größer oder gleich der Anzahl der Spalten sein,
anderenfalls ist sie mit Null-Zeilen zu einer quadratischen Matrix 
aufzufüllen.}

\proch{int}{QRDecomposition}{const Matrix \&A,Matrix \&Q,Matrix \&R}{qrdecomp.h}
\descr{Führt eine QR-Zerlegung der Matrix $M = Q \cdot R$ durch, wobei $Q$ 
eine orthogonale Matrix und $R$ eine obere Dreiecksmatrix $R$ sind.}

\seealso{LUDecomposition}

Die folgenden Funktionen mit Matrizen des Types \see{MatrixStruct} sind
überholt und sollten nicht mehr benutzt werden.

\proc{MatrixStruct}{Mateigen}{MatrixStruct A,double *eval,MatrixStruct evect}
\descr{
Für eine symmetrische Matrix $A$ werden die Eigenwerte und die normierten 
Eigenvektoren mit dem Jacobi-Verfahren berechnet. Die Eigenwerte werden 
sortiert, beginnend mit dem größten Eigenwert, auf dem Vektor $eval$ 
zurückgegeben. Die zugehörigen Eigenvektoren sind die Spaltenvektoren der 
Matrix $evect$. Wenn für $evect$ der NULL-Pointer übergeben wird, wird die 
Matrix intern angelegt.
}

\proc{int}{SingularValueDcmp}{MatrixStruct A,MatrixStruct *U,MatrixStruct *S,MatrixStruct *V}
\descr{
Für die Matrix $A$ wird die Singulärwertzerlegung $A=USV^T$ mit der 
Diagonalmatrix $S$ der Singulärwerte berechnet. Die Anzahl der Zeilen 
der Matrix $A$ muß größer oder gleich der Anzahl der Spalten sein,
anderenfalls ist sie mit Null-Zeilen zu einer quadratischen Matrix 
aufzufüllen. Für $U$, $S$ und $V$ können
NULL-Pointer übergeben werden, die Matrizen werden dann intern angelegt.
}

\subsection{Optimierung}
\proch{int}{LinearOptimization}{int rows,int columns,double **matrix,double
*rside,double *costfunction,double *solution,double \&costs}{simplex.h}
\descr{
Für die lineare Optimierungsaufgabe  $matrix \cdot solution \leq rside$ und
$costfunction \cdot solution \rightarrow minimum$ werden mittels der 
Simplexmethode die Lösung $solution$ und die minimalen Kosten $costs$ 
berechnet. 
Die Matrix $matrix$ hat $rows$ Zeilen und $columns$ Spalten. Die Spaltenanzahl 
ist gleich der Anzahl der Variablen.
Der Rückkehrkode der Funktion  bestimmt den Typ der Lösung:
\begin{itemize}
\item $rc=0:$ - Lösung o.k.
\item $rc=1:$ - Unbeschränkter zulässiger Bereich
\item $rc=2:$ - Leerer zulässiger Bereich
\end{itemize}
}

\proch{int}{LMDif}{Vector \&variable,int optnumber,LMFunc *func,int funcdim,int
  \&inumber,int maxiter=MAX\_INT}{lmdif.h}
\procf{int}{LMDif}{Vector \&variable,int optnumber,LMFunc *func,int funcdim}
\procf{int}{LMDif}{Vector \&variable,IVector optvar,
  LMFunc *func,int funcdim,int \&inumber,int maxiter=MAX\_INT}
\procf{int}{LMDif}{Vector \&variable,IVector optvar,LMFunc *func,int funcdim}
\descr{
Mittels der Levenberg-Marquardt-Methode wird der euklidische Betrag der 
vektoriellen Zielfunktion $func$ minimiert. 
Die Funktion $func$ muß vom Typ $LMFunc$ sein, der wie folgt definiert ist:\\
typedef int LMFunc(const Vector \&funcvar,Vector \&result);\\
Der Vektor $funcvar$ stellt die Parameter der Funktion dar, $result$ ist der
Ergebnisvektor. Der Ergebnisvektor muß die Dimension $funcdim$ besitzen.\\
Mittels $variable$ wird LMDif eine Startlösung und weitere notwendige
Parameter der Funktion $func$ übergeben. In diesem Parametervektor optimiert
der Levenberg-Marquardt-Algorithmus 
\begin{itemize}
\item Die ersten $optnumber$ Parameter oder
\item die Parameter, deren Index im Integer-Vektor $optvar$ aufgeführt ist.
\end{itemize}
Die Zahl der zu optimierenden Parameter darf die Dimension $funcdim$ der
Zielfunktion $func$ nicht übersteigen.\\
 Der Parameter $maxiter$ beschränkt die Iteration auf $maxiter$ Zyklen.
Der Parameter $inumber$ gibt die tatsächlich ausgeführte Zahl von 
Iterationen zurück.\\
Der Rückgabewert gibt den Grund für die Beendigung der Optimierung zurück. Die
Werte außer ERROR stellen keinen ICE-Fehler dar. Insbesondere die Werte 1 bis
4 stellen in der Regel eine erfolgreiche Beendigung dar.
\begin{tabular}{ll}
{\bf Rückgabewert}&{\bf Grund des Abbruchs}\\
ERROR & Rückgabewert im Fehlerfall, z.B. Parameterfehler \\
1 & both actual and predicted relative reductions in the sum of squares
  are at most ftol.\\
2 & relative error between two consecutive iterates is at most xtol.\\
3 & conditions for 1 and 2 both hold.\\
4 & the cosine of the angle between fvec and any column of the jacobian
  is at most gtol in absolute value.\\
5 & number of calls to fcn has reached or exceeded maxfev.\\
6 & ftol is too small. no further reduction in the sum of squares 
  is possible.\\
7 & xtol is too small. no further improvement in the approximate 
  solution x is possible.\\
8 & gtol is too small. fvec is orthogonal to the columns of the 
  jacobian to machine precision.\\
\end{tabular}
}

\proc{int}{LMDif}{const \vector{double*} \&ov,const LMFunctor \&fn,
  int maxiter=MAX\_INT}
\descr{Mittels der Levenberg-Marquardt-Methode wird der euklidische Betrag
  einer vektoriellen Zielfunktion minimiert. Die Zielfunktion ist gegeben
  durch den Operator() des Objektes fn. Der \vector{double*} ov von Zeigern auf
  double-Werte verweist auf die zu optimierenden Parameter der Zielfunktion.
  Der Parameter $maxiter$ beschränkt die Iteration auf $maxiter$ Zyklen.
}

$fn$ ist ein Objekt einer von $LMFunctor$ abgeleiteten Klasse. $LMFunctor$
ist wie folgt als abstracte Klasse definiert:
\begin{verbatim}
  class LMFunctor {
  public:
    virtual int operator()(Vector \&result) const = NULL;
    virtual int funcdim() const = NULL;
  };
\end{verbatim}
Der Konstruktor der abgeleiteten Klasse ist zu nutzen, um alle für die
Zielfunktion erforderlichen Parameter zu übergeben, was oft sinnvollerweise
über eine Referenz erfolgt. Dazu gehören auch die
Datenstrukturen, die die zu optimierenden Parameter enthalten. Die Funktion
$funcdim$ muß die Dimensionalität der Fehlerfunktion zurückgeben. Dieser Wert
dient vor allem dazu, den Ergebnis-Vektor der Fehlerfunktion
bereitszustellen. Der überladenen Operator () wird von der Optimierung
aufgerufen, um die Fehlerfunktion zu ermitteln. Dabei wird ein Vector
geeigneter Größe übergeben, den die Operator-Methode belegen muß.

Das folgende Beispielprogramm demonstriert die Verwendung von LMDif anhand
einer Anpassung einer linearen Funktion an Stützstellen unter Minimierung der
quadratische Fehlersumme.

\begin{verbatim}
class LinReg:public LMFunctor
{
private:
// Referenzen auf die dem Konstruktor übergebenen Parameter
  const Vector &x; // Referenz-Paare (Argument x,Funktionswert y)
  const Vector &y;
  Vector &fpara; // Parameter der linearen Funktion
public:
  // Konstruktor
  // übernimmt (als Referenz) die zu optimierenden
  // Parameter der linearen Funktion und die Referenz-Liste
  LinReg(Vector &pp,const Vector &xp,const Vector &yp):
    x(xp),y(yp),fpara(pp) { } ;
  // Dimension der Fehlerfunktion
  int funcdim() const {
    return y.size();    // Ein Fehlerwert pro Funktionswert
  }
  // Fehler-Funktion
  int operator () (Vector &result) const
    {
      int i;
      for (i=0; i<x.size(); i++) // für jeden Funktionswert
        result[i]=fpara[1]*x[i]+fpara[0] - y[i];
      return 1;
    }
};

int LinearRegression()
{
  int info;
  int inumber=10000;
  int i;

  Vector x(1.0,5.0,9.0);// Die Stützstellen
  Vector y(3.0,4.0,5.0);

  Vector n(2); // Parameter der linearen Funktion

  vector<double*> op(2); // Pointer auf zu optimierende Parameter
  op[0]=&n[0];
  op[1]=&n[1];

  info=LMDif(op,        // Liste von Zeigern auf zu optimierende Parameter
             LinReg(n,x,y), // Konstruktion des Funktors
             1000,      // maximale Zahl der Iterationsschritte
             inumber);  // Rückgabe der durchgeführten Iterationsschritte

  cout << "Nach " << inumber << " Iterationen: " << endl;
  cout << "Funktion: y= " << n[1] << "*x + " << n[0] << endl;
  return OK;
}

\end{verbatim}

 
\newpage
\makeatletter{}\nsection{Segmentierung}{segmentation}
\subsection{Wasserscheidentransformation (WST)}

Die Idee der Wasserscheidentransformation ist recht einfach: Ein Grauwertbild
wird als topographisches Relief interpretiert und jeder Punkt dieses
digitalen Bildes einem regionalen Minimum zugewiesen.
Dazu wird ein Flutungsprozess simuliert, bei dem Wasser aus den
regionalen Minima str\"omt und damit die Becken (Minima) füllt.
Punkte werden einem Minimum zugeordnet, indem sie mit der entsprechenden 
Staubeckennummer markiert werden.

Es werden durch den steigenden Wasserstand Einflusszonen der Minima
berechnet. Treffen zwei Becken aufeinander, werden die Punkte an den 
Ber\"uhrungsstellen speziell als D\"amme markiert. Diese D\"amme sind 
die Wasserscheidenlinien, die m\"ogliche Objektgrenzen darstellen.

Um in konstanter Zeit auf die Pixel einer H\"ohenstufe zugreifen zu 
k\"onnen, werden die Bildpixel ihrem Grauwert entsprechend in ein Array 
von FIFO-Schlangen einsortiert. Die Gr\"o\ss e des Array ist durch die 
Anzahl der unterschiedlichen Grauwerte im Bild bestimmt.

Die Anwendung der Wasserscheidentransformation resultiert oft in starker
\"Ubersegmentierung. Diese kann durch Vorverarbeitungsmaßnahmen gemindert 
werden. Um die \"Ubersegmentierung nachtr\"aglich zu reduzieren, k\"onnen 
die Regionen nach bestimmten Kriterien verschmolzen werden.

Wenn Objekte mit homogenen Grauwerten segmentiert werden sollen, wird die
Wasserscheidentransformation auf das Gradientenbild angewendet. F\"ur die
Segmentierung von texturierten Objekten eignet sich dieses Vorgehen nicht.

\subsection{WST-Algorithmen und Hilfsfunktionen}

\proch{int}{WST}{Image in, Image WSImg, int mode=1}{WaterShed.h}
\descr{Anwendung der Wasserscheidentransformation auf Bild $in$. Im Bild
$WSImg$ werden die Minima und ihre Einzugsgebiete numeriert.
$mode = 1$ : Flutungsansatz, neue Minima in h\"oheren Grauwertleveln zulassen}

5 Schritte bei $mode=1$:
\begin{quote}
\begin{tabular}{ll}
1.&     Sortieren der Grauwertpixel nach H\"ohenstufen.\\
2.&     Punkte, die sich an Regionengrenzen befinden, in FIFO-Schlange aufnehmen.\\
3.&     Diese Punkte als Wasserscheide markieren oder einem Becken zuordnen.\\
4.&     Isoliert liegende Punkte als neue Regionen markieren.\\
5.&     N\"achstes Grauwertlevel verarbeiten und Schritt 2 ausf\"uhren, bis Grauwert-Maximum erreicht ist.\\
\end{tabular}
\end{quote}




\proch{void}{GraphIter}{Image Original, Image WSImg, Image \&GrwImg, int Threshold}{WaterShed.h}
\descr{Originalbild $Original$, Ergebnisbild der Wasserscheidentransformation $WSImg$ und das R\"uckgabebild
$GrwImg$ \"ubergeben. Der Parameter $Threshold$ steuert die Verschmelzung der Regionen. Es werden
nur Regionen vereinigt, bei denen die Differenz der durchschnittlichen Grauwerte gr\"o\ss er als $Threshold$ ist.}

Eine vollst\"andige Grapheniteration durchf\"uhren:
\begin{quote}
\begin{tabular}{ll}
1.&     Regionengraph berechnen.\\
2.&     In Kantengraph transformieren.\\
3.&     WST auf Kantengraph ausf\"uhren.\\
4.&     Kantengraph in Regionenbild \"uberf\"uhren.\\
\end{tabular}
\end{quote}























\subsection{Regionenwachstum}

\proch{Region}{RegionGrow}{int x,int y,const Image \&orig,int maxsize=INT\_MAX,int refvalue=-1}{segment1.h}
\procf{int}{RegionGrow}{int x,int y,const Image \&orig,Image \&mark,int val=1,int maxsize=INT\_MAX,int refvalue=-1}
\descr{Ermittelt durch Regionenwachstum auf dem Bild $orig$ eine Region mit 
  maximal $maxSize$ Pixeln um den Punkt (x,y). Das Regionenwachstum erfolgt 
durch Hinzufügen des ``ähnlichsten'' Punktes. Der ``ähnlichste'' Punkt ist 
der Punkt, der die geringste Wert-Abweichung vom Startpunkt zeigt, 
beziehungsweise die geringste Abweichung vom übergebenen Referenzwert 
$refvalue$, wenn dieser nicht negativ ist. Durch Angabe von 0 oder 
orig.maxval kann RegionGrow zur Ermittlung von Minima- oder 
Maxima-Regionen genutzt werden. Abbruchbedingung ist das
  Maximum der Differenz des mittleren Grauwertes der Region zu den 
  benachbarten Punkten. Die zweite Aufruf-Form zeichnet die Region mit dem
  Wert $val$ in das Bild $mark$ ein.}

\proch{Region}{RegionGrowGrw}{int x,int y,const Image \&orig,double stdmax=3.0,int maxSize=INT\_MAX}{segment1.h}
\procf{int}{RegionGrowGrw}{int x,int y,const Image \&orig,Image \&mark,int
  val=1,double stdmax=3.0,int maxSize=INT\_MAX}
\descr{Ermittelt durch Regionenwachstum eine Region mit maximal $maxSize$
  Pixeln um den Punkt (x,y). Das Wachstum wird abgebrochen, wenn die
  Standardabweichung der Grauwerte der Region den Wert $stdmax$ übersteigt.
  Die zweite Aufruf-Form zeichnet die Region mit dem Wert $val$ in das Bild $mark$ ein.}

 
\newpage
\makeatletter{}\nsection{Fitting}{fitting}

Zusätzlich zu den hier vorgestellten Wegen kann das Fitting von Funktionen
auch durch Verwendung der Klassen der Hierarchie ein- und zweidimensionaler
Funktionen erfolgen (\see{Funktionen}).

\subsection{Fitting mehrdimensionaler linearer Funktionen}
\label{GaussFit}
\hypertarget{GaussFit}{}

Die Klasse $GaussFit$ stellt die Mittel zum Bestimmen der Koeffizienten $a_i$ 
einer Funktion der Form $F(x_1,x_2,..x_i) = \sum_{i=0}^n a_i \cdot x_i$ 
zur Verfügung.

\seealso{Funktionen}

Konstruktoren:
\proch{}{GaussFit::GaussFit}{int n=0}{fitgauss.h}
\descr{Legt einen Fit-Bereich mit der Dimension $n$ an.
Wird die Dimension $n$ mit 0 angegeben, so muss diese 
durch Aufruf von \see{GaussFit::Init} vor der Benutzung der
Instanz noch festgelegt werden.}

Methoden:

\proch{void}{GaussFit::Init}{int n=0}{fitgauss.h}
\descr{Initialisiert einen (neuen) Fit-Prozess. Ein Wert von $n$ ungleich
Null legt eine (neue) Dimension der Funktion fest. Diese Funktion muss
aufgerufen werden, wenn die Dimension im Konstruktor nicht festgelegt wurde
oder wenn nach einer Verwendung ein neuer Fitprozess initialisiert werden 
soll.}

\proch{void}{GaussFit::Value}{const \bsee{Vector} \&x,double y,double w=1.0}{fitgauss.h}
\procf{void}{GaussFit::Value}{\vector{double} \&x,double y,double w=1.0}
\descr{Übergibt einen Wert für das Fitting. Der Vektor $x$ enthält die x-Werte
  $x_i$, $y$ den zugehörigen Funktionswert. Mit $w$ kann ein Gewicht
  festgelegt werden.}

\proch{void}{Gaussfit::Finish}{}{fitgauss.h}
\descr{Schließt das Fitting ab. Muss vor der Abfrage des Resultats
aufgerufen werden. Nach dem Abschluss kann das Fitting durch Eingabe weiterer
Werte fortgesetzt werden, dann muss auch noch einmal {\bf Finish} 
aufgerufen werden.}

\proch{void}{GaussFit::Fit}{const \bsee{Matrix} \&xn,const \bsee{Vector} \&yn}{fitgauss.h}
\descr{Fitted eine Funktion an eine Liste von Werten.
Die Matrix $xn$ enthält zeilenweise x-Vektoren, der Vektor $yn$ die 
zugehörigen y-Werte. Dieser Aufruf erledigt den vollständigen Fitting-Prozess
mit {\bf Init}, {\bf Value} und {\bf Finish}.}

\proch{void}{GaussFit::getResult}{Vector \&v}{fitgauss.h}
\procf{void}{GaussFit::getResult}{\vector{double} \&v}
\descr{Schreibt die Koeffizienten $a_i$ des Ergebnisses auf v[i].}

\proch{double}{GaussFit::Variance}{}{fitgauss.h}
\descr{Gibt die Varianz der Funktionswerte zurück.}

\subsection{Adaptives Fitting geometrischer Elemente}
\label{Adaptives Fitting}

Bei den hier betrachteten Fittung-Funktionen werden geometrische
(Linien-)Objekte an eine gegebene Punktmenge angepasst. Die Punktmenge wird
als \vector{Point} oder als \class{Matrix} übergeben.

Wird die Punktmenge als \vector{Point} übergeben, so kann als zusätzlicher 
Parameter ein \vector{double} übergeben werden, der für jeden Punkt 
ein Gewicht festlegt. Fehlt dieser Parameter, werden alle Punkte gleich gewichtet.

Wird die Punktmenge als \class{Matrix} übergeben, so müssen die ersten 
beiden Spalten der Matrix die Koordinaten x und y der Punkte enthalten. 
Ist eine dritte Spalte vorhanden, wird diese als Gewicht des jeweiligen 
Punktes interpretiert, sonst werden 
alle Punkte gleich gewichtet. Alle weiteren Spalten werden ignoriert.

Die Struktur \class{PointList} ist veraltet und sollte nicht mehr 
verwendet werden. 

Soll die Anpassung an eine Kontur erfolgen, so kann diese einfach mittels 
\bsee{ConturPointlist} gewandelt werden, zum Beispiel:
\begin{verbatim}
Contur c=...;
Circle c=FitCircle(ConturPointlist(c));
...
\end{verbatim}

\subsubsection{Gerade}
An eine Punktmenge wird eine Gerade angepaßt. Die Punktmenge kann als
\verb+vector<Point>+ oder als Matrix vorgegeben sein (\see{Adaptives Fitting}).

Es ist möglich eine Anzahl $step$ adaptiver Iterationsschritte vorzugeben.
Bei den weiteren Iterationsschritten werden die Punkte, die weiter von der im 
vorhergehenden Schritt angepaßten Geraden entfernt liegen, mit einem 
geringeren Gewicht versehen.

\proch{LineSeg}{FitLine}{const \vector{Point} \&pl}{fit.h}
\procf{LineSeg}{FitLine}{const \vector{Point} \&pl,int step}
\procf{LineSeg}{FitLine}{const \vector{Point} \&pl,const \vector{double} \&weight}
\procf{LineSeg}{FitLine}{const \vector{Point} \&pl,\vector{double} \&weight,int step}
\procf{LineSeg}{FitLine}{const Matrix \&pl,int step=0}
\descr{Die gefundene Gerade wird als Instanz der Klasse \class{LineSeg} 
zurückgegeben.
}

\proc{int}{FitLine}{const Matrix \&pl,double \&r,double \&phi,int step=0}
\descr{Die Parameter $r$ und $phi$ der Hesseschen Normalform der gefundenen 
  Gerade werden zurückgegeben. 
  $x \cdot \cos(\phi) + y \cdot sin(\phi) = r$
}

\proc{int}{FitLine}{const Matrix \&m,double par[2],int step=0}
\descr{Die Parameter der Hesseschen Normalform der gefundenen Gerade werden im 
  Array $par$ (2 Elemente) zurückgegeben.
  $x \cdot \cos(par[1]) + y \cdot sin(par[1]) = par[0]$
}

\proch{int}{FitLine}{PointList pl,int a1,int a2,int step,double par[2],double *mdist,int *madr}{fit\_pointlist.h}
\descr{
An die in einer Punktliste $pl$ zwischen $a1$ und $a2$ angegebenen Punkte wird 
adaptiv eine Gerade angepaßt. Die Anzahl der Adaptionsschritte ist mit $step$ 
vorzugeben. In der Adaption werden Punkte, die weiter von der im vorhergenden 
Schritt angepaßten Geraden entfernt liegen, mit einem geringeren Gewicht 
versehen. Es werden die Parameter der Hesseschen Normalform 
$x \cdot \cos(par[1]) + y \cdot sin(par[1]) = par[0]$, der Abstand $mdist$ 
des am weitesten entfernt liegenden Punktes sowie dessen Adresse $madr$ in
der Punktliste bereitgestellt. 
}

\proc{int}{FitLineLinOpt}{PointList pl,int a1,int a2,int step,double
par[2],double limit=1000000} 
\descr{
An die in einer Punktliste $pl$ zwischen $a1$ und $a2$ mit der Schrittweite
$step$  angegebenen Punkte wird
mit den Gewichten der Punktliste eine
Gerade angepaßt. Die gewichtete Ausgleichsrechnung wird mittels linearer
Optimierung durchgeführt (Simplexmethode),d.h. es wird nicht die Summe der
Quadrate der Defekte minimiert sondern die Summe der Beträge der Defekte. Der
Parameter limit (Standard:1000000) wird in einer zusätzlichen
Beschränkungsrelation zur linearer Optimierung benutzt. Es ist
möglich, daß dieser Parameter gegebenenfalls vergrößert werden muß. Es werden die
Parameter der Hesseschen Normalform $x \cdot \cos(par[1]) + y \cdot
sin(par[1]) = par[0]$ der Geraden bereitgestellt. 
}

\subsubsection{Kreis}
An eine Punktmenge wird ein Kreis angepaßt. Die Punktmenge kann als
\verb+vector<Point>+ oder als Matrix vorgegeben sein (\see{Adaptives Fitting}).
Es ist möglich eine Anzahl $step$ adaptiver Iterationsschritte vorzugeben. 
Dabei werden Punkte, die weiter von dem im vorhergehenden Schritt angepassten 
Kreis entfernt liegen, mit einem geringeren Gewicht versehen.

\proch{Circle}{FitCircle}{const \vector{Point} \&pl}{fit.h}
\procf{Circle}{FitCircle}{const \vector{Point} \&pl,const \vector{double} \&weight}
\procf{Circle}{FitCircle}{const \vector{Point} \&pl,int step}
\procf{Circle}{FitCircle}{const \vector{Point} \&pl,\vector{double} \&weight,int step}
\proc{Circle}{FitCircle}{const Matrix \&pl,int step=0}
\descr{Der gefundene Kreis wird als Datenstruktur \see{Circle} zurückgegeben. 
}

\proch{int}{FitCircle}{const Matrix \&pl,double \&xm,double \&ym,double \&rad,int step=0}{fit.h}
\descr{Der Mittelpunkt $(xm,ym)$ und der Radius $rad$ des gefundenen Kreises werden 
  zurückgegeben.}

\proc{int}{FitCircle}{const Matrix \&pl,double par[3],int step=0}
\descr{Der Mittelpunkt (xm,ym) und der Radius rad des gefundenen Kreises werden 
  im Array $par$ zurückgegeben (3 Elemente). }

\proc{int}{FitCircle}{PointList pl,int a1,int a2,int step,double par[3],double *mdist,int *madr} 
\descr{
An die in einer Punktliste $pl$ zwischen $a1$ und $a2$ angegebenen Punkte wird
adaptiv ein Kreis angepaßt. In der Adaption werden Punkte, die weiter von dem
im vorhergenden Schritt angepaßten Kreis entfernt liegen, mit einem geringeren
Gewicht versehen. Es wird der Mittelpunkt $(par[0],par[1])$, der Radius des Kreises $par[2]$,
der Abstand $mdist$ des am weitesten entfernt liegenden Punktes sowie dessen
Adresse $madr$ in der Punktliste bereitgestellt.
}

\proc{int}{FitCircleLinOpt}{PointList pl,int a1,int a2,int step,double
par[3],double limit=1000000} 
\descr{
An die in einer Punktliste $pl$ zwischen $a1$ und $a2$ mit der Schrittweite
$step$ angegebenen Punkte wird mit den Gewichten der Punktliste
ein Kreis angepaßt. Die gewichtete Ausgleichsrechnung wird mittels linearer
Optimierung durchgeführt (Simplexmethode), d.h. es wird nicht die Summe der
Quadrate der Defekte minimiert sondern die Summe der Beträge der Defekte.  Der
Parameter limit (Standard:1000000) wird in einer
zusätzlichen Beschränkungsrelation zur linearer Optimierung benutzt. Es ist
möglich, daß dieser Parameter gegebenenfalls vergrößert werden muß. Es
werden der Mittelpunkt $(par[0],par[1])$ und der Radius des Kreises $par[2]$
bereitgestellt. Falls der Rückkehrkode nicht
Null ist, konnte kein Kreis angepasst werden.
}

\subsubsection{Ellipse}
An eine Punktmenge wird eine Ellipse angepaßt.  Die Punktmenge kann als
\verb+vector<Point>+ oder als Matrix vorgegeben sein (\see{Adaptives Fitting}).

Es werden die Quadrate der algebraischen Distanzen 
$distance = a \cdot x^2 + b \cdot x^2 + c \cdot y^2+d \cdot x + e \cdot y + f$ 
minimiert. 

Bei der Default-Methode ($mode=1$) wird die Restriktion $ a^2+b^2+c^2+d^2+e^2+f^2=1$ 
bei der Minimierung verwendet. 

Alternativ ($mode=2$) wird als Restriktion $a + c = 1$ verwendet. In diesem 
Falle ist das Fitting einer Ellipse kovariant bezüglich 
Ähnlichkeitstransformationen, d.h. transformiert man die Punktmengen, 
so sind die beiden gefitteten Ellipsen auch die Abbilder voneinander 
bezüglich der verwendeten Ähnlichkeitstransformation.

Es ist möglich eine Anzahl $step$ adaptiver Iterationsschritte vorzugeben. 
Dabei werden Punkte, die weiter von der im vorhergenden Schritt angepaßten 
Ellipse entfernt liegen, mit einem geringeren Gewicht versehen.

\proch{Ellipse}{FitEllipse}{const Matrix \&pl,int step=0,int mode=1}{fit.h}
\descr{Die gefundene Ellipse wird als Datenstruktur \see{Ellipse} zurückgegeben. }

\proch{int}{FitEllipse}{const Matrix \&pl,double par[5],int step=0,int mode=1}{fit.h}
\descr{Die Parameter Mittelpunkt $(par[0],par[1])$,
  die Halbachsen $par[2]$und $par[3]$, der Drehwinkel $par[4]$ der 
  gefundenen Ellipse werden im Array $par$ zurückgegeben. 
}

\proc{int}{FitEllipse}{PointList pl,int a1,int a2,int step,double
par[5],double *mdist,int *madr,int mode=1}
\descr{
An die in einer Punktliste $pl$ zwischen $a1$ und $a2$ angegebenen Punkte wird
adaptiv eine Ellipse angepaßt. In der Adaption werden Punkte, die weiter von 
der im vorhergenden Schritt angepaßten Ellipse entfernt liegen, mit einem 
geringeren Gewicht versehen. Es wird der Mittelpunkt $(par[0],par[1])$, 
die Halbachsen $par[2]$und $par[3]$, der Drehwinkel $par[4]$, 
der Abstand $mdist$ des am weitesten entfernt liegenden Punktes sowie 
dessen Index $madr$ in der Punktliste bereitgestellt.}

\proc{int}{FitEllipseLinOpt}{PointList pl,int a1,int a2,int step,double
par[5],double limit}
\descr{
An die in einer Punktliste $pl$ zwischen $a1$ und $a2$ mit der Schrittweite
$step$  angegebenen Punkte wird
eine Ellipse angepaßt. Die gewichtete Ausgleichsrechnung wird mittels linearer
Optimierung durchgeführt (Simplexmethode), d.h. es wird nicht die Summe der
Quadrate der Defekte minimiert sondern die Summe der Beträge der Defekte.  Der
Parameter limit (Standard:1000000) wird in einer
zusätzlichen Beschränkungsrelation zur linearer Optimierung benutzt. Es ist
möglich, daß dieser Parameter gegebenenfalls vergrößert werden muß. Es werden der Mittelpunkt $(par[0],par[1])$, die Halbachsen
$par[2]$und $par[3]$ und der Drehwinkel $par[4]$ der Ellipse
bereitgestellt. Falls der Rückkehrkode nicht 
OK ist, konnte keine Ellipse angepasst werden. 
}


\subsubsection{Segmente}

Für die Beschreibung von Geraden-, Kreis- und Ellipsensegmenten wird die
Datenstruktur $Segment$ verwendet, die den Aufbau von verketteten Listen
erlaubt.
\begprogr\begin{verbatim}
typedef struct Segment_
{
  double          p0[2],p1[2];     /*Anfangs- und Endpunkt*/
  int             typ;             /*Segmenttyp: 1 - Geradensegment*/
                                   /*            2 - Kreissegment*/
                                   /*            3 - Ellipsensegment*/
  double          par[7];          /*Geradensegment: p,phi*/
                                   /*Kreissegment:   xm,ym,r,psi1,psi2*/
                                   /*Ellipsensegment:xm,ym,a,b,phi,psi1,psi2*/
  struct Segment_ *prev,*next;     /*Listenverkettung*/
}*Segment;
\end{verbatim}\endprogr

\proc{Segment}{FitLineSegment}{PointList pl,int a1,int a2,int step,double *mdist,int *madr}
\descr{An die in der Punktliste $pl$ von Adresse $a1$ bis Adresse $a2$
abgelegten Punkte wird ein Geradensegment angepaßt. Der Punkt mit dem größten
Abstand $mdist$ zu dem Geradensegment hat die Adresse $madr$.}
\proc{Segment}{FitCircleSegment}{PointList pl,int a1,int a2,int step,double *mdist,int *madr}
\descr{An die in der Punktliste $pl$ von Adresse $a1$ bis Adresse $a2$
abgelegten Punkte wird ein Kreissegment angepaßt. Der Punkt mit dem größten
Abstand $mdist$ zu dem Kreissegment hat die Adresse $madr$.}
\proc{Segment}{FitEllipseSegment}{PointList pl,int a1,int a2,int step,double *mdist,int *madr}
\descr{An die in der Punktliste $pl$ von Adresse $a1$ bis Adresse $a2$
abgelegten Punkte wird ein Ellipsensegment angepaßt. Der Punkt mit dem größten
Abstand $mdist$ zu dem Ellipsensegment hat die Adresse $madr$.}


\subsection{Kontursegmentierung}
\proc{Segment}{LineSegContur}{Contur c,int mlng,double mdist}
\descr{
Die Kontur $c$ wird in Geradensegmente zerlegt. Die Mindestanzahl der zu einem
Segment gehörenden Punkte wird durch $mlng$ festgelegt, $mdist$ gibt den
maximal zulässigen Abstand eines Konturpunktes zu dem nächstliegenden
Geradensegment an. Rückgabewert ist das erste Element einer Liste von
Geradensegmenten, die einen Polygonzug bilden. Falls die Kontur geschlossen
ist, wird durch die Geradensegmente ein geschlossener Polygonzug gebildet.
}

\proc{PointList}{FitPolygonContur}{Contur c,int mlng,double mdist}
\descr{
An die Kontur $c$ wird ein Polygonzug angepaßt. Die Mindestanzahl der zu einer
Seite des Polygonzuges gehörenden Punkte wird durch $mlng$ festgelegt, $mdist$
gibt den maximal zulässigen Abstand eines Konturpunktes zum Polygonzug
an. Rückgabewert ist eine Punktliste mit den Eckpunkten des angepaßten
Polygons. Falls die Kontur $c$ geschlossen ist, wird der Endpunkt der letzten
Seite nicht in die Liste aufgenommen, da er mit dem Anfangspunkt der ersten
Seite identisch ist.
}

\subsection{Segmentierung von Punktlisten}
\proc{Segment}{SegmentPointList}{PointList pl, int mode}
\descr{
Die Punktliste $pl$ wird in Linien, Kreise und Ellipsen ($mode$=SPL\_ALL),
in Linien und Kreise ($mode$=SPL\_LINECIRC) oder nur in Linien 
($mode$=SPL\_LINE) segmentiert. Zurückgegeben wird eine
Liste vom Typ Segment mit den Parametern der gefundenen Segment oder im
Fehlerfall NULL. Es wird der Algorithmus aus ``P. L. Rosin: Nonparametric
Segmentation of Curves into Various Representations. PAMI-17, 1995,
pp. 1140-1153'' verwendet.\\
}

\proc{Segment}{SegmentPointList}{PointList pl, int mode, [double maxdev]}
\descr{
Die Punktliste $pl$ wird in Linien, Kreise und Ellipsen ($mode$=SPL\_ALL),
 in Linien
und Kreise ($mode$=SPL\_LINECIRC) oder nur in Linien ($mode$=SPL\_LINE) 
segmentiert. Zurückgegeben
wird eine Liste vom Typ Segment mit den Parametern der gefundenen Segment oder
im Fehlerfall NULL. Wird der Parameter $mode$ zusätzlich mit SPL\_NOCLOSE
ODER-verknüpft, so wird nicht versucht, das erste und letzte Segment zu
verbinden. 
}

\proc{Segment}{DetermineSegment}{PointList pl, int pa, int pe, int type, Segment sl, int* ma, double* md}
\descr{
An den Ausschnitt [$pa$,$pe$] der Punktliste $pl$ wird genau ein 
Segment angepaßt. Der Parameter type definiert die in Frage kommenden
Segmenttypen (ODER-Verknüpfung):\\
DS\_LINE - Liniensegment\\
DS\_CIRCLE - Kreissegment\\
DS\_ELLIPSE - Ellipsensegment\\
Wird eine bereits vorhandene Segmentliste $sl$ übergeben, so wird das
gefundene Segment angehängt (sonst $sl$=NULL). Der zurückgegebene
Zeiger $ma$ zeigt auf den Punkt mit dem größten Abstand $md$ vom
Segment. Rückgabewert ist ein Zeiger auf das gefundene Segment bzw. NULL
bei Fehler.
}

\proc{Segment}{LineSegPointList}{PointList pl,int closed,int mlng,double mdist}
\descr{
Die geordnete Punktliste $pl$ wird in Geradensegmente zerlegt. Die
Mindestanzahl der zu einem Segment gehörenden Punkte wird durch $mlng$
festgelegt, $mdist$ gibt den maximal zulässigen Abstand eines Punktes der Punktliste zu
dem nächstliegenden Geradensegment an. Rückgabewert ist das erste Element einer
Liste von Geradensegmenten, die einen Polygonzug bilden. Falls $closed$=TRUE
ist, wird durch die Geradensegmente ein geschlossener Polygonzug gebildet.
}
\proc{PointList}{FitPolygonPointList}{PointList pl,int closed,int mlng,double mdist}
\descr{
An die geordnete Punktliste $pl$ wird ein Polygonzug angepaßt. Die
Mindestanzahl der zu einer Seite des Polygonzuges gehörenden Punkte wird durch $mlng$
festgelegt, $mdist$ gibt den maximal zulässigen Abstand eines Punktes der
Punktliste zum Polygonzug an. Rückgabewert ist eine Punktliste mit den
Eckpunkten des angepaßten Polygons. Falls $closed$=TRUE ist, wird der Endpunkt
der letzten Seite nicht in die Liste aufgenommen, da er mit dem Anfangspunkt
identisch ist.
}

\subsection{Anpassung an Grauwertverläufe}

\proc{double}{FitGrayLine}{Image img, double lp[2][2],int dist, double *p, double *phi}
\descr{
Über das Geradensegment mit den Endpunkten $lp[0]$ und $lp[1]$ wird ein
Fenster der Breite $2 \cdot dist$ gelegt. An die Punkte aus diesem Fenster
wird eine Gerade angepaßt, wobei die Punkte mit ihrem Grauwert gewichtet
werden. Punkte, deren Grauwert unterhalb des Mittelwertes im Fenster liegt,
erhalten das Gewicht Null.
}
\proc{double}{FitGradLine}{Image img, double lp[2][2],int dist, double *p, double *phi}
\descr{
Über das Geradensegment mit den Endpunkten $lp[0]$ und $lp[1]$ wird ein
Fenster der Breite $2 \cdot dist$ gelegt. An die Punkte aus diesem Fenster
wird eine Gerade angepaßt, wobei die Punkte mit ihrem Gradientenbetrag 
gewichtet werden. Punkte, deren Gradientenbetrag unterhalb des Mittelwertes 
im Fenster liegt, erhalten das Gewicht 0.0 .
}
 
\newpage
\makeatletter{}\nsection{Signal-Transformationen}{signalTrafo}

\subsection{Fourier- und Hartleytransformation - Operationen im Frequenzbereich}

Hauptanwendungen der Fourier- und der Hartleytransformation sind 
Operationen im Zusammenhang mit Faltung und Korrelation. Diese 
Operationen sind im Frequenzbereich einfacher auszuführen. Während
die Fouriertransformation die Arbeit mit komplexen Zahlen und Bildern
erfordert, ist die Hartleytransformation eine Transformation aus dem
reellen Zahlenbereich in den reellen Zahlenbereich. Zu den im 
Frequenzbereich möglichen Operationen auf Fourierspektren gibt es 
äquivalente Operationen für die Hartleytransformierte.

\vspace{1em}
\noindent Allgemeine Hinweise:
\begin{itemize}
\item Alle Funktionen dieser Gruppe arbeiten mit Gleitkommazahlen bzw.
Bildern mit Gleitkommawerten.
\item Die schnellen Algorithmen für die Fourier- und Hartleytransformation
erfordern Werte-Anzahlen, die Potenzen von 2 darstellen (2,4,8,16..).
Wenn diese Bedingung erfüllt ist, arbeiten die Funktionen wesentlich 
schneller.
\item Aus Geschwindigkeits- und Speichergründen ist die Hartley-Transformation
vorzuziehen, wenn das Problem damit lösbar ist.
\end{itemize}


\subsubsection{Fourier- und Hartleytransformation}

\proc{int}{Fourier}{const Vector \&re1,const Vector \&im1,int mode,
Vector \&re2,Vector \&im2}
\procf{int}{Fourier}{Vector \&re,Vector \&im,int mode=NORMAL}
\descr{
Die durch die Vektoren $re1$ und $im1$ gegebene Folge von komplexen 
Zahlen wird transformiert ($mode$=NORMAL: Hintransformation, $mode$=INVERS:
Rücktransformation). Das Ergebnis der Transformation wird auf den Vektoren
$re2$ und $im2$ bzw. den Ausgangvektoren bereitgestellt. Der Wert bei 
$re2[0]$ und $im2[0]$ ist der Gleichanteil.
}

\proc{int}{Fourier}{const Matrix \&src,int mode,Matrix \&dst}
\procf{int}{Fourier}{Matrix \&m,int mode=NORMAL}
\descr{
Die durch die Matrix gegebene Folge von komplexen Zahlen wird 
transformiert ($mode$=NORMAL: Hintransformation, $mode$=INVERS:
Rücktransformation). Das Ergebnis der Transformation wird auf der Matrix
$dst$ bzw. der Ausgangsmatrix bereitgestellt. Die Matrix muß 2 Zeilen
oder 2 Spalten aufweisen. Die erste Zeile (Spalte) enthält die Real-Teile,
die zweite Zeile (Spalte) die Imaginär-Teile. Der Gleichanteil liegt 
beim Index 0.
}


\proc{int}{Hartley}{const Vector \&src,const Vector \&dst}
\procf{int}{Hartley}{Vector \&src}
\descr{
Die durch den Vektor $src$ gegebene Folge von reellen Zahlen wird
transformiert. Das Ergebnis der Transformation wird auf dem Vektor
$dst$ bzw. dem Ausgangsvektor bereitgestellt. Der Wert bei $dst[0]$ 
ist der Gleichanteil.
}


\proc{void}{FourierImgD}{ImageD re1,ImageD im1,int mode,ImageD re2,ImageD
  im2,int dir=XY}
\descr{
  Das durch Realteil $re1$ und Imaginärteil $im1$ gegebene komplexe Bild wird
  transformiert ($mode$=NORMAL: Hintransformation, $mode$=INVERS: Rücktransformation)
  und in den Bildern $re2$ und $im2$ bereitgestellt. Die Koordinaten werden
  hier auf den Wertebereich $[-\frac{n}{2},\frac{n}{2}-1]$ abgebildet, so 
  daß die Frequenz 0 in der Mitte des Bildes liegt.
  \noindent Folgende Werte für $dir$ sind möglich:
  \begin{itemize}
  \item XY - Die komplette 2D-Transformation (in X- und Y-Richtung) wird
    durchgeführt
  \item X\_ONLY - Es wird nur die Transformation in X-Richtung durchgeführt.
  \item Y\_ONLY - Es wird nur die Transformation in Y-Richtung durchgeführt.
  \end{itemize}
}

\proc{int}{HartleyImgD}{ImageD src,ImageD dest,int dir=XY}
\descr{
  Das durch $src$ gegebene Bild wird transformiert und im Bild $dest$ 
  bereitgestellt. Die Koordinaten werden hier auf den Wertebereich 
  $[-\frac{n}{2},\frac{n}{2}-1]$ abgebildet, so daß die Frequenz 0 
  in der Mitte des Bildes liegt.
  \noindent Folgende Werte für $dir$ sind möglich:
  \begin{itemize}
  \item XY - Die komplette 2D-Transformation (in X- und Y-Richtung) wird
    durchgeführt
  \item X\_ONLY - Es wird nur die Transformation in X-Richtung durchgeführt.
  \item Y\_ONLY - Es wird nur die Transformation in Y-Richtung durchgeführt.
  \end{itemize}
}

\subsubsection{Abgeleitete Spektren und Darstellungen}

\proc{int}{PowerSpectrumFImgD}{ImageD re,ImageD im,ImageD imgd,int mode=MD\_POWER}
\descr{
  Es wird das Leistungsspektrum eines Bildes aus dessen fouriertransformierten 
  Bild berechnet. 
  Dazu wird punktweise das Betragsquadrat der komplexen Bildpunkte berechnet.
  Es sind folgende Modi möglich:
  \begin{itemize}
  \item MD\_POWER Leistungsspektrum
  \item MD\_MAGNITUDE Amplitudenspektrum (Quadratwurzel des Leistungsspektrums)
  \item MD\_LOG logarithmiertes Leistungspektrum
  \end{itemize}
}

\proc{int}{PowerSpectrumHImgD}{ImageD src,ImageD imgd,int mode=MD\_POWER}
\descr{
  Es wird das Leistungsspektrum eines Bildes aus dessen Hartleytransformierten 
  Bild berechnet.
  Es sind folgende Modi möglich:
  \begin{itemize}
  \item MD\_POWER Leistungsspektrum
  \item MD\_MAGNITUDE Amplitudenspektrum (Quadratwurzel des Leistungsspektrums)
  \item MD\_LOG logarithmiertes Leistungspektrum
  \end{itemize}
}

\proc{int}{PowerSpectrumImgD}{ImageD imgs,ImageD imgd,int mode=MD\_POWER}
\descr{
  Es wird das Leistungsspektrum des Bildes $imgs$ berechnet.
}

\proc{int}{MPSpectrumFImgD}{ImageD re,ImageD im,ImageD mag,ImageD phase}
\descr{
  Aus dem komplexen Fourierspektrum in den Bildern $re$ und $im$ wird 
  die Betrags-/Phasen-Darstellung berechnet und in den Bildern $mag$ (Betrag)
  und $phase$ (Phase) gepeichert.
}

\proc{int}{MPSpectrumHImgD}{ImageD sp,ImageD mag,ImageD phase}
\descr{
  Aus der Hartleytransformierten $sp$ wird die Betrags-/Phasen-Darstellung 
  berechnet und in den Bildern $mag$ (Betrag) und $phase$ (Phase) gepeichert.
}

\proc{int}{MPSpectrumImgD}{ImageD im,ImageD mag,ImageD phase}
\descr{
  Aus dem Bild $im$ wird die Betrags-/Phasen-Darstellung der 
  Fouriertransformierten berechnet und in den Bildern $mag$ (Betrag) 
  und $phase$ (Phase) gepeichert.
}

\proc{int}{FourierMPImgD}{ImageD mag,ImageD phase,ImageD re,ImageD im}
\descr{
  Die Betrags-/Phasen-Darstellung der Fouriertransformierten in den 
  Bildern $mag$ und $phase$ wird in die komplexe Darstellung in den Bildern 
  $re$ (Realteil) und $im$ (Imaginärteil) umgerechnet.
}

\proc{int}{HartleyMPImgD}{ImageD mag,ImageD phase,ImageD dst}
\descr{
  Aus der Betrags-/Phasen-Darstellung der Fouriertransformierten in den 
  Bildern $mag$ und $phase$ wird die reellwertige Hartleytransformierte
  im Bild $dst$ umgerechnet. Dabei wird vorausgesetzt, daß das 
  das Ausgangsbild das Spektrum eines reellen Bildes ist. Die andernfalls
  entstehenden imaginären Anteile werden ignoriert.
}

\proc{int}{CepstrumImgD}{ImageD imgs,ImageD imgd}
\descr{
  Es wird das Cepstrum des Bildes $imgd$ berechnet. 
  Das Cepstrum ist das Leistungsspektrum des logarithmierten
  Leistungsspektrums).
}

\subsubsection{Faltung und Kreuzkorrelation}

Es stehen jeweils Varianten der Faltung, inversen Faltung und 
Kreuzkorrelation zur Verfügung, die die entspechende Operation
im Ortsbereich(Grauwertbild mit Gleitkommawerten), im Frequenzraum 
der Fouriertransformation und im Frequenzraum der Hartleytransformation
ausführen. Bei den Operationen im Ortsbereich erfolgt intern eine
Transformation in den Frequenzraum. Die bei der Fouriertransformation
gemachten Aussagen bezüglich der Wahl der Bildgrößen für eine optimale
Abarbeitungsgeschwindigkeit gelten deshalb auch hier.

\proc{int}{Convolution}{const Vector \&src1,const Vector \&src2,Vector \&dst}
\descr{
  Die Funktion im Vektor $src1$ wird mit dem Vektor $src2$ gefaltet und 
  das Ergebnis im Vektor $dst$ gespeichert.
}

\proc{int}{ConvolutionImgD}{ImageD im1,ImageD im2,ImageD dst,int mode=MD\_USE\_BIAS}
\descr{
  Das Bild $im1$ wird mit dem Bild $im2$ gefaltet und das Ergebnis in Bild
  $dst$ gespeichert.
}

\proc{int}{ConvolutionFImgD}{ImageD re1,ImageD im1,
  ImageD re2,ImageD im2,ImageD re3,ImageD im3}
\descr{
  Die der Faltung entsprechende Operation wird auf den komplexen
  Fouriertransformierten ($re1$,$im1$) und ($re2$,$im2$) ausgeführt und
  das Ergebnis (Fouriertransformierte des gefalteten Bildes) in den Bildern
  $re3$,$im3$ gespeichert.
}
\proc{int}{ConvolutionHImgD}{ImageD im1,ImageD im2,ImageD im3}
\descr{
  Die der Faltung entsprechende Operation wird auf den  
  Hartleytransformierten $im1$ und $im2$ ausgeführt und
  das Ergebnis (Hartleytransformierte des gefalteten Bildes) im Bild
  $im3$ gespeichert.
}

\proc{int}{ConvolutionImg}{const Image \&im1,const Image \&im2,
  Image \&dst,double factor=0.0,int mode=MD\_USE\_BIAS}
\descr{
  Das Bild $im1$ wird mit dem Bild $im2$ gefaltet und das Ergebnis in Bild
  $dst$ gespeichert. Um eine optimale Umwandlung in Integer-Werte zu
  ermöglichen, kann der Faktor $factor$ angegeben werden, mit dem alle Werte
  vor der Konvertierung multipliziert werden. Ist $factor=0.0$, so wird eine
  automatische Grauwert-Skalierung so vorgenommen, daß der Wert mit dem
  maximalen Betrag den Werte-Bereich genau ausschöpft.
}

\proc{int}{ConvolutionImg}{const Image \&im1,const Image \&im2,
ImageD dst, int mode=MD\_USE\_BIAS}
\descr{
  Das Bild $im1$ wird mit dem Bild $im2$ gefaltet und das Ergebnis im 
Gleitkomma-Bild $dst$ gespeichert. 
}

\proc{int}{InvConvolution}{const Vector \&src1,const Vector \&src2,double beta,Vector \&dst}
\descr{
  Es wird der Vektor $dst$ berechnet, der gefaltet mit Vektor $src1$ den 
  Vektor $src2$ ergibt (pseudo-inverse Faltung). Der vorzugebende 
  Parameter $beta$ beschreibt den Rauschanteil in den Ausgangsfunktionen. 
}

\proc{int}{InvConvolutionImgD}{ImageD im1,ImageD im2,ImageD dst,double beta=0.000001,int mode=MD\_USE\_BIAS}
\descr{
  Es wird das Bild $dst$ berechnet, das gefaltet mit Bild $im1$ das Bild $im2$
  ergibt (pseudo-inverse Faltung). Der vorzugebende Parameter $beta$ 
  beschreibt den Rauschanteil in den Bildern. 
}

\proc{int}{InvConvolutionFImgD}{ImageD re1,ImageD im1,
        ImageD re2,ImageD im2,ImageD re3,ImageD im3,double beta}
\descr{
Die der (pseudo-)inversen Faltung entsprechende Operation wird auf 
den komplexen Fouriertransformierten ($re1$,$im1$) und ($re2$,$im2$) 
ausgeführt und das Ergebnis (Fouriertransformierte des rekonstruierten Bildes) 
in den Bildern $re3$,$im3$ gespeichert.
}

\proc{int}{InvConvolutionHImgD}{ImageD im1,ImageD im2,ImageD im3}
\descr{
  Die der (pseudo-)inversen Faltung entsprechende Operation wird auf den  
  Hartleytransformierten $im1$ und $im2$ ausgeführt und
  das Ergebnis (Hartleytransformierte des rekonstruierten Bildes) im Bild
  $im3$ gespeichert.
}

\proc{int}{InvConvolutionImg}{const Image \&im1,const Image \&im2,
  Image \&dst,
  double factor=0.0,double beta=0.000001,int mode=MD\_USE\_BIAS}
\descr{
  Es wird das Bild $dst$ berechnet, das gefaltet mit Bild $im1$ das Bild $im2$
  ergibt (pseudo-inverse Faltung). Der vorzugebende Parameter $beta$
  beschreibt den Rauschanteil in den Bildern. Um eine optimale Umwandlung in
  Integer-Werte zu ermöglichen, kann der Faktor $factor$ angegeben werden,
  mit dem alle Werte vor der Konvertierung multipliziert werden. Ist
  $factor=0.0$, so wird eine automatische Grauwert-Skalierung so vorgenommen,
  daß der Wert mit dem maximalen Betrag den Werte-Bereich genau ausschöpft.
}

\proc{int}{InvConvolutionImg}{const Image \&im1,const Image \&im2,
  ImageD dst,
  double beta=0.000001,int mode=MD\_USE\_BIAS}
\descr{
  Es wird das Gleitkomma-Bild $dst$ berechnet, das gefaltet mit Bild 
  $im1$ das Bild $im2$ ergibt (pseudo-inverse Faltung). Der 
  vorzugebende Parameter $beta$ beschreibt den Rauschanteil in den 
  Bildern. 
}

\proc{int}{CrossCorrelationImgD}{ImageD im1,ImageD im2,ImageD dst}
\descr{
  Die Kreuzkorrelation der Bilder $im1$ und $im2$ wird berechnet und 
  das Ergebnis in Bild $dst$ gespeichert.
}

\proc{int}{CrossCorrelationFImgD}{ImageD re1,ImageD im1,
  ImageD re2,ImageD im2,ImageD re3,ImageD im3}
\descr{
  Die der Kreuzkorrelation entsprechende Operation wird auf den komplexen
  Fouriertransformierten ($re1$,$im1$) und ($re2$,$im2$) ausgeführt und
  das Ergebnis (Kreuzkorrelation des gefalteten Bildes) in den Bildern
  $re3$,$im3$ gespeichert.
}

\proc{int}{CrossCorrelationHImgD}{ImageD im1,ImageD im2,ImageD im3}
\descr{
  Die der Kreuzkorrelation entsprechende Operation wird auf den  
  Hartleytransformierten $im1$ und $im2$ ausgeführt und
  das Ergebnis (Hartleytransformierte des gefalteten Bildes) im Bild
  $im3$ gespeichert.
}

\subsubsection{Manipulation im Frequenzbereich}

\proch{int}{WhiteningImgD}{ImageD img1,ImageD img2,double beta=0}{fourier.h}
\descr{Das Bild $img1$ wird ''weiß gemacht'' (whitening), das heißt dass die
  Amplituden der Fourierkoeffizienten zu 1.0 normiert werden. Diese Funktion
  beinhaltet die implizite Transformation in den Frequenzbereich und zurück. 
  Die Normierung der Fourierkoeffizienten erfolgt nach:
  \[
  F_{i,j} = \frac{F_{i,j}}{| F_{i,j} |+\beta^2}
  \]
}

\proch{int}{WhiteningFImgD}{ImageD re1,ImageD im1,ImageD re2,ImageD im2,double
  beta=0}{fourier.h}
\descr{Auf der komplexen Fouriertransformierten wird die Operation des
  ''Whitening'' (\see{WhiteningImgD}) ausgeführt. Die Transformation in den
    Frequenzraum und zurück muss hier explizit vorher bzw. hinterher
    vorgenommen werden. 
}

\proch{int}{WhiteningHImgD}{ImageD imgs,ImageD imgd,double beta=0}{fourier.h}
\descr{Auf der Hartleytransformierten wird die Operation des ''Whitening'' 
(\see{WhiteningImgD}) ausgeführt. Die Hartley-Transformation muss hier explizit 
vorher und hinterher vorgenommen werden. 
}

\subsection{Haartransformation}

\proc{int}{HaarImg}{Image imgs,int depth,int mode,Image imgs}
\descr{
  Haartransformation des Bildes $imgs$ in das Bild $imgd$ mit der
  Auflösungsstufe $depth$ ($mode$=NORMAL: Hintransformation, $mode$=INVERS:
  Rücktransformation).
}

\subsection{Momenttransformation}

\proc{ImageD}{MomentImg}{Image imgs,int p,int q,int n,ImageD imgd}
\descr{Es wird punktweise aus einer $n \cdot n$-Umgebung das Moment
  $m_{pq}$ über dem Bild $imgs$ berechnet und im Bild $imgd$ abgelegt.
}

\subsection{Radon-Transformation}

\proch{int}{RadonImg}{const Image \&src,Image \&radon}{radon.h}
\descr{Berechnet die Radontransformierte des Bildes $src$ und legt das Ergebnis in
$radon$ ab.}

\proc{int}{InvRadonImg}{const Image \&radon,Image \&res,int fmax=-1}
\descr{Berechnet aus einem radontransformierten Bild $radon$ das Originalbild $res$. Ist $fmax$ größer
als Null, so werden Frequenzen größer $fmax$ bei der Rücktransformation nicht berücksichtigt.}

 
\newpage
\makeatletter{}\nsection{Merkmale, Ähnlichkeiten und Abstandsmaße}{features}
\label{Merkmale}

Zur Klassifikation, zur Bestimmung von Ähnlichkeiten und zur Lösung von 
Zuordnungsproblemen werden Merkmale von Bildern, Regionen und Objekten 
ermittelt. Typischerweise sind Merkmale numerische Werte, die 
charakteristische Eigenschaften beschreiben. Gewöhnlich kommen
mehrere Merkmale zum Einsatz, die in ICE in einem \class{Vector} 
oder als \vector{double} abgelegt werden. 

\subsection{Abstandsmaße}
\label{VectorDistance}
Die (abstrakte) Klasse \verb+VectorDistance+ dient in ICE als Abstandsmaß und 
kann bei der Klassifikation, bei Zuordnungsproblemen und zur Bestimmung von 
Ähnlichkeitsmaßen verwendet werden. Die Klasse (und damit die abgeleiteten 
Klassen für spezielle Abstandsmaße) definiert die Methode 
\verb+Distance+ und den Operator \verb+operator()+, die den Abstand ihrer 
Argumente ermitteln:

\proch{double}{VectorDistance::Distance}{const vector$<$double$>$ \&x,const vector$<$double$>$ \&x}{vectordistance.h}
\procf{double}{VectorDistance::Distance}{const Vector \&x,const Vector \&y}
\procf{double}{VectorDistance::operator()}{const vector$<$double$>$ \&x,const vector$<$double$>$ \&y}
\procf{double}{VectorDistance::operator()}{const Vector \&x,const Vector \&y}
\descr{Es wird der Abstand der übergebenen Argumente ermittelt und zurückgegeben.}

\subsubsection{EuclidianVectorDistance}
\label{EuclidianVectorDistance}
\verb+EuclidianVectorDistance+ ist eine von \bsee{VectorDistance} abgeleitete Klasse, die 
die Distanz als Euklidische Distanz $ \sqrt{\sum_{i} (x_{i} - y_{i} )^2} $  berechnet.

\subsubsection{CityBlockVectorDistance}
\label{CityBlockVectorDistance}
\verb+CityBlockVectorDistance+ ist eine von \verb+VectorDistance+ abgeleitete Klasse, die 
die Distanz als CityBlock-Distanz $ \sum_{i} |x_{i} - y_{i}| $  berechnet.

\subsubsection{QuadraticFormVectorDistance}
\label{QuadraticFormVectorDistance}
\verb+QuadraticFormVectorDistance+ ist eine von \verb+VectorDistance+ abgeleitete Klasse, die 
die Distanz als Quadratische Form $ \sum_{i,j} a_{i,j} \cdot (x_{i} - y_{i} ) \cdot (x_{j} - y_{j} ) $  
berechnet. Die Matrix $a$ wird über den Konstruktor vorgegeben:

\proch{}{QuadraticFormVectorDistance::QuadraticFormVectorDistance}{const Matrix \&a}{vectordistance.h}
\descr{Erzeugt eine QuadraticFormVectorDistance unter Verwendung der gegebenen Matrix $a$.}

\subsubsection{EarthMoverVectorDistance}
\label{EarthMoverVectorDistance}
\verb+EarthMoverVectorDistance+ ist eine von \verb+VectorDistance+ 
abgeleitete Klasse, die die Earth Mover-Distanz berechnet. Diese Distanz 
ist sinnvoll einsetzbar, wenn benachbarte/aufeinderfolgende Merkmale in 
Zusammenhang stehen, wie es bei den Häufigkeiten von Histogrammklassen 
der Fall ist.

Beispiel für die Berechnung der Distanzen zweier Bilder anhand des 
Histogramms:
\nopagebreak
\begprogr
\begin{verbatim}
Image img1;
Image img2;
...
Histogramm h1(img1);
Histogramm h2(img2);

vector<double> hvec1=h1.Rel();
vector<double> hvec2=h2.Rel();
EuklidianVectorDistanz ed;
CityBlockVectorDistanz md;
EarthMoverVectorDistanz emd;

cout << "Euklidische Distanz: " << ed(hvec1,hvec2) << endl;
cout << "City Block Distanz: " << md(hvec1,hvec2) << endl;
cout << "Earth Mover Distanz: " << emd(hvec1,hvec2) << endl;
\end{verbatim}
\endprogr

\subsection{Distanz-Matrix}
\proch{Matrix}{DistanceMatrix}{const Matrix \&feat1, const Matrix \&feat2,
  int mode=D\_EUKLID}{assignment.h}
\procf{Matrix}{DistanceMatrix}{const Matrix \&feat1, int mode=D\_EUKLID}
\procf{Matrix}{DistanceMatrix}{const Matrix \&feat1, const Matrix \& feat2, const VectorDistance \&dist}
\procf{Matrix}{DistanceMatrix}{const Matrix \&feat1, const VectorDistance \&dist}
\descr{
Aus zwei Merkmalslisten $feat1$ und $feat2$ wird eine Kostenmatrix 
aufgestellt, die geeignet ist, die Zuordnung zu ermitteln. Die Zahl 
der Merkmale in beiden Listen muss gleich sein (gleiche Spaltenzahl).
Die Zeilenzahl der Ergebnismatrix ist gleich der Zeilenzahl von $feat1$,
die Spaltenzahl ist gleich der Zeilenzahl von $feat2$.\\
Der Modus $mode$ gibt die zu verwendende Metrik an:\\
\begin{tabular}{ll}
D\_EUCLID    & Euklidischer Abstand\\
D\_SQUARE    & Quadrat des euklidischen Abstands\\
D\_CITYBLOCK & city block-Metrik (L1-Norm)\\
\end{tabular}
}
\seealso{Hungarian}
\seealsonext{TimeWarp}

\nsection{Registrierung, Matching}{registration}

Registrierung ist die Bestimmung von Transformationen, die Bilder oder
Objekte ineinander überführen.

\hypertarget{Trafo-Konstanten}{}
Die Spezifikation der zu ermittelnden Transformation erfolgt in ICE 
über Konstanten. Dabei nimmt die Spiegelung eine Sonderstellung ein.
Da bei vielen Bildverarbeitungsaufgaben die Spiegelung auszuschließen ist,
gibt es von den Transformations-Gruppen, die auch eine Spiegelung beinhalten,
auch jeweils eine Variante ohne Spiegelung.

\begin{tabular}{|l|l|l|} \hline
* & mit Spiegelung & ohne Spiegelung \\ \hline
projektive Transformation & TRM\_PROJECTIVE & - \\
affine Transformation & TRM\_AFFINE & TRM\_AFFINE\_NOR \\
Ähnlichkeitstransformation & TRM\_SIMILARITY & TRM\_SIMILARITY\_NOR \\
Euklidische Transformation & TRM\_EUCLIDEAN & TRM\_EUCLIDEAN\_NOR \\
Translation & - & TRM\_SHIFT \\ \hline
\end{tabular}

\subsection{Schätzung geometrischer Transformationen
aus Punktkorrespondenzen}

\proch{Trafo}{MatchPointlists}{const Matrix \&p1,const Matrix \&p2,int
  mode=TRM\_PROJECTIVE}{geo.h}
\procf{Trafo}{MatchPointlists}{const Matrix \&p1,const Matrix \&p2,
int mode,const Vector \&w}
\descr{Bestimmung einer an die gegebenen Punktreferenzen angepassten
Transformation mittels Ausgleichsrechnung, bei der der quadratische 
Fehler $\| T(p_1) - p_2\|^2$ minimiert wird.
Die Punktreferenzen müssen als Punktlisten in den zwei Matrizen 
$p1$ und $p2$ bereitgestellt werden, wobei in jeder Zeile ein Punkt 
gespeichert sein muss. Die Spaltenzahl von p1 und p2 bestimmen die
Diomension des Quell- bzw. Zielraumes.\\
In einem (optionalen) Vektor $w$ ist für jedes Punktpaar ein 
Gewicht anzugeben. Ohne $w$ werden alle Punktpaare gleich 
gewichtet.\\
Der Parameter $mode$ (\hyperlink{Trafo-Konstanten}{Trafo-Konstanten}) 
bestimmt den Typ der geometrischen Transformation.
\begin{itemize}
\item TRM\_SHIFT - Translation
\item TRM\_SIMILARITY\_NOR - Ähnlichkeits-Transformationen (ohne Spiegelung)
\item TRM\_AFFINE - Affine Transformationen
\item TRM\_PROJECTIVE - Projektive Transformationen
\end{itemize}
}
\seealso{AffinFitMoments}
\seealso{estimateTransformation}

\proch{Trafo}{MatchPointlists}{const \vector{Point} \&pl1,
  const \vector{Point} \&pl2, int mode = TRM\_PROJECTIVE}{geo.h}
\procf{Trafo}{MatchPointlists}{const \vector{Point} \&pl1,
  const \vector{Point} \&pl2, int mode = TRM\_PROJECTIVE, 
  const \vector{double} \&weight}
\descr{Spezialfall von MatchPointlists, der Punktlisten als 
\vector{Point} akzeptiert. Diese Funktionen funktionieren genauso, 
sind aber auf 2D-2D-Transformationen beschränkt.}

\proc{Trafo}{MatchPointlists}{PointList pl1,PointList pl2,int mode}
\descr{Spezialfall von MatchPointlists, bei dem die Punktlisten
als Datentyp $PointList$ übergeben werden. 
Dieser Typ ist veraltet und sollte nicht mehr genutzt werden. 
Als Gewicht der 
Punktpaare wird das in der Liste pl2 gespeicherte Gewicht 
verwendet.}

\proc{Trafo}{MatchPointlistsLinOpt}{const Matrix \&p1,const Matrix \&p2,int
mode=TRM\_AFFINE}
\procf{Trafo}{MatchPointlistsLinOpt}{const Matrix \&p1,const Matrix \&p2,int mode,const Vector \&w,double limit=1000000.0}
\descr{Bestimmung einer an die gegebenen Punktreferenzen angepassten
Transformation. Die Punktreferenzen müssen als Punktlisten in den 
zwei Matrizen $p1$ und $p2$ bereitgestellt werden, wobei in jeder 
Zeile ein Punkt gespeichert sein muß.
In einem (optionalen) Vektor $w$ kann für jedes Punktpaar ein 
Gewicht angegeben werden. Ohne $w$ werden alle Punktpaare gleich gewichtet.
Die Transformation wird mittels linearer Optimierung (Simplexmethode) 
bestimmt. Anders als bei der Methode der kleinsten Quadrate werden
hier die Beträge des Fehlers $\|T(p_1) - p_2\|$ minimiert, wodurch Ausreißer
das Ergebnis weniger verfälschen.
Diese Funktion ist zur Zeit auf 2D-2D-Transformationen beschränkt.
Der Parameter $limit$  wird im linearen Optimierungsmodell in einer 
zusätzlichen Beschränkungsungleichung verwendet. Der Default-Wert ist
1000000.0. Gegebenenfalls muss dieser Wert vergroessert werden.\\
Der Parameter $mode$ bestimmt den Typ der geometrischen 
Transformation (\hyperlink{Trafo-Konstanten}{Transformations-Konstanten}).
\begin{itemize}
\item TRM\_SHIFT - Translation (2 Parameter)
\item TRM\_SIMILARITY\_NOR - Ähnlichkeits-Transformationen (4 Parameter)
\item TRM\_AFFINE - Affine Transformationen (6 Parameter)
\item TRM\_PROJECTIVE - Projektive Transformationen (8 Parameter)
\end{itemize}
}

\proc{int}{MatchPointlistsLinOpt}{PointList pl1,PointList pl2,double
tr[][3],int mode=TRM\_AFFINE,double limit=1000000.0}
\descr{Analog MatchPointlistsLinOpt, die Punktlisten werden
als Datentyp $PointList$ übergeben werden.
Dieser Typ ist veraltet und sollte nicht mehr genutzt werden. 
}
\seealso{NewPointList}

\subsection{Signalbasierte Methoden}
Die implementierten signalbasierten Methoden der Registrierung 
beruhen auf der Detektion von Verschiebungen mittels
Shift Detection by Restoration (SDR), beschrieben zum Beispiel in \\

{
\noindent
K.Voss,H.Süße,W.Ortmann,T.Baumbach: Shift detection by restoration\\
Pattern Recognition 32(1999), Elsevier, pp. 2067-2068\\
}

SDR basiert auf dem Modell, eine Verschiebung durch eine 
Faltung mit einem verschobenen Einheitsimpuls zu beschreiben. 
Die Rekonstruktion dieser Faltungsmaske erlaubt die Bestimmung 
der Lage des verschobenen Einheitsimpulses als Peak.

Die elementaren Funktionen zur Rekonstruktion der Faltungsmaske
der Verschiebung sind im Abschnitt Faltung und Kreuzkorrelation 
dokumentiert (\see{InvConvolution}). Die Ermittlung der Peaks
in den erhaltenen Bildern erfolgt mit der Funktion \see{PeakValuation}.

\see{DetectShift} verwendet diese Funktionen um die Verschiebung im Bild 
bzw. in einem Teil-Bild zu detektieren. Durch eine Blockmatching-artige
Verwendung des Verfahrens kann \see{DetectTrafo} allgemeine 
Transformationen bestimmen, wenn lokal die Transformation 
einer Verschiebung nahekommt.. 
Zur Unterdrückung des Einflusses globaler Helligkeitsschwankungen (Shading) 
kann die Vorverarbeitung der Bilder mit \see{PreprocessImg} sinnvoll sein.

\proc{int}{DetectShift}{Image img1,Image img2,
       double \&dx,double \&dy,double \&val,double beta=0.1}
\descr{
In zwei Bilder wird mittels der SDR-Methode eine Verschiebung
detektiert. Dazu werden die Funktionen zur Invertierung der
Faltung (\see{InvConvolution}) und zur Peaksuche (\see{PeakValuation})
verwendet. Es wird die Verschiebung ($dx$,$dy$) ermittelt, die das 
Bild $img1$ in das Bild $img2$ überführt. Der zurückgegebene Wert 
der Variable $val$ stellt ein Maß für die Güte dar. Der Parameter 
$beta$ optimiert den Prozess und muss abhängig von Rauschen und 
Störungen gewählt werden.}

\proc{int}{DetectTrafo}{Image img1,Image img2,Trafo \&tr,
double beta=0.1,int ct=3,int mode=DT\_NEARLY\_SHIFT}
\descr{
Es wird eine Transformation $tr$ ermittelt, die das Bild $img1$
in das Bild $img2$ überführt. Dies geschieht durch Ermittlung 
eines lokalen Verschiebungsvektors durch Anwendung
der SDR-Methode auf Teilblöcke der Bilder und Anpassung einer
projektiven 2D-2D-Transformation an die ermittelten 
Verschiebungsvektoren. Der Parameter $beta$ optimiert den Prozess
und muss abhängig von Rauschen und Störungen gewählt werden.\\
Im ersten Schritt wird die globale Verschiebung anhand des 
gesamten Bildes ermittelt. \\
Ist der Parameter $ct>0$, so erfolgt danach eine $ct$-fache 
iterative Anwendung der Verschiebungsdetektion in den Teilblöcken
des Bildes.\\
Der Parameter $mode$ steuert die Art der zu detektierenden 
Transformation. Einziger zulässiger Wert ist zur Zeit 
DT\_NEARLY\_SHIFT für die Detektion von Transformationen, die 
näherungsweise eine Verschiebung darstellen.
}

\proc{int}{PreprocessImg}{(Image imgs,Image imgd)}
\descr{
Oft treten bei der Fouriertransformation von Bildern die sogenannten
Fourierkreuze auf, die bei manchen Anwendungen störend sein können. Oft möchte
man auch hohe Frequenzen abschwächen. Sollte dies in einer Anwendung nötig
sein, so kann man das Bild vorher mit dieser Funktion vorverarbeiten. 
Es hängt von der jeweiligen Anwendung ab, ob dies sinnvoll ist. Dabei ist 
$imgs$ das Ausgangsbild, $imgd$ das Zielbild. Diese Funktion ist z.B. 
sinnvoll, wenn man aus dem Amplitudenspektrum weitere Transformationen 
berechnen will (Log-Polar-Transform).
}

\subsubsection{Peaksuche}

\proc{double}{PeakValuation}{Image img,Image mark,double\& x0,double\& y0,
        int mode=PN\_CONVOLUTION,int gnull=0,int zykl=TRUE}
\descr{
Es erfolgt die Suche nach dem globalen Maximum der Grauwertfunktion im 
Bild $img$ und dessen Bewertung. Wird ein Markierungsbild $mark!=NULL$ 
angegeben, so werden nur die unmarkierten Bildpunkte einbezogen. Die 
zurückgegebene Bewertung $B$ liegt im Intervall $[0,1]$ und ist ein Maß 
für den Abstand des Bildes vom Bild eines beliebig verschobenen 
Einheitsimpulses. Für $B=1.0$ liegt ein idealer verschobener 
Einheitsimpuls vor.\\
Der Parameter $gnull>=0$ legt den Grauwert-Nullpunkt des Bildsignales 
fest. Dieser liegt im allgemeinen bei $0$ oder $g_max/2$. 
Mit $zykl=TRUE$ wird das Bild als zweifach zyklisch fortgesetzt 
angesehen. Der Parameter $mode$ hat momentan keine Bedeutung.
}

\proc{int*}{Peak1D}{double* values,int anz,int\& panz,int zykl,int noise}
\procf{IVector}{Peak1D}{const Vector\& vec,int panz,int zykl,int noise}
\descr{
Es erfolgt die Suche nach lokalen Maxima in der durch das Feld $values$
oder den Vektor $vec$ repräsentierten eindimensionalen, diskreten 
Funktion. Im Falle eines Feldes beschreibt der Parameter $anz$ die
Anzahl der Funktionswerte (Größe des Feldes $values$). Die Anzahl der 
zu suchenden Maxima wird durch $panz$ (>=0) festgelegt. Mit $panz=0$ 
werden alle lokalen Maxima bestimmt.\\
Mit $zykl=TRUE$ wird die Funktion als eine zyklisch fortgesetzte Funktion
angesehen, was die Erkennung von Peaks an den Intervallrändern beeinflußt.
Solche Funktionen ergeben sich zum Beispiel als Ergebnis der Entfaltung.\\
Der Parameter $noise$ steuert die Rauschempfindlichkeit der Maximumsuche.
Es werden alle Nebenpeaks, die sich maximal $noise$ Grauwertstufen über
das größere der zwei direkt benachbarten lokalen Minima erheben, ignoriert.\\
In der ersten Aufrufvariante ist der Rückgabeparameter ein neu angelegtes 
Integer-Feld. Auf $panz$ wird dann die gefundene Anzahl der lokalen 
Maxima (Größe des Rückgabefeldes) abgelegt. Dieses Feld ist vom Nutzer 
freizugeben, sobald es nicht mehr benötigt wird. Im Falle eines Fehlers 
wird NULL zurückgegeben und $panz$ wird auf $-1$ gesetzt.
Die Rückgabe ist ebenfalls NULL, wenn die Funktion konstant ist.\\
In der Vektorvariante wird ein neu angelegter Vektor zurückgegeben.
}

Im Falle der Suche mehrerer Peaks wird eine Datenstruktur vom Typ
\see{PeakList} verwendet.

\proc{PeakList}{ImgPeakList}{Image img,Image mark,int panz=0,int mingrw=0,
        int zykl=FALSE, int noise=0,int feat=IPL\_NOFEAT,int gnull=0}
\descr{
Es erfolgt die Suche nach lokalen Extremwerten im Bild $img$. Wird ein
Markierungsbild $mark!=NULL$ angegeben, so werden in die Extremwertsuche
nur die unmarkierten Bildpunkte einbezogen. Die Anzahl der zu suchenden
Extremwerte wird durch $panz$ ($>=0$) festgelegt. Mit $panz=0$ werden alle
lokalen Extrema bestimmt. Für die Extremwerte kann mit $mingrw!=0$ ein
Mindestgrauwert gefordert werden.\\
Mit $zykl=TRUE$ wird das Bild als zweifach zyklisch fortgesetzt angesehen,
was die Erkennung von Maxima/Minima an den Bildrändern beeinflußt.
Solche Bilder ergeben sich zum Beispiel als Ergebnis der Entfaltung.\\
Der Parameter $noise$ steuert die Rauschempfindlichkeit der Maximumsuche.
Es werden alle Nebenpeaks, die sich maximal $noise$ Grauwertstufen über
den maximalen Grauwert des Peak Tales erheben, ignoriert.\\
Mit dem Parameter $feat$ werden die zurückgelieferten Daten festgelegt:
\begin{itemize}
\item IPL\_NOFEAT Koordinaten der Extrema
\item IPL\_MINCONTUR Koordinaten und Kontur des minimalen Einzugsbereiches
\item IPL\_MAXCONTUR Koordinaten und Kontur des maximalen Einzugsbereiches
\item IPL\_STANDARD Koordinaten und Mittelwert/Streuung
\item IPL\_ALL alle obigen Merkmale werden berechnet
\end{itemize}
Der Parameter $gnull>=0$ legt den Grauwert-Nullpunkt des Bildsignales fest.
Dieser liegt im allgemeinen bei $0$ oder $g_{max}/2$.
Die Rückgabe der Merkmale erfolgt als verkettete Liste von Elementen, die
durch einen neuen Datentyp PeakList definiert sind.\\
}

\label{PeakList}
Für die Beschreibung von Peakmerkmalen eines Bildes wird die Datenstruktur 
$PeakList$ verwendet, die den Aufbau von verketteten Listen erlaubt.

\begprogr\begin{verbatim}
typedef struct _PeakList {
  int        grw;
  ConturList contur;
  ConturList contur_max;
  double     sx,sy,sxy,x,y;
  _PeakList  *prev,*next;
} *PeakList;
\end{verbatim}\endprogr

\proc{PeakList}{NewPeakList}{}
\descr{
Es wird eine neue, leere Peakliste angelegt.
}

\proc{}{FreePeakList}{PeakList pl}
\descr{
Sämtlicher von pl belegter Speicherplatz (inklusive aller eventuell 
darin gespeicherten Konturen) wird freigegeben.
}

Beispiel für die Erzeugung einer Peakliste aus einem Bild:
\begprogr
\begin{verbatim}
PeakList pl;
pl=NewPeakList();
if (ImgPeakList(img,20)==NULL) exit(-1);
// .. bearbeiten/auslesen der Peakliste
FreePeakList(pl);
\end{verbatim}
\endprogr

\subsection{Merkmalsbasierte Methoden}

Zuordnungsprobleme entstehen im Rahmen der Registrierung als Zuordnung von
Punkten oder Objekten eines Bildes zu solchen des anderen
Bildes. Ausgangspunkt für die Zuordnung sind oft (invariante) Merkmale der 
Objekte. Es ist möglich, eine Kostenmatrix zu erstellen, die die Kosten der
Zuordnung zweier Objekte zueinander bewertet. Dies wird oft die Distanz der
Merkmale der Objekte sein. Je nach Randbedingungen ist die Zuordnung der
Punkte zueinander ansonsten beliebig (\see{Hungarian}) oder es gibt 
wie bei Konturpunkten eine vorgegebene Ordnung (\see{TimeWarp}).

Nach Ermittlung der Zuordnung kann die Transformation zwischen den Objekten
beziehungsweise den Bildern ermittelt werden (\see{MatchPointlists}..).

\subsubsection{Zuordnungsprobleme}
\proc{int}{AssignFunction}{const Matrix \&cost,IMatrix \&pairs,int mode}
\descr{
Dies ist eine Typdefinition für Funktionen, die anhand einer Kostenmatrix
Zuordnungen herstellen. Implementierte Funktionen dieses Types sind
\see{Hungarian} und \see{TimeWarp}.
}

\proc{double}{ReferenceCosts}{const Matrix \&costs,const IMatrix \&pairs}
\descr{
Anhand einer gegebenen Liste von Referenzen $pairs$ werden die Kosten 
entspechend der Werte in der Kostenmatrix $costs$ ermittelt und zurückgegeben.
Die Referenzen müssen als Paare von Indizes angegeben sein.
}

\proc{int}{Hungarian}{const Matrix \&cost,IMatrix \&reference\_pairs,
double \&min\_cost}
\procf{int}{Hungarian}{const Matrix \&cost,IMatrix \&reference\_pairs,
int mode=0}
\descr{
Es wird ein allgemeines Zuordnungsproblem (m Quellen, n Ziele) mit der
Ungarischen Methode gelöst. Das Problem wird allgemein durch eine 
Kostenmatrix $cost$ beschrieben. $cost$ is eine Matrix mit m Zeilen 
und n Spalten. Das Matrixelement cost[i][j] stellt die Kosten für 
die Zuordnung der Quelle i zum Ziel j dar. Ein Beispiel einer Kostenmatrix 
ist die Distanzmatrix (\see{DistanceMatrix}). 
{\bf Intern wird nur mit ganzzahligen Kosten gerechnet}, wobei durch eine 
interne Normierung der Kostenbereich auf den Integerbereich abgebildet
wird. Der Parameter $mode$ steuert die Art der Normalisierung. Bei mode=0
erfolgte eine lineare Transformation der Kostenwerte auf den Integer-Bereich,
wobei der maximale Kostenwert auf einen festgelegten Integer-Wert abgebildet
wird. $mode=1$ bewirkt eine Abbildung, die linear den minimalen Kostenwert auf
die Null und den nächstgrößeren Kostenwert auf die 1 abbildet. Werte, die bei
dieser Transformation den möglichen Maximalwert überschreiten, werden auf den
Maximalwert gesetzt.\\ 
Berechnet wird eine optimale Zuordnung im Sinne einer
minimalen Gesamtkostensumme. In der Integer-Matrix reference\_pairs
sind alle ermittelten optimalen Indexpaare enthalten. Diese Matrix 
besitzt 2 Spalten und höchstens min(m,n) Zeilen. Ist die Anzahl der 
Indexpaare kleiner als min(m,n) (return-Wert 1),so können für die nicht 
belegten Indizes beliebige Zuordnungen vom Nutzer selbst getroffen werden, 
da diese dann willkürlich sind. Auf min\_cost steht die optimale 
Gesamtkostensumme zur Verfügung.
}

\proc{int}{TimeWarp}{const Matrix \&cost,IMatrix \&reference\_pairs,
int mode=TW\_NORMAL}
\descr{
Es wird ein Zuordnungsproblem zwischen zwei Mengen gelöst, bei dem 
die Ordnung der Objekte beider Mengen vorgegeben ist. Beispiele für 
solche Mengen sind Funktionswerte diskreter Funktionen von der Zeit, 
wie sie z.B. für Sprachanalyse typisch sind. In der Bildverarbeitung 
treten dagegen oft als zyklische Funktionen die Merkmale von 
Konturpunkten auf.
Das Problem wird allgemein durch eine m*n-Kostenmatrix $cost$ beschrieben. 
Das Matrixelement cost[i][j] stellt die Kosten für die Zuordnung der 
Quelle i zum Ziel j dar. Lösung des Problems ist ein Weg in der Matrix 
mit minimaler Kostensumme, wobei jeder Punkt des Weges einer Zuordnung eines
Quellpunktes zu einem Zielpunkt entspricht.
TimeWarping ermittelt eine Zuordnung in Form eines Weges vom 
Startpunkt (0,0) zum Endpunkt (m,n).
Dieser Weg ist optimal im Sinne minimaler Gesamtkosten. 
In der Integer-Matrix reference\_pairs sind alle ermittelten optimalen
Indexpaare enthalten. Diese Matrix besitzt 2 Spalten. Jede Zeile enthält
ein Index-Paar der Zuordnung. Die Zuordnung kann mehrdeutig sein, ein
Objekt der einen Menge kann mehreren Objekten der zweiten Menge zugeordnet
sein.\\
Der Parameter $mode$ beschreibt die Vorgehensweise:\\
\begin{itemize}
\item mode==TW\_NORMAL \\
Die Wegsuche erfolgt vom Startpunkt (0,0) zum Endpunkt (m,n).
Zusätzlich können folgende Modifikationen angegeben werden: 
\begin{itemize}
\item mode==TW\_NORMAL||TW\_BIDIRECTIONAL \\
Es erfolgt eine zusätzliche Suche, bei der die Ordnung einer Menge 
invertiert (enstpricht einer Spiegelung) wird. Ergebnis ist das Minimum 
beider Suchschritte.
\item mode==TW\_NORMAL||TW\_SEARCHSTART\\
Die Funktionen werden als zyklisch angenommen (Konturen..). Jede Kombination
von Startpunkten wird untersucht. (Vorsicht, zeitaufwendig!)
\end{itemize}
\item mode==TW\_REDUCED\\
Die sehr zeitaufwendige Wegsuche für jeden möglichen Startpunkt bei 
zyklischen Funktionen kann in gutartigen Fällen drastisch verkürzt 
werden, wenn der feste Start- und Endpunkt aufgegeben wird. Dies 
geschieht durch Angabe von TW\_REDUCED. Es ist hier nicht mehr 
garantiert, dass sich ''der Kreis schließt''. Das bedeutet, dass eventuell 
eine Funktion nur einem Teil der anderen zugeordnet wird. 
Zusätzlich kann TW\_BIDIRECTIONAL angegeben werden. Dann erfolgt eine 
zusätzliche Suche in entgegengesetzter Richtung. In jedem Fall erfolgt 
die Wegsuche zyklisch.
\end{itemize}
\seealso{MatchObject}
}
\subsubsection{Objekt-Matching}
\proc{Trafo}{MatchObject}{(const Contur \&cont1,const Contur \&cont2,int tmode,double \&eval,int mmode=MM\_SQUARE,int anz=0)}
\procf{Trafo}{MatchObject}{(const Contur \&cont1,const Contur \&cont2,int tmode=TRM\_AFFINE)}
\procf{Trafo}{MatchObject}{(const Contur \&cont1,const Matrix \&pl2,int tmode,double \&eval,int mmode=MM\_SQUARE,int anz=0)}
\procf{Trafo}{MatchObject}{(const Contur \&cont1,const Matrix \&pl2,int tmode=TRM\_AFFINE)}
\procf{Trafo}{MatchObject}{(const Matrix \&pl1,const Matrix \&pl2,int tmode,double \&eval,int mmode=MM\_SQUARE,int anz=0)}
\procf{Trafo}{MatchObject}{(const Matrix \&pl1,const Matrix \&pl2,int tmode=TRM\_AFFINE)}
\procf{Trafo}{MatchObject}{(const Matrix \&pl1,const Contur \&cont2,int tmode,double \&eval,int mmode=MM\_SQUARE,int anz=0)}
\procf{Trafo}{MatchObject}{(const Matrix \&pl1,const Contur \&cont2,int tmode=TRM\_AFFINE)}
\descr{
Es wird eine Transformation (Klasse \see{Trafo}) ermittelt, die die Kontur 
$cont1$ in die Kontur $cont2$ überführt. 
Für den Standardfall $tmode$=TRM\_AFFINE wird eine affine
Transformation der Klasse $Trafo$ zurückgegeben. Für jeden Konturpunkt beider
Konturen werden aus Momenten affin invariante Merkmale berechnet und
dem Konturpunkt zugeordnet. Es wird die Abstandsmatrix aller Punkte der
einen zur anderen Kontur bezüglich dieser Invarianten berechnet. Bezüglich
dieser Abstandsmatrix werden mittels dynamischer Programmierung 
(\see{TimeWarp}) die Konturpunkte beider Konturen einander zugeordnet, 
es wird eine Liste von Punkt-Referenzen ermittelt. Aus dieser Liste 
wird die Transformation mittels der kleinsten Quadrate-Methode 
($mmode$=MM\_SQUARE, \see{MatchPointlists}) oder mit den kleinsten 
Absolutbeträgen (lineare Optimierung, $mmode$=MM\_LINEAR, 
\see{MatchPointlistsLinOpt}) ermittelt.\\
Die Bewertung des optimalen Weges in der Abstandsmatrix wird auf 
$eval$ zurückgeliefert und kann als Güte der Anpassung benutzt werden. \\
Wird die Methode der kleinsten Absolutbeträge benutzt, so kann die 
Rechenzeit wesentlich steigen. Durch $anz$ kann man vorgeben, wieviele
Konturpunkte in die Rechnung eingehen sollen, wobei $anz=0$ bedeutet, 
daß alle Konturpunkte benutzt werden. \\
Der gesamte Algorithmus ist äußerst robust gegenüber Störungen und 
Rauschen der Kontur. Auch Symmetrien
der Objekte haben keinen Einfluß auf die Güte. Der Algorithmus kann nur
versagen, wenn die Objekte nicht durch eine affine Transformation ineinander
überführbar sind, sondern z.B. durch starke projektive Verzerrungen.\\
Alternativ kann MatchObject auch mit Punklisten (Typ \see{Matrix}) aufgerufen 
werden. Dabei ist zu beachten, daß die Punkte in den Listen dicht 
liegen müssen, wie zum Beispiel in Listen, die durch Konvertierung 
aus Konturen entstanden sind.
}
\subsubsection{Winkelbestimmung von Objekten mit einer geschlossenen Kontur}
\procf{int}{OrientationMoments}{double moment[15],double \&angle}
\descr{Aus den (Flächen-)Momenten bis vierter Ordnung $moment[15]$ 
eines Objektes mit einer geschlossenen Kontur wird eine Orientierung 
berechnet. Zurückgegeben wird der Winkel $angle$ im Bogenmaß. 
Es werden zunächst die Momente zweiter Ordnung benutzt (Rückgabewert 1)
(Orientierung der Trägheitsellipse), wenn diese instabil sind 
(nahe dem Trägheitskreis) die Momente dritter Ordnung (Rückgabewert 2), 
wenn diese instabil sind, die Momente vierter Ordnung (Rückgabewert 3). 
Wenn alles instabil sein sollte, dann wird kein Winkel berechnet und 
es wird -1 zurückgegeben.  
}

\seealso{AffinFitMoments}
\seealsonext{MatchPointlists}
\seealsonext{MatchPointlistsLinOpt}

 
\newpage
\makeatletter{}\nsection{Graphen}{graph}

\subsection{Forest}
\hypertarget{Forest}{}
Die Klasse {\bf Forest} ist eine Repräsentation von Bäumen.
Jedes der {\bf n} Elemente einer zugrunde liegenden Menge sind in je genau 
einem Baum enthalten. Der Wald kann somit aus bis zu {\bf n} Bäumen 
bestehen, die dann jeder aus genau einen Knoten (Wurzel) bestehen. 
Das andere Extrem ist {\bf ein} Baum, der alle Knoten enthält. Die 
Elemente der zugrunde liegenden Menge werden über ihren Index 
(ganze Zahl von {\bf 0} bis {\bf n-1}) verwaltet. Jeder Knoten 
ausser der Wurzel hat einen Verweis auf den Vater.

\subsubsection{Konstruktoren}
\proch{}{Forest::Forest}{int n=0}{forest.h}
\descr{Legt einen Wald aus einer Menge mit $n$ Elementen an. Jedes Element 
ist Wurzel seines eigenen Baumes.}

\proch{int}{Forest::Reset}{int n}{forest.h}
\descr{Setzt einen Wald in den Ursprungszustand zurück wie im Konstruktor 
beschrieben.}

\subsubsection{Methoden}
\proch{int}{Forest::Size}{}{forest.h}
\descr{
Gibt die Anzahl der Elemente der zugrundeliegenden Menge des Waldes zurück.
}

\proch{int}{Forest::nTree}{bool ignoreZeroLengthTrees=false}{forest.h}
\descr{Gibt die Anzahl der Bäume des Waldes zurück. Ist $ignoreZeroLengthTrees$ wahr,
so werden Bäume ignoriert, die nur aus der Wurzel bestehen.
}

\proch{int}{Forest::getRefCount}{int x}{forest.h}
\descr{Zählt die zum Knoten $x$ gehörigen Kinder. Ist für Blätter von 
Bäumen gleich Null.}

\proch{int}{Forest::getNeighborCount}{int x}{forest.h}
\descr{Zählt die Zahl der Nachbarn des Knotens $x$.}

\proch{void}{Forest::setFather}{int x,int f=Forest::rootval}{forest.h}
\descr{
Setzt den Knoten $f$ als Vater des Knotens $x$ ein. Damit wird $x$ dem 
entsprechenden Baum zugeordnet. Der Defaultwert $Forest::rootval$ bewirkt, 
dass der Knoten keinen Vater besitzt und selbst zur Wurzel wird.
}

\proch{bool}{Forest::isRoot}{int x}{forest.h}
\descr{Gibt zurück, ob der Knoten $x$ Wurzel eines Baumes ist.}

\proch{bool}{Forest::isLeaf}{int x}{forest.h}
\descr{Gibt zurück, ob der Knoten $x$ ein Blatt ist. Eine Wurzel ist 
kein Blatt, auch wenn sie allein steht und somit keine Kinder hat.}

\proch{void}{Forest::makeRoot}{int x}{forest.h}
\descr{
Organisiert den zu $x$ gehörenden Baum derart um, dass $x$ die Wurzel wird.
}

\proch{int}{Forest::Father}{int x}{forest.h}
\descr{
Gibt den Index des Vaters des Knotens $x$ zurück. Wenn $x$ die Wurzel 
des Baumes ist, wird der Wert Forest::rootval zurückgegeben.
}

\proch{int}{Forest::Root}{int x}{forest.h}
\descr{
Ermittelt die Wurzel des Baumes, zu dem der Knoten $x$ gehört.
}

\proch{int}{Forest::Depth}{int x}{forest.h}
\descr{Ermittelt die Tiefe des Knotens $x$, das heisst die Zahl der Schritte
bis zur Wurzel.}

\subsection{Minimal aufspannender Baum}
\hyperref{MinTree}{}
Der minimal aufspannende Baum zu einer Punktmenge ist ein Baum, der alle Punkte 
als Knoten enthält und für den die Summe der Kantenlängen minimal ist. Um 
einen minimal aufspannenden Baum zu erzeugen, wird zunächst eine Instanz der
Klasse \class{MinTree} angelegt. Der Konstruktor erzeugt eine interne
Repräsentation des minimal auspannenden Baumes. Mit den Methoden 
von \class{MinTree} kann der Baum als \class{Forest} abgefragt werden.

\ctor{MinTree}{const \vector{Point} \&pointlist}{mintree.h}
\descr{Erzeugt einen minimal aufspannenden Baum zu den Punkten der 
Punktliste pointlist anhand der euklidischen Distanzen.}

\ctor{MinTree}{const \vector{\vector{double} } \&nodelist,
const VectorDistance \&vd = EuclideanVectorDistance()}{mintree.h}
\descr{Erzeugt einen minimal aufspannenden Baum zu den Knoten von
nodelist. Jeder Knoten ist durch einen Vektor von Merkmalen 
charakterisiert. Durch Vorgabe einer \class{VectorDistance} kann
eine beliebige Metrik verwendet werden.}
 
\ctor{MinTree}{const Matrix \&distances}{mintree.h}
\descr{Erzeugt einen minimal aufspannenden Baum zu Knoten, deren
Abstände in der Matrix distances vorgegeben sind (\see{DistanceMatrix}).}
 
\method{double}{getTree}{Forest \&f}
\descr{Speichert den ermittelten minimal aufspannenden Baum 
im \class{Forest} f.}

\method{double}{getForest}{Forest \&f, double maxlen}
\descr{Erzeugt aus dem minimal aufspannenden Baum einen Graphen,
der um alle Kanten länger als maxlen reduziert ist. Das Ergebnis wird 
in \class{Forest} f gespeichert. Dieser Graph besteht aus mehreren Bäumen.}

\method{double}{getCluster}{Forest \&f, int nCluster}
\descr{Erzeugt aus dem minimal aufspannenden Baum einen Graphen,
der durch Entfernen der längsten Kanten in nCluster Teilbäume
zerlegt ist. Das Ergebnis wird in \class{Forest} f gespeichert. 
Sind mehrere Kanten gleich lang, so können auch mehr als nCluster
Teilbäume entstehen, da bei Kanten gleicher Länge immer alle diese 
Kanten entfernt werden.}

\proch{double}{computeMinTree}{const vector$<$Point$>$ \&pointlist,Forest \&
tree,double maxlen=0.0}{mintree.h}
\procf{double}{computeMinTree}{const Matrix \&pointlist,Forest \& tree,double maxlen=0.0}
\descr{Für die Punkte der übergebene Liste $pointlist$ wird der minimal 
aufspannende Baum berechnet und auf $tree$ zurückgegeben. 
Mit dem Parameter $maxlen$ kann eine Grenze für die Länge der
Kanten angegeben werden. Das Ergebnis ist dann ein Wald, also mehrere Bäume. 
Ist $maxlen$ gleich 0 wird keine Schranke angenommen. 
Rückgabewert ist die Summe der Kantenlängen im Baum bzw. in den Bäumen.}

\proch{vector$<$vector$<$int$>$ $>$}{SplitToBranches}{Forest f}{mintree.h}
\descr{Zerlegt einen Baum in Äste. Äste sind Pfade zwischen 
Verzweigungspunkten. Ein Ast wird durch 
die Indizes der Knoten als vector$<$int$>$ beschrieben. Alle Äste werden 
dementsprechend als vector$<$vector$<$int$>$ $>$ zurückgegeben. Bäume in $f$, 
die nur aus einer Wurzel bestehen, werden ignoriert.}

\proch{int}{cutShortBranches}{Forest \&f,const vector$<$Point$>$ \&pointlist,double minlen}{mintree.h}
\procf{int}{cutShortBranches}{Forest \&f,const Matrix \&pointlist,double minlen}
\descr{
Beschneidet Zweige eines Baumes, die eine Länge unter $minlen$ aufweisen. Die 
abgeschnittenen Knoten werden in $f$ als Bäume ``der Länge Null'' geführt: 
Sie sind Wurzel eines Baumes ohne weiteren Punkt. 
}

\begprogr
\begin{verbatim}
// Erzeugung und Darstellung eines minimal aufspannenden Baumes 

   vector<Point> points; // Punktliste anlegen

   for (int i=0;i<n;i++)
       points.push_back(Point(x,y)); // Punkte an Punktliste anhängen

   Forest mintree;  
   MinTree(points,mintree); // minimal aufspannenden Baum ermitteln
   
   for (int i=0;i<mintree.Size();i++)
    {
      int father = mintree.Father(i); // Vater des aktuellen Knotens
      if (father != Forest::rootval) // Knoten ist nicht die Wurzel
      {
        Line(points[i],points[father],2,pic); // Verbindung einzeichnen
      }
    }
// Analyse der Äste des Baues
   vector<vector<int> > branches=SplitToBranches(mintree);

   for (int i=0;i<branches.size();i++)  // für alle Äste
     {
       for (int j=1;j<branches[i].size();j++) // alle Kanten des Astes        
         {
            Line(points[branches[i][j-1]],points[branches[i][j]],i,pic);
         }
     }

\end{verbatim}
\endprogr

\subsection{Dijkstra}
Der Algorithmus von Dijkstra sucht einen Pfad mit minimalen Kosten in 
einem Graphen. In bezug auf Bilder wird der Nachbarschaftsgraph für die
8er-Nachbarschaft verwendet und die Kosten entsprechen der Grauwertsumme 
auf dem Pfad.

\proch{\bsee{Contur}}{Dijkstra}{const Image \&img,\bsee{IPoint} s,IPoint e}{dijkstra.h}
\descr{
Bestimmt einen Pfad mit minimalen Kosten im Bild $img$ zwischen Startpunkt s 
und Zielpunkt $e$ und gibt diesen als \bsee{Contur} zurück.
}

\proch{Contur}{Dijkstra}{const Image \&img,IPoint s,Image \&e}{dijkstra.h}
\descr{
Bestimmt einen Pfad mit minimalen Kosten im Bild $img$ zwischen Startpunkt s 
und einem in $e$ markierten Punkt und gibt diesen als \bsee{Contur} zurück. Das 
Bild $e$ muss die gleiche Größe wie $img$ haben und die möglichen Endpunkte müssen 
einen Wert ungleich Null besitzen. Nach Ablauf von Dijkstra stehen in dem Bild $e$ 
die Richtungskodes der untersuchten Pfade.
}

\begprogr
\begin{verbatim}
// Ermittlung und Darstellung eines optimalen Pfades mit Dijkstra

   Image img;
   Image mrk;
   ...
   Contur res=Dijkstra(img,IPoint(5,5),IPoint(225,225));
   MarkContur(c,1,mrk);
   ...
   ClearImg(mrk);
   Line(555,4,666,500,1,mrk); // "ausgedehntes" Ziel
   res=Dijkstra(img,IPoint(5,5),mrk);
   ClearImg(mrk);
   MarkContur(c,1,mrk);

\end{verbatim}
\endprogr

\subsection{Delaunay-Triangulation}
Die Delaunay-Triangulation einer Punkt-Menge erfolgt mittels der Klasse
\class{Delaunay}. Die Konstruktion der Klasse mittels einer Punktmenge als 
\verb+vector<Point>+ führt die Triangulation aus. Danach kann mittels der 
weiteren Methoden das Ergebnis in verschiedenen Formen abgefragt werden 
und mittels Delaunay::draw gezeichnet werden.

\subsubsection{Konstruktoren}
\proch{}{Delaunay::Delaunay}{\vector{Point} \&nodesp}{delaunay.h}
\descr{Konstruiert einen Delaunay-Graphen mit den übergebenen Punkten 
als Ecken.}

\proch{}{Delaunay::Delaunay}{const PolygonalCurve \&curv}{delaunay.h}
\descr{Konstruiert einen Delaunay-Graphen aus den Eckpunkten einer
geschlossenen polygonalen Kurve (\class{PolygonalCurve}) oder einem 
Polygon (\class{Polygon}).
}

\subsubsection{Ergebnis-Abfrage}
Die Ergebnisse werden als Liste von Kanten beziehungsweise Dreiecken 
bereitgestellt. Dabei gibt es jeweils Varianten, die dies als 
geometrisches Objekt oder über die Indizes der Knoten in der 
originalen Punktliste bereitstellen. Optional kann die Ausgabe dabei
auf Kanten und Dreiecke beschränkt werden, deren Kantenlänge ein übergebenes
Limit nicht übersteigt. Wird das Limit nicht angegeben oder ist dessen
Wert kleiner gleich Null, so erfolgt keine Bschränkung.

\proch{void}{Delaunay::getTriangles}{\vector{Triangle} \&output, double limit = -1}{delaunay.h}
\descr{Die Dreiecke werden als Vektor von \class{Triangle} zurückgegeben.}

\proc{void}{Delaunay::getTrianglesI}{\vector{\vector{int}} \&output, double limit = -1}
\descr{Die Indizes der Eckpunkte jedes Dreiecks in der Originalpunktliste
werden als \vector{int} mit 3 Elementen zurückgegeben, alle Dreiecke bilden 
demnach einen \vector{\vector{int}}.
}

\proch{void}{Delaunay::getEdges}{\vector{LineSeg} \&output, double limit = -1}{delaunay.h}
\descr{Die Kanten werden als Vektor von \class{LineSeg} zurückgegeben.}

\proch{void}{Delaunay::getEdgesI}{\vector{\vector{int}} \&output, double limit = -1}{delaunay.h}
\descr{Die Kanten werden durch die Indizes ihrer Endpunkte in der 
Originalpunktliste in einem \vector{int} der Länge 2 beschrieben. Alle Kanten
bilden demnach einen \vector{\vector{int}}.}

\proch{void}{Delaunay::getRegion}{Region \&region, double limit = -1}{delaunay.h}
\descr{Die Fläche der Triangulation = die Fläche aller Dreiecke wird
als Region bereitgestellt. Ohne Beschränkung durch limit ist dies
die konvexe Hülle.}

\proch{void}{Delaunay::draw}{const Image \&img, int edgeValue = 1, int fillValue = -1, double limit = -1}{delaunay.h}
\descr{Stellt die Triangulation im Bild img dar. Die Kanten werden mit dem Wert
edgeValue, die Fläche der Dreiecke mit fillValue gezeichnet. Werden diese
Werte mit negativen Werten angegeben, erfolgt keine Darstellung.}

 
 
\newpage
\makeatletter{}\nsection{Grafik}{graphics}

\subsection{Zeichnen}
\subsubsection{Grafische Primitiva}

\proc{int}{Marker}{int mode, int x,int y,int val,int size,Image img}
\procf{int}{Marker}{int mode, const IVector \&p,int val,int size,Image img}
\procf{int}{Marker}{int mode, const Point \&p,int val,int size,Image img}
\descr{
In das Bild $img$ wird an der Stelle $(x,y)$ ein Markierungspunkt mit dem Wert
$val$ und der Größe $size$ eingetragen. Die Form der Markierung wird durch
$mode$ festgelegt.}
\begin{quote}
\begin{tabular}{ll}
DEFAULT&senkrechtes Kreuz\\
1&      schräges Kreuz\\
2&      leerer Kreis\\
3&      voller Kreis\\
4&      leeres achsparalleles Quadrat\\
5&      volles achsparalleles Quadrat\\
6&      leeres schräges Quadrat\\
7&      volles schräges Quadrat\\
\end{tabular}
\end{quote}

\proc{int}{Text}{const string \&s,IPoint p,int val,int exp,Image \& img}
\proc{int}{Text}{const string \&s,int x,int y,int val,int exp,Image \& img}
\proc{int}{Text}{const char *s,int x,int y,int val,int exp,Image \& img}
\descr{
In das Bild $img$ wird der Text $s$ mit dem Wert $val$ eingetragen.
Die linke obere Ecke des Textes liegt auf dem gegebenen Punkt.
Der Parameter $exp$ ($0 \le exp \le 4$) bewirkt eine Vergrößerung des
Textes um $2^{exp}$.
}

\subsubsection{Zeichnen geometrischer Figuren}

\proc{int}{Line}{int x1,int y1,int x2,int y2,int val,int mode,Image img}
\procf{int}{Line}{int x1,int y1,int x2,int y2,int val,Image img}
\procf{int}{Line}{const IVector \&p1,const IVector \&p2,int val,int mode,Image
img}
\procf{int}{Line}{const IVector \&p1,const IVector \&p2,int val,Image img}
\procf{int}{Line}{const Point \&p1,const Point \&p2,int val,int mode,Image img}
\procf{int}{Line}{const Point \&p1,const Point \&p2,int val,Image img}
\descr{
In das Bild $img$ wird mit dem Wert $val$ ein Geradensegment von $(x1,y1)$ 
bis $(x2,y2)$ ($mode$=DEFAULT) bzw. eine Gerade durch die beiden Punkte 
($mode$=1) gezeichnet. Alternativ können die Punkte als \see{Point} oder
als Integer-Vektoren vom Typ \see{IVector} angegeben werden.}
\proc{int}{HesseLine}{double p,double phi,int val,Image img}
\procf{int}{HesseLine}{const Vector \&p,int val,Image img}
\descr{
In das Bild $img$ wird mit dem Wert $val$ eine Gerade gezeichnet, deren
Hessesche Normalform die Parameter $p$ und $phi$ hat. Alternativ können die
Parameter p und phi als 2-elementiger Vektor vom Typ \see{Vector} angegeben 
werden.}
\proc{int}{DrawCircle}{double par[3],int val1,int val2,int mode,Image img}
\descr{
In das Bild $img$ wird der Kreis mit dem Mittelpunkt $(par[0],par[1])$ und dem Radius
$par[2]$ mit $val1$ gezeichnet. Für $mode$=DEFAULT wird die Kreisfläche mit dem
Wert $val2$ gefüllt. Bei $mode$=NOFILL wird nur der Kreis gezeichnet und der
Parameter $val2$ ist redundant.}
\proc{int}{DrawEllipse}{double par[5],int val1,int val2,int mode,Image img}
\descr{ 
In das Bild $img$ wird mit dem Wert $val1$ eine Ellipse gezeichnet mit dem
Mittelpunkt $(par[0],par[1])$, den Halbachsen $par[2]$ bzw. $par[3]$ und einer Drehung um den
Winkel $par[4]$. Für $par[4]=0$ ist die Halbachse $par[2]$ parallel zur x-Achse. Wenn
$mode$=DEFAULT ist, wird die Ellipse mit dem Wert $val2$ gefüllt. Bei
$mode$=NOFILL wird nur die Ellipse gezeichnet und der Parameter $val2$ ist
redundant.}
\proc{void}{DrawSuperEllipse}{double c, double tr[3][3], int val,Image img}
\descr{ 
In das Bild $img$ wird mit dem Wert $val$ eine SuperEllipse gezeichnet. Der
Wert $c$ ist der Exponent in Zentrallage und $tr[3][3]$ ist eine affine
Transformation zur Abbildung der Zentrallage.}

\proc{int}{DrawCircleSegment}{double par[5],int val1,int val2,int mode,Image img}
\descr{Wie \bsee{DrawCircle}, es wird aber nur das Segment vom Winkel 
$par[3]$ bis zum Winkel $par[4]$ gezeichnet.}
\proc{int}{DrawEllipseSegment}{double *par[7],int val1,int val2,int mode,Image img}
\descr{Wie \bsee{DrawEllipse}, es wird aber nur das Segment vom Winkel 
$par[5]$ bis zum Winkel $par[6]$ gezeichnet.}
\proc{void}{DrawPolygon}{PointList pl,int val,Image img}
\descr{
Die Punktliste $pl$ wird als Folge von Eckpunkten eines Polygons interpretiert
und mit dem Wert $val$ in das Bild $img$ eingezeichnet.
}

\subsubsection{Geometrische Figuren als Konturen}

\proc{Contur}{LineContur}{Contur c,int p1[2][,int p2[2]]}
\descr{
Ablegen eines Geradensegmentes als Kontur. Es ist ein zwei- und ein
dreiparametriger Aufruf vorgesehen. Wird für $c$ der NULL-Pointer verwendet,
so wird intern eine neue Kontur angelegt. Die Funktion gibt den Pointer auf
diese neue Kontur zurück. In ihr wird eine Kontur von $p1$ nach $p2$ abgelegt
(dreiparametriger Aufruf). Existiert die Kontur $c$ bereits ($c$!=NULL) so sind
für diesen Funktionsaufruf nur zwei Parameter relevant ($p2$ redundant).
An die Kontur $c$ wird eine Linienkontur vom Endpunkt der alten Kontur nach
$p1$ angefügt. Der Pointer auf die neue Kontur wird als Funktionswert zurückgegeben. 
}
\proc{Contur}{CircleContur}{double par[3]}
\descr{
Es wird eine geschlossene Kontur angelegt, die einen Kreis mit dem Radius $par[2]$
um den Punkt $(par[0],par[1])$ beschreibt. Die Parameter sind so zu
wählen, daß alle Konturpunkte positive Koordinaten haben. Bei erfolgreicher
Ausführung wird der Pointer auf die Kreiskontur zurückgegeben, im Fehlerfall
der NULL-Pointer.
}
\proc{Contur}{EllipseContur}{double par[5]}
\descr{
Es wird eine geschlossene Kontur angelegt, die eine Ellipse mit dem
Mittelpunkt $(par[0],par[1])$, den Halbachsen $par[2]$ bzw. $par[3]$ und einer Drehung um den
Winkel $par[4]$ beschreibt. Für $par[4]=0$ ist die Halbachse $par[2]$ parallel zur x-Achse.
}
\proc{Contur}{CircleSegmentContur}{double par[5]}
\descr{
Es wird eine Kontur angelegt, die ein Segment eines Kreises mit dem Radius $par[2]$
um den Punkt $(par[0],par[1])$ beschreibt. Das Segment beginnt bei dem Winkel $par[3]$,
endet bei dem Winkel $par[4]$ und verläuft im positiven Drehsinn. Der Betrag der
Differenz zwischen den beiden Winkeln $par[3]$ und $par[4]$ darf nicht größer
als $2\pi$ sein.
}
\proc{Contur}{EllipseSegmentContur}{double par[7]}
\descr{
Es wird eine Kontur angelegt, die ein Segment einer Ellipse mit dem
Mittelpunkt $(par[0],par[1])$, den Halbachsen $par[2]$ bzw. $par[3]$ und einer Drehung um den
Winkel $par[4]$ beschreibt. Für $par[4]=0$ ist die Halbachse $par[2]$ parallel zur
x-Achse. Das Segment beginnt bei dem Winkel $par[5]$, endet bei dem Winkel
$par[6]$ und verläuft im positiven Drehsinn. Der Betrag der Differenz zwischen
den beiden Winkeln $par[5]$ und $par[6]$ darf nicht größer als $2\pi$ sein.
}

\subsubsection{Zeichnen von Kurven und Flächen}

\proc{int}{MarkContur}{Contur c,int val,Image img}
\descr{
Die Kontur $c$ wird mit dem Wert $val$ in das Bild $img$ eingezeichnet.
}
\proc{int}{FillRegion}{Contur c,int val,Image img}
\descr{
Die durch die {\em geschlossene} Kontur $c$ eingeschlossene Fläche wird mit
dem Wert $val$ im Bild $img$ gefüllt.
}

\subsection{Interaktive Zeichenfunktionen}

Zur Benutzung der interaktiven Zeichenfunktionen muß das zughörige Bild
visualisiert werden.

\proch{\bsee{LineSeg}}{SelLine}{Image img}{polygon\_vis.h}
\procf{int}{SelLine}{Image img,\bsee{IPoint} \&p1,IPoint p2}
\procf{int}{SelLine}{Image img,int p0[2],int p[2]}
\descr{
Interaktive Selektion einer Linie durch Auswahl der Endpunkte mit der Maus.
Abbruch durch Drücken einer Maustaste. Der Rückgabewert hängt von der zum 
Abbruch gedrücken Maustaste ab:
Links 1, Mitte 0, Rechts -1. Übrige Funktionalität wie bei \see{SelPoint}.
}


\proch{Contur}{SelContur}{Image img,int force\_close=FALSE}{contool\_vis.h}
\descr{
Interaktives Zeichnen einer Kurve mit der Maus. Bei erstmaliger 
Betätigung der linken Maustaste wird der Startpunkt der Kontur 
festgelegt. Bei gedrückter linker Maustaste kann ``gezeichnet''
werden. Wenn die Maus bewegt wird, ohne daß eine Taste gedrückt
ist, wird ausgehend vom aktuellen Endpunkt der Kontur ein 
Liniensegment ``aufgezogen'', das durch Drücken der linken 
Maustaste bestätigt wird. Es besteht die Möglichkeit, das 
Selektieren der Kontur ohne Schließen (Betätigen der rechten
Maustaste) bzw. mit Schließen der Kontur (Betätigen der linken 
und rechten Maustaste) zu beenden. Ist der Parameter $force\_close$
auf TRUE gesetzt, so wird die Kontur immer geschlossen, indem
an die selektierte Kontur eine geradlinige Verbindung mit dem 
Startpunkt angehängt wird.
}

 
\newpage
\makeatletter{}\nsection{Numerik}{numeric}
\subsection{Allgemeine numerische Hilfsmittel}

\proch{int}{limited}{int val,int min,int max}{util.h}
\descr{Gibt $val$ zurück, wenn $val$ im Interval $min..max$ liegt. Gibt $min$
zurück, wenn $val<min$ und gibt $max$ zurück, wenn $val>max$.}

\proch{int}{limited}{int val,Image img}{util.h}
\descr{Beschränkt einen Wert auf den Wertebereich des Bildes $img$.
Gibt $val$ zurück, wenn $val$ im Interval $0..img->maxval$ liegt. Gibt $0$
zurück, wenn $val<0$ und gibt $img->maxval$ zurück, wenn $val>img->maxval$.}

\proc{double}{Sqr}{double val}
\descr{Quadratberechnung}
\proc{double}{Cub}{double val}
\descr{Dritte Potenz}
\proc{double}{CubRoot}{double val}
\descr{Dritte Wurzel}

\proc{double}{Arcus}{double degree}
\descr{Umrechnung Gradmaß  Bogenmaß}
\proc{double}{Degree}{double arc}
\descr{Umrechnung Bogenmaß  Gradmaß}

\proc{int}{Sign}{int val}
\descr{Vorzeichen von Integer-Zahlen}
\proc{double}{SignD}{double val}
\descr{Vorzeichen von Double-Zahlen}

\proc{int}{Max}{int val1,int val2}
\descr{Maximum zweier Integer-Zahlen}
\proc{int}{Min}{int val1,int val2}
\descr{Minimum zweier Integer-Zahlen}
\proc{double}{MaxD}{double val1,double val2}
\descr{Maximum zweier Double-Zahlen}
\proc{double}{MinD}{double val1,double val2}
\descr{Minimum zweier Double-Zahlen}

\proc{int}{MulDiv}{int val1,int val2,int val3}
\descr{Berechnung von $val1\cdot val2 \over val3$, wobei durch die
Multiplikation der Wertebereich von int überschritten werden darf. Diese Funktion
wird auf Systemen, wo dies möglich ist, optimiert implementiert und ist einer
Konvertierung zu Typen mit größerem Zahlenbereich stets vorzuziehen.}

\proc{int}{Mod}{int val,int mod}
\descr{Berechnet den Modulo-Wert von $val$ bezüglich $mod$. 
Im Unterschied zum C-Operator \% ist das Ergebnis
stets positiv im Intervall $ 0 \le result < abs(mod) $.}

\proc{double}{FMod}{double val,double mod}
\descr{Berechnet den Modulo-Wert von $val$ bezüglich des absoluten 
Betrags von $mod$. Im Unterschied zu der C-Funktion $fmod$ ist das Ergebnis
stets positiv ($ 0 \le result < fabs(mod) $).}

\proc{double}{Round}{double val}
\descr{Berechnet die nächste (gerundete) ganze Zahl (vom Typ double)}

Die folgenden Funktionen dienen der Konvertierung von double-Werten in int mit
Rundung. Diese Funktionen werden auf die jeweiligen Systeme optimiert und sind
Lösungen mit floor usw. vorzuziehen, solange die Sprachstandards dies nicht
besser definieren.

\proc{int}{RoundInt}{double val}
\descr{Berechnet die nächste (gerundete) ganze Zahl (vom Typ int)}
\proc{void}{RoundInt}{double val,int \&i}
\descr{Speichert in $i$ die nächste (gerundete) ganze Zahl zu $val$}

\proch{double}{GammaFunction}{double x}{numbase.h}
\descr{Die Gamma-Funktion}

\subsection{Analytische Geometrie}
\subsubsection{Analytische Geometrie der Ebene}

\proch{double}{Distance}{double x1,double y1,double x2,double y2}{analygeo.h}
\descr{Ermittelt den Euklidischen Abstand der Punkte $(x1,y1)$ und $(x2,y2)$.}

\proc{double}{Distance}{\bsee{IPoint} p1,IPoint p2}
\descr{Ermittelt den Euklidischen Abstand der Punkte $p1$ und $p2$.}

\proc{double}{Distance}{\bsee{Point} p1,Point p2}
\descr{Ermittelt den Euklidischen Abstand der Punkte $p1$ und $p2$.}

\proch{void}{ConvCartesPolar}{double x,double y,double \&rad,double \&arc}{analygeo.h}
\procf{void}{ConvCartesPolar}{double p[2],double *rad,double *arc}
\descr{
  Konvertierung von kartesischen in Polarkoordinaten
}

\proc{void}{ConvPolarCartes}{double rad,double arc,double \&x,double \&y}
\procf{void}{ConvPolarCartes}{double rad,double arc,double p[2]}
\descr{
  Konvertierung von Polarkoordinaten in kartesische Koordinaten
}

\proc{int}{ConvPointHesse}{double p1[2],double p2[2],double *p,double *phi}
\procf{\bsee{Vector}}{ConvPointHesse}{const \bsee{Vector} \&p1,const \bsee{Vector} \&p2}
\descr{
  Es werden die Parameter der Hesseschen Normalform 
$x \cdot cos(\varphi)+y \cdot sin(\varphi)=p$
der Geraden durch die Punkte $p1$ und $p2$ berechnet.
In der zweiten Form werden die Punkt-Koordinaten als Vektor (\see{Vector})
  angegeben und die Parameter der Hesseschen Normalform werden als
  Rückgabewert vom Typ \bsee{Vector} bereitgestellt.
}

\proc{void}{RotTransPoint}{double p1[2],double centre[2],double arc,double p2[2]}
\descr{
  Der Punkt $p2$ ergibt sich aus der Rotation des Punktes $p1$ mit dem
  Winkel $arc$ um das Rotationszentrum $centre$.
}

\proc{double}{DistPointLine}{double r[2],double p,double phi}
\descr{
  Es wird der Abstand des Punktes $r$ von der Geraden mit den Parametern
  $p$ und $phi$ berechnet.
}

\proc{double}{ClosestPointLineSeg}{double p[2],double ls0[2],double
  ls1[2],double pf[2]}
\descr{
  Es wird der Punkt der Strecke $(ls0,ls1)$ mit dem geringsten Abstand zum
  Punkt $p$ berechnet und auf $pf$ zurückgegeben. Rückgabewert der Funktion
  ist der Abstand von $p$ und $pf$.
}

\proc{double}{DistPointCircle}{double p[2],double par[3]}
\descr{
 Es wird der Abstand des Punkte $p$ zu einem Kreis mit dem Mittelpunkt
 $(par[0],par[1])$ und dem Radius $par[2]$ berechnet.
}

\proc{double}{DistPointEllipse}{double p[2],double par[5],double koord[2]}
\descr{Abstand des Punktes $p$ von einer Ellipse mit dem Mittelpunkt 
$(par[0],par[1])$, den Halbachsen $par[2]$ und $par[3]$ und 
der Drehung $par[4]$. Auf $koord$ stehen die Koordinaten des Punktes auf der
Ellipse, der zum gegebenen Punkt p minimalen Abstand hat. Der Parameter
koord  kann wahlweise geschrieben werden.}

\proc{int}{IntersecLine}{double p1,double phi1,double p2,double phi2,double p[2]}
\descr{Der Schnittpunkt zweier Geraden mit den Parametern $p1$ und $phi1$
bzw. $p2$ und $phi2$ wird berechnet.}

\proc{int}{TangentCircle}{double p[2],double par[3],double p1[2],double p2[2]}
\descr{Die Berührungspunkte der Tangenten von dem Punkt $p$ an einen Kreis mit dem Mittelpunkt
$(par[0],par[1])$ und dem Radius $par[2]$ werden berechnet.}

\proc{double}{AreaPolygon}{PointList pl}
\procf{double}{AreaPolygon}{const \bsee{Matrix} \&pl}
\descr{
Die Fläche eines Polynoms, dessen Eckpunkte in der Punktliste $pl$ bzw. 
\bsee{Matrix} $pl$ stehen, wird berechnet.
}

\proc{int}{FeatureQuadrFunc}{double koeff[6],double par[5],int *type}
\descr{
  Es werden geometrische Parameter der quadratischen Form $koeff[0] \cdot x^2
  + koeff[1] \cdot y^2 + koeff[2] \cdot x + koeff[3] \cdot y + koeff[4] \cdot
  xy +koeff[5] = 0$ berechnet und auf $par$ bereitgestellt. Der Typ der
  quadratischen Form wird auf $type$ bereitgestellt. Dafür sind die Konstanten
  ELLIPSE, HYPERBEL, PARABEL und DEGENERATE (Entartung zu Geraden) definiert.
  Die Parameter $par$ haben die folgende Reihenfolge: Mittelpunktkoordinaten,
  Achsenparameter (Ellipse: große Halbachse, kleine Halbachse; Hyperbel:
  reelle halbachse, imaginäre Halbachse; Parabel: Halbparameter = Abstand des
  Brennpunktes zur Leitlinie), Drehwinkel bezüglich der Normallage.
}

\proc{int}{ParamQuadrFunc}{double par[5],int type,double koeff[6]}
\descr{
  Aus den geometrischen Parametern $par$ eines Kegelschnittes werden die
  Koeffizienten der zugehörigen quadratischen Form berechnet. Der Typ des
  Kegelschnittes wird durch $type$=(ELLIPSE, HYPERBEL, PARABEL) festgelegt.
  Die geometrischen Parameter haben die folgende Reihenfolge:
  Mittelpunktkoordinaten, Achsenparameter (Ellipse: große Halbachse, kleine
  Halbachse; Hyperbel: reelle halbachse, imaginäre Halbachse; Parabel:
  Halbparameter = Abstand des Brennpunktes zur Leitlinie), Drehwinkel
  bezüglich der Normallage.
}

\proc{int}{InvarFivePoint2d}{double p[5][2],double *i1,double *i2}
\descr{
Für die fünf 2D-Punkte des Feldes $p$ werden die zwei projektiven Invarianten
$i1$ und $i2$ berechnet, indem Doppelverhältnisse der Flächen von Dreiecken
berechnet werden, die von jeweils drei der fünf Punkte gebildet werden.
}

\subsubsection{Analytische Geometrie des Raumes}

\proch{double}{Distance}{const \bsee{Point3d} \&p1,const \bsee{Point3d} \&p2}{analygeo3d.h}
\descr{Berechnet den Abstand zweier Raumpunkte}

\proch{double}{Distance}{const \bsee{Point3d} \&p,const \bsee{Line3d} \&l}{analygeo3d.h}
\procf{double}{Distance}{const \bsee{Line3d} \&l,const \bsee{Point3d} \&p}
\descr{Berechnet den Abstand eines Raumpunktes von einer Raumgeraden.}

\proch{double}{Distance}{const \bsee{Line3d} \&l1,const \bsee{Line3d} \&l2}{analygeo3d.h}
\descr{Berechnet den Abstand zweier Geraden im Raum.}

\proch{int}{Intersection}{const \bsee{Line3d} \&l1,const \bsee{Line3d} \&l2,\bsee{Point3d}
\&p,double \&dist,\bsee{Vector} \&res}{analygeo3d.h}
\procf{int}{Intersection}{const \bsee{Line3d} \&l1,const \bsee{Line3d} \&l2,\bsee{Point3d}
\&p,double \&dist}
\procf{int}{Intersection}{const \bsee{Line3d} \&l1,const \bsee{Line3d} \&l2,\bsee{Point3d} \&p}
\descr{Berechnet den Schnittpunkt $p$ der Geraden $l1$ und $l2$. Falls der
Schnittpunkt nicht existiert, wird der beiden Geraden am nächsten liegende
Punkt zurückgegeben. Die Variable $dist$ ist der Abstand des Punktes zu beiden
Geraden. Dieser Wert ist 0, falls der Schnittpunkt existiert. Der Vektor $res$
enthält die Parameter der Lage der dem Punkt $p$ am nächsten gelegenen 
Punkte auf den Geraden in Parameterdarstellung \see{Line3d}.}

\proch{int}{Intersection}{const \bsee{Line3d} \&l,const \bsee{Sphere} \&s,\bsee{Point3d}
\&p1,\bsee{Point3d} \&p2}{analygeo3d.h}
\descr{Berechnet die Schnittpunkte $p1$ und $p2$ der Geraden $l$ und der Kugel
$s$. Existiert kein Schnittpunkt wird $NO\_INTERSECTION$ zurückgegeben,
existiert nur ein Schnittpunkt $TANGENT$, sonst (bei Erfolg) $OK$.}

\proc{int}{InvarFivePoint3d}{double p[5][3],double *i1,double *i2}
\descr{
Für die fünf 3D-Punkte des Feldes $p$ werden die zwei projektiven Invarianten
$i1$ und $i2$ berechnet, indem Doppelverhältnisse der Flächen von Dreiecken
berechnet werden, die von jeweils drei der fünf Punkte gebildet werden. Es
wird vorausgesetzt, daß die fünf Punkte koplanar sind.
}

\proc{int}{ConvR3PointHesse}{double p1[3],double p2[3],double p3[3],double *p,double n[3]}
\descr{
Für eine Raumebene durch die drei Punkte $p1,p2,p3$ wird der Abstand
$p$ zum Ursprung und der Normalenvektor $n$ bestimmt.
}
\proc{double}{DistR3PointLine}{double p[3],double p0[3],double dir[3]}
\descr{
Es wird der Abstand des Punktes $p$ zu der in Parameterform
$g=p0+\lambda dir$ gegebenen Geraden bestimmt.
}
\proc{double}{DistR3PointPlane}{double p[3],double r,double n[3]}
\descr{
Es wird der Abstand des Punktes $p$ zu der durch den Abstand $r$ vom Ursprung
und den Normalenvektor $n$ gegebenen Ebene bestimmt.
}



\subsection{Nullstellen von Polynomen}

\proc{int}{Root2}{double p1,p0,Complex *cptr1,*cptr2}
\descr{
Die Nullstellen des Polynoms $x^2+p1 x + p0=0$ werden berechnet und auf
den komplexen Variable $cptr1$ und $cptr2$ bereitgestellt.
}
\proc{int}{Root3}{double p2,p1,p0,Complex c[3]}
\descr{
Die Nullstellen des Polynoms $x^3+p2 x^2+p1 x + p0=0$ werden analytisch
berechnet.
}
\proc{int}{Root4}{double p3,p2,p1,p0,Complex c[4]}
\descr{
Die Nullstellen des Polynoms $x^4+p3 x^3+p2 x^2+p1 x + p0=0$ werden analytisch
berechnet.
}

\proch{int}{Bairstow}{const \bsee{Vector} \&para,\bsee{Matrix}\& result,int inumber = 1000}{bairstow.h}
\descr{Berechnet die Nullstellen eines Polynomes beliebigen Grades. Die
Koeffizienten $a_0,a_1..$ des Polynoms werden als Vektor $para$ übergeben. 
Die komplexen Nullstellen werden zeilenweise in der \bsee{Matrix} $result$ abgelegt (Real-,Imaginärteil).}

\subsection{Ableitungen und bestimmte Integrale}

\proc{int}{DeriveFunc}{FuncD func,int dim,int i,double *x,double h,int mode,double *val}
\descr{
Die partielle Ableitung $val$ der mehrdimensionalen Funktion $func$
nach der $i$-ten Unbekannten $(i=0,\dots,dim-1)$ wird an der Stelle $x$ numerisch
berechnet. $h$ gibt den Abstand der Stützstellen vor, durch $mode$ kann die
Auswahl der Stützstellen beeinflußt werden:\\
$mode=0:\qquad  (x_i-2h,x_i-h,x_i,x_i+h,x_i+2h)$\\
$mode=1:\qquad  (x_i-h,x_i,x_i+h,x_i+2h,x_i+2h)$\\
$mode=2:\qquad  (x_i-h,x_i,x_i+h)$\\
$mode=3:\qquad  (x_i,x_i+h,x_i+2h,x_i+3h)$\\
$mode=4:\qquad  (x_i,x_i+h,x_i+2h)$\\
$mode=5:\qquad  (x_i,x_i+h)$
}
\proc{int}{Derive2Func}{FuncD func, int dim,int i,double *x,double h,int mode,double *val}
\descr{
Die zweite partielle Ableitung $val$ der mehrdimensionalen Funktion $func$
nach der $i$-ten Unbekannten $(i=0,\dots,dim-1)$ wird an der Stelle $x$ numerisch
berechnet. Es werden die Stützstellen $(x_i-2h,x_i-h,x_i,x_i+h,x_i+2h)$ verwendet.
}
\proc{int}{IntegrateFunc}{FuncD func,double s1,double s2,double *prec,double *val}
\descr{
Die Funktion $func$ wird im Intervall $[s1,s2]$ mit der Genauigkeit $prec$
numerisch integriert (Romberg-Integration).
}

 
\newpage
\makeatletter{}\nsection{Allgemeine Werkzeuge}{genericTools}

\subsection{String-Funktionen}

\proc{string}{NumberString}{int i,unsigned int width=0}
\procf{string}{NumberString}{unsigned int i,unsigned int width=0}
\procf{string}{NumberString}{long int i,unsigned int width=0}
\procf{string}{NumberString}{long long int i,unsigned int width=0}
\procf{string}{NumberString}{double f,unsigned int width=0,unsigned int
  prec=0}
\descr{Gibt einen String zurück, der den übergebenen Wert in Textform
  darstellt. Sind die Werte von $width$ oder $prec$ ungleich Null, so wird die
  Ausgabe entsprechend dieser Werte formatiert.}

\proc{int}{Integer}{const string\& s}
\descr{Wandelt den übergebenen String $s$ nach Integer (int).}

\proc{double}{Double}{const string \&s}
\descr{Wandelt den übergebenen String $s$ nach double.}

\proc{string}{lowercase}{const string \&s}
\proc{string}{uppercase}{const string \&s}
\descr{Wandelt die Buchstaben des übergebenen Strings $s$ in Klein-
  bzw. Großbuchstaben um.}

\proch{string}{Split}{string \&text,const string \&del,int erase=true,
int need\_del=false}{strtool.h}
\descr{Die Funktion spaltet vom gegebenen String $text$ von vorne einen
 Teilstring ab und gibt diesen zurück, der durch den Begrenzer $del$ 
abgegrenzt wird. Ist $erase = true$ (Standard), so wird $text$ um den 
abgespalteten Text und den Begrenzer gekürzt. Kommt der Begrenzer $del$ 
im String $text$ nicht vor, so wird bei $need\_del=false$ (Standard) der 
gesamte restliche String zurückgegeben, bei $need\_del=true$ wird in diesem
Fall nichts abgespalten.}

\proch{string}{SplitFilename}{const string \&fullname,string \&path,string \&basename,string \&ext}{strtool.h}
\procf{string}{SplitFilename}{const string \&fullname,string \&path,string \&filename}
\descr{Die Funktion spaltet den gegebenen Namen einer Datei in Pfad (Verzeichnis) 
und Dateinamen auf. Wird der Parameter $ext$ angegeben wird der Dateinamen in
den Basisnamen (ohne Erweiterung) und die Dateierweiterung aufgespalten. 
Die Trennzeichen '/' am Ende des Pfades und '.' zwischen Dateinamen und Erweiterung
gehören nicht zu den Ergebnis-Zeichenketten.}

\subsection{Alphanumerische Bildschirmsteuerung}

Für ICE-Implementierungen unter X11 und MS-Windows steht ein
terminalähnliches Textfenster zur Verfügung, an das auch dann Eingaben
weitergeleitet werden, wenn das ICE-Grafikdisplayfenster den Focus hat. Damit
sind Anwendungsprogramme mit einem einfachen Nutzerinterface, das sich auf
einem Textbildschirm realisieren läßt, zwischen den verschiedenen
Implementierungen portabel.

\proc{void}{OpenAlpha}{unsigned char *windowname}
\descr{
Es wird ein Textfenster mit dem Namen $windowname$ angelegt geöffnet.\\
Auch ohne expliziten Aufruf dieser Funktion wird ein Textfenster
geöffnet, wenn eine Funktion zur Ausgabe bzw. Eingabe aufgerufen wird.
}
\proc{void}{CloseAlpha}{void}
\descr{
Das Textfenster wird abgemeldet.
}
\proc{void}{Alpha}{int mode}
\descr{
Das Textfenster wird mit $mode$=OFF minimiert und mit $mode$=ON wieder eingeschaltet.
}
\proc{void}{PushAlpha}{void}
\descr{
Der aktuelle Zustand des Textfensters wird auf einem Stack gesichert.
}
\proc{void}{PopAlpha}{void}
\descr{
Das zuletzt auf dem Stack gesicherte Textfenster wird wiederhergestellt.
}
\proc{void}{ClearAlpha}{void}
\descr{
Der Inhalt des Textfensters wird gelöscht.
}
\proc{void}{SetAlphaCursor}{int x,int y}
\descr{
Ein Textkursor wird im Textfenster auf die Position $(x,y)$ gesetzt.
}
\proc{void}{GetAlphaCursor}{int *x,int *y}
\descr{
Die aktuelle Position des Textkursors wird auf den 
Variablen $x$ und $y$ bereitgestellt.
}
\proc{void}{Bell}{void}
\descr{
Es wird ein Ton ausgegeben.
}
\proc{int}{AlphaSizeX}{void}
\descr{
Die Anzahl der Spalten des Textfensters wird zurückgegeben.
}
\proc{int}{AlphaSizeY}{void}
\descr{
Die Anzahl der Zeilen des Textfensters wird zurückgegeben.
}
\proc{void}{SetAttribute}{int fg,int bg,int inv,int high}
\descr{
Es werden Attribute für den Textbildschirm gesetzt. Die Vordergrundfarbe wird
durch die niederwertigen drei Bits von $fg$, die Hintergrundfarbe duch die
niederwertigen drei Bits von $bg$ bestimmt. Für $inv \ne 0$ wird der Text
invertiert dargestellt und mit $high \ne 0$ hervorgehoben.\\
Für die Farbangaben können die Konstanten C\_BLACK, C\_RED, C\_GREEN,
C\_BLUE, C\_YELLOW, C\_CYAN, C\_MAGENTA und C\_WHITE verwendet werden.
}


\subsection{Ein- und Ausgabefunktionen}

\proc {int}{PutChar}{int c}
\descr{
Es wird ein Zeichen $c$ an das Textfenster ausgegeben.
}
\proc {int}{GetChar}{void}
\descr{
Es wird die Eingabe eines Zeichens erwartet und der Zeichencode der
gedrücketen Taste zurückgegeben.
}
\proc {int}{GetKey}{void}
\descr{
Es wird getestet, ob eine Taste gedrückt wurde. Ist das der Fall, wird der
zugehörige Zeichencode zurückgegeben, wenn keine Taste gedrückt wurde, ist der
Rückgabewert 0.
}
\proc{int}{Printf}{const char *format,...}
\descr{
Ausgabe in das Textfenster. Der Formatstring und die restlichen Parameter sind
aufgebaut wie bei der Standardfunktion printf().
}
\proc{int}{Print}{const string \&s}
\descr{
Ausgabe des string s in das Textfenster.
}
\proc{int}{Input}{const char *prompt}
\procf{int}{Input}{const char *prompt,int defvalue}
\procf{int}{Input}{const string \&prompt}
\procf{int}{Input}{const string \&prompt,int defvalue}
\descr{
Eingabe einer Integerzahl. Der String $prompt$ wird als Prompt ausgegeben. Bei
fehlerhafter Eingabe wird die Anforderung wiederholt. Ist $defvalue$ gegeben, 
so wird dieser Wert als Default-Wert angeboten.
}

\proc{double}{InputD}{const char *prompt}
\procf{double}{InputD}{const char *prompt,double defvalue}
\procf{double}{InputD}{const string \&prompt}
\procf{double}{InputD}{const string \&prompt,double defvalue}
\descr{
Eingabe einer Gleitkommazahl. Der String $prompt$ wird als Prompt ausgegeben. 
Bei fehlerhafter Eingabe wird die Anforderung wiederholt. 
Ist $defvalue$ gegeben, so wird dieser Wert als Default-Wert angeboten.
}
\proc{void}{InputS}{const char *p,char *s}
\procf{string}{InputS}{const string \&p}
\descr{
Eingabe einer Zeichenkette. Der String $p$ wird als Prompt ausgegeben.
}
\proc{int}{InputString}{char *Str,int Control,int *Ptr,int *scroll}
\descr{
Eingabe einer Zeichenkette. Falls $Control$ ungleich Null ist, wird die
Eingabe auch durch Kursortasten abgebrochen und als Rückgabewert der
entsprechende Tastendruck geliefert.
}

\subsection{Zeitmessung}

\proc{double}{TimeD}{int mode=TM\_WORLD}
\descr{
Es wird die Zeit in Sekunden zurückgegeben. Abhängig von $mode$ können 
verschiedene Zeiten abgefragt werden:
\begin{itemize}
\item TM\_WORLD Die Systemzeit. Widerspiegelt die real abgelaufene Zeit.
\item TM\_PROCESS Die Prozesszeit. Widerspiegelt die vom Prozess genutzte
  Rechenzeit inklusive Systemaufrufen.
\item TM\_USER Die ``user time''. Widerspiegelt die vom Prozess genutzte
  Rechenzeit ohne Systemaufrufe.
\item TM\_CHILD Die Kindzeit. Widerspiegelt die von Kindern des aktuellen Prozesses genutzte
  Rechenzeit inklusive Systemaufrufen.
\item TM\_CHILDUSER Die ``user''-Kindzeit. Widerspiegelt die von Kindern des
  aktuellen Prozesses genutzte Rechenzeit ohne Systemaufrufe.
\end{itemize}
}
\proc{void}{Delay}{double time}
\descr{
Verzögerung von $time$ Sekunden.
}

\subsection{Menüs und Verzeichnisse}

\proch{void}{Directory}{vector$<$string$>$ \&t,const string \&mask,int mode=DIR\_FILE $|$ DIR\_DIR}{dirfunc.h}
\descr{Im vector$<$string$>$ $t$ werden die Namen der gefundenen Dateien abgelegt, 
die der Auswahlmaske $mask$ entsprechen. Die Maske ist den Konventionen des jeweiligen 
Betriebssystems entsprechend aufzubauen. Enthält die Maske keinen Pfad,
wird das aktuelle Verzeichnis benutzt.
Enthält die Liste bereits Einträge, so bleiben diese erhalten. Die neuen Einträge
der Liste werden alphabetisch sortiert angehängt.\\
\begin{tabular}{ll}
Modus & Bedeutung\\
DIR\_FILE & suche reguläre Dateien \\
DIR\_DIR & suche Verzeichnisse \\
DIR\_WITHPATH & Ergänze die Eintrage um den Pfad \\
\end{tabular}
}
\seealso{SplitFilename}

\proch{int}{Menu}{const vector$<$string$>$ \&t,int x1=-1,int y1=-1,int x2=-1,int y2=-1, bool restore=false,const string \&title=''''}{visual/menu.h}
\procf{int}{Menu}{const vector$<$string$>$ \&t,const vector$<$int$>$ \&menuId, int x1=2,int y1=2,int x2=30,int y2=22, bool restore=false,const string \&title=''''}
\descr{
  Aus der Liste von Menüpunkten $t$ wird in dem durch die Koordinaten $x1,y1$ und $x2,y2$
  festgelegten Ausschnitt des Textfensters ein Menü aufgebaut.
  Die Auswahl erfolgt mit den Kursortasten. Ist im Menütext ein Buchstabe durch ein 
  vorangestelltes '~' markiert, so kann dieser Menüpunkt durch die entsprechende 
  Taste ausgewählt werden, sonst wird der Anfangsbuchstabe verwendet.
  Rückgabewert der Funktion ist die Nummer $nr$ des ausgewählten Texteintrages, 
  auf den dann mit $t[nr]$ zugegriffen werden kann. Wird der Parameter $menuId$
  angegeben, so wird der entsprechende Wert aus $menuId$ zurückgegeben.
  Bei Abbruch mit $<$ESC$>$ ist der Rückgabewert negativ (=ERROR).
  Ist $restore=true$ wird nach der Menüauswahl der vorherige Bildschirminhalt 
  wiederhergestellt.
}

\proch{bool}{SelFile}{const string \&mask,string \&filename,string \&dirname,int mode=DIR\_FILE,const string \&title='''', int x1=-1,int y1=-1,int x2=-1,int y2=-1}{visual/menu.h}
\procf{bool}{SelFile}{const string \&mask, string \&filename}
\descr{Eine einfache interaktive Dateiauswahl. Mittels \see{Directory} wird eine
Dateiliste aufgebaut, aus der mittels \see{Menu} eine Datei ausgewählt werden
kann. Je nach $mode$ kann eine Datei und/oder ein Verzeichnis gewählt werden. Ist bei
$mode$ der Wert $DIR\_SELPATH$ angegeben, kann man damit eine Datei in einem beliebigen
erreichbaren Verzeichnis ausgewählt werden. Die Funktion gibt nach erfolgreicher Auswahl 
den Wert $true$ zurück. Die ausgewählte Datei steht in $filename$, das Verzeichnis in 
$dirname$. Bei Aufruf in der zweiten Form wird ist $filename$ aus Verzeichnis und 
Dateinamen zusammengesetzt. Der Verzeichnisname ist relativ oder absolut, je nachdem wie
das Verzeichnis in $mask$ angegeben wurde.}


 
\newpage
\makeatletter{}\nsection{Quaternionen}{quaternions}
\hypertarget{Trafo}{}

\subsection{Elementare Quaternionen}
\hypertarget{Quaternion}{}

\subsubsection{Konstruktoren und Destruktoren}
\proch{}{Quaternion::Quaternion}{}{quaternion.h}
\descr
{
Es wird eine mit 0 initialisierte Quaternion angelegt.
}
\proc{}{Quaternion::Quaternion}{double real, double i, double j, double k}
\descr
{
Es wird eine Quaternion mit Realteil $real$ und den
Imaginäranteilen $i$, $j$ und $k$ angelegt.
}
\proc{}{Quaternion::Quaternion}{double real, Vector3d\& imaginary}
\descr
{
Es wird eine Quaternion mit Realteil $real$ und
Imaginäranteilen aus dem Vektor $imaginary$ (i,j,k) angelegt.
}
\proc{}{Quaternion::Quaternion}{const Quaternion\& b}
{
Es wird eine Kopie der Quaternion $b$ erzeugt. (Kopier-Konstruktor) 
}
\subsubsection{Operatoren}
\begin{tabular}{|c|c|}
\hline
Operator & Funktion\\ 
\hline
Quaternion = Quaternion & Zuweisungsoperator\\
\hline
Quaternion + Quaternion & Quaternionenaddition\\
\hline
Quaternion - Quaternion & Quaternionensubtraktion\\
\hline
-Quaternion & Negation der Quaternion\\
\hline
Quaternion * double & Multiplikation mit Skalar\\
\hline
double * Quaternion & Multiplikation mit Skalar\\
\hline
Quaternion * Quaternion & Quaternionenmultiplikation\\
\hline
\end{tabular}

\subsubsection{Elementfunktionen}
\proc{double}{Quaternion::getReal}{}
\descr
{
Liefert den Realteil der Quaternion.
}
\proc{double}{Quaternion::getI}{}
\descr
{
Liefert den i-Imaginärteil der Quaternion.
}

\proc{double}{Quaternion::getJ}{}
\descr
{
Liefert den j-Imaginärteil der Quaternion.
}

\proc{double}{Quaternion::getK}{}
\descr
{
Liefert den k-Imaginärteil der Quaternion.
}

\proc{vector3d}{Quaternion::getImaginary}{}
\descr
{
Liefert die Imaginärteile der Quaternion als Vektor (i,j,k)
}

\proc{void}{Quaternion::setReal}{double real}
\descr
{
Setzt den Realteil der Quaternion auf $real$.
}

\proc{void}{Quaternion::setI}{double i}
\descr
{
Setzt den i-Imaginärteil der Quaternion auf $i$.
}

\proc{void}{Quaternion::setJ}{double j}
\descr
{
Setzt den j-Imaginärteil der Quaternion auf $j$.
}

\proc{void}{Quaternion::setK}{double k}
\descr
{
Setzt den k-Imaginärteil der Quaternion auf $k$.
}

\proc{void}{Quaternion::setImaginary}{vector3d\& imaginary}
\descr
{
Setzt die Imaginärwerte der Quaternion auf die Werte des Vektors $imaginary$ (i,j,k).
}

\proc{Quaternion}{Quaternion::getNegate}{}
\descr
{
Gibt die negierte Quaternion zurück.
}

\proc{Quaternion}{Quaternion::getConjugate}{}
\descr
{
Gibt die conjugierte Quaternion zurück.
}

\proc{Quaternion}{Quaternion::getInverse}{}
\descr
{
Gibt die inverse Quaternion zurück, falls diese Vorhanden ist, sonst Fehlermeldung.
}

\proc{Quaternion}{Quaternion::getNormalize}{}
\descr
{
Gibt die normalisierte Quaternion zurück, falls diese Vorhanden ist, sonst Fehlermeldung.
}

\proc{Quaternion}{Quaternion::getSquare}{}
\descr
{
Gibt das Quadrat der Quaternion zurück.
}

\proc{double}{Quaternion::getNorm}{}
\descr
{
Gibt die Norm der Quaternion zurück.
}

\proc{double}{Quaternion::getSquareNorm}{}
\descr
{
Gibt das Quadrat der Norm der Quaternion zurück.
}

\proc{double}{Quaternion::getEigenwinkel}{}
\descr
{
Gibt den Eigenwinkel der Quaternion zurück, falls dieser Vorhanden, sonst Fehlermeldung.
}

\proc{Quaternion}{Quaternion::getEigenachse}{}
\descr
{
Gibt die Eigenachse der Quaternion zurück, falls diese vorhanden, sonst Fehlermeldung.
}

\proc{vector3d}{Quaternion::getPhases}{}
\descr
{
Gibt die Phasen der Quaternion als Vektor $(\alpha,\beta,\delta) $ zurück,falls
vorhanden, sonst Fehlermeldung.
}

\proc{bool}{Quaternion::isUnitQuaternion}{}
\descr
{
Liefert TRUE, falls die Quaternion eine Einheitsquaternion ist.
}

\subsubsection{Funktionen mit Quaternionen}
\proc{Quaternion}{qexp}{Quaternion\& x}
\descr
{
Gibt $e^x$ zurück.
}
\subsection{RotQuaternionen}
\hypertarget{RotQuaternion}{}
\subsubsection{Konstruktoren und Destruktoren}
\proch{}{RotQuaternion::RotQuaternion}{}{rotquaternion.h}
\descr
{
Es wird eine mit 1 initialisierte Rotationsquaternion angelegt.
}

\proc{}{RotQuaternion::RotQuaternion}{double angle, double x, double y, double z}
\descr
{
Es wird eine Rotationsquaternion mit Rotationswinkel $angle$ im Bogenmaß und
Rotationsachse ($x$,$y$,$z$) angelegt.
}

\procf{}{RotQuaternion::RotQuaternion}{double angle, vector3d\& axis}
\descr
{
Es wird eine Rotationsquaternion mit Rotationswinkel $angle$ im Bogenmaß und
Rotationsachse $axis$ angelegt.
}

\procf{}{RotQuaternion::RotQuaternion}{const RotQuaternion\& b)
{
Es wird eine Kopie der Rotationsquaternion b erzeugt. (Kopier-Konstruktor}
}

\subsubsection{Operatoren}
\begin{tabular}{|c|c|}
\hline
Operator & Funktion\\ 
\hline
RotQuaternion = RotQuaternion & Zuweisungsoperator\\
\hline
-RotQuaternion & Negation der Rotationsquaternion\\
\hline
RotQuaternion * RotQuaternion & Quaternionenmultiplikation\\
\hline
\end{tabular}

Operatoren, die den Bereich der Rotationsquaternionen verlassen und eine Quaternion als
Rückgabewert liefern.

\begin{tabular}{|c|c|}
\hline
Operator & Funktion\\ 
\hline
RotQuaternion + Rotquaternion & Quaternionenaddition\\
\hline
RotQuaternion - RotQuaternion & Quaternionensubtraktion\\
\hline
double * RotQuaternion & Multiplikation einer Quaternion mit einem Skalar\\
\hline
RotQuaternion * double & Multiplikation einer Quaternion mit einem Skalar\\
\hline
RotQuaternion*Quaternion & Quaternionenmultiplikation\\
\hline
Quaternion*RotQuaternion & Quaternionenmultiplikation\\
\hline
(Quaternion)* & Castingoperator
\end{tabular}

\subsubsection{Elementfunktionen}
\proc{double}{RotQuaternion::getReal}{}
\descr
{
Liefert den Realteil der Rotationsquaternion.
}

\proc{double}{RotQuaternion::getI}{}
\descr
{
Liefert den i-Imaginärteil der Rotationsquaternion.
}

\proc{double}{RotQuaternion::getJ}{}
\descr
{
Liefert den j-Imaginärteil der Rotationsquaternion.
}

\proc{double}{RotQuaternion::getK}{}
\descr
{
Liefert den k-Imaginärteil der Rotationsquaternion.
}

\proc{vector3d}{RotQuaternion::getImaginary}{}
\descr
{
Liefert die Imaginärteile der Rotationsquaternion als Vektor (i,j,k).
}

\proc{double}{RotQuaternion::getRotationAngle}{}
\descr
{
Liefert den Rotationswinkel der Rotationsquaternion im Bogenmaß.
}

\proc{vector3d}{RotQuaternion::getRotationAxis}{}
\descr
{
Liefert die Rotationsachse der Rotationsquaternion als Vektor (i,j,k).
}

\proc{void}{RotQuaternion::setRotationAngle}{double angle}
\descr
{
Setzt Rotationswinkel der Rotationsquaternion auf angle im Bogenmaß.
}

\proc{void}{RotQuaternion::setRotationAxis}{vector3d\& axis}
\descr
{
Setzt die Rotationsachse der Rotationsquaternion.
}

\proc{RotQuaternion}{RotQuaternion::getNegate}{}
\descr
{
Gibt die negierte Rotationsquaternion zurück.
}

\proc{RotQuaternion}{RotQuaternion::getConjugate}{}
\descr
{
Gibt die conjugierte Rotationsquaternion zurück.
}

\proc{RotQuaternion}{RotQuaternion::getInverse}{}
\descr
{
Gibt die inverse Rotationsquaternion zurück.
}

\proc{RotQuaternion}{RotQuaternion::getSquare}{}
\descr
{
Gibt das Quadrat der Quaternion zurück.
}

\proc{double}{RotQuaternion::getNorm}{}
\descr
{
Gibt die Norm (1.0) der Rotationsquaternion zurück.
}

\proc{double}{RotQuaternion::getSquareNorm}{}
\descr
{
Gibt das Quadrat (1.0) der Norm der Rotationsqquaternion zurück.
}

\proc{double}{RotQuaternion::getEigenwinkel}{}
\descr
{
Gibt den Eigenwinkel der Rotationsquaternion zurück, falls dieser Vorhanden, sonst
Fehlermeldung.
}

\proc{RotQuaternion}{RotQuaternion::getEigenachse}{}
\descr
{
Gibt die Eigenachse der Rotationsquaternion zurück, falls diese vorhanden, sonst
Fehlermeldung.
}

\proc{vector3d}{RotQuaternion::getPhases}{}
\descr
{
Gibt die Phasen der Rotationsquaternion als Vektor $(\alpha,\beta,\delta)$ zurück,
falls vorhanden, sonst Fehlermeldung.
}

\proc{Matrix}{RotQuaternion::getRotationMatrix}{}
\descr
{
Konvertiert die Quaternion in eine $3\times 3$ Rotationsmatrix.
}


\subsubsection{Funktionen mit Rotationsquaternionen}
\proc{Quaternion}{qexp}{RotQuaternion\& x}
\descr
{
Gibt $e^x$ zurück.
}

\proc{RotQuaternion}{convertToRotQuaternion}{Quaternion\& in}
\descr
{
Konvertiert die Quaternion $in$ in eine Rotationsquaternion, falls dies
möglich, sonst Fehlermeldung.
}

\proc{RotQuaternion}{convertToRotQuaternion}{Matrix\& in}
\descr
{
Konvertiert die $3\times 3$ Rotationsmatrix $in$ in eine Rotationsquaternion,
falls dies möglich, sonst Fehlermeldung.
}
\subsection{QuatMatrix - Quaternionenwertige Matrizen}
\hypertarget{QuatMatrix}{}
\subsubsection{Konstruktoren und Destruktoren}
\proch{}{QuatMatrix::QuatMatrix}{}{quatmatrix.h}
\descr
{
Es wird eine quaternionenwertige Matrix unbestimmter Größe angelegt.
}

\procf{}{QuatMatrix::QuatMatrix}{unsigned int rows, unsigned int columns}
\descr
{
Es wird eine quaternionenwertige Matrix mit $rows$ Zeilen und $columns$
Zeilen angelegt.
}

\procf{}{QuatMatrix::QuatMatrix}{const QuatMatrix\& qm}
\descr
{
Es wird eine Kopie der quaternionenwertigen Matrix $qm$ erzeugt.
(Kopier-Konstruktor)
}

\subsubsection{Operatoren}
\begin{tabular}{|c|c|}
\hline
Operator & Funktion\\ 
\hline
QuatMatrix = QuatMatrix & Zuweisungsoperator\\
\hline
QuatMatrix + QuatMatrix & Matrixaddition\\
\hline
QuatMatrix - QuatMatrix & Matrixsubtraktion\\
\hline
QuatMatrix * double & Multiplikation mit Skalar\\
\hline
double * QuatMatrix & Multiplikation mit Skalar\\
\hline
QuatMatrix * Quaternion & Multiplikation mit Quaternion\\
\hline
Quaternion * QuatMatrix & Multiplikation mit Quaternion\\
\hline
Quaternion [int] & Zugriff auf eine Zeile der quaternionenwertigen Matrix\\
\hline
Quaternion [int i][int j] & Zugriff auf Element der Matrix
\end{tabular}

\subsubsection{Elementfunktionen}
\proc{unsigned int}{QuatMatrix::getRows}{}
\descr
{
Liefert die Anzahl der Zeilen der quaternionenwertigen Matrix.
}

\proc{unsigned int}{QuatMatrix::getColumns}{}
\descr
{
Liefert die Anzahl der Spalten der quaternionenwertigen Matrix.
}
\subsection{Quaternionenwertige Vektoren}
\hypertarget{QuatVector}{}
\subsubsection{Konstruktoren und Destruktoren}
\proch{}{QuatVector::QuatVector}{}{quatvektor.h}
\descr
{
Es wird ein quaternionenwertiger Vektor unbestimmter Größe angelegt.
}

\procf{}{QuatVector::QuatVector}{unsigned int dimension}
\descr
{
Es wird ein quaternionenwertiger Vektor der Größe $dimension$ angelegt.
}

\procf{}{QuatVector::QuatVector}{const QuatVector\& qv}
\descr
{
Es wird eine Kopie des quaternionenwertigen Vektors $qv$ erzeugt.
(Kopier-Konstruktor)
}

\subsubsection{Operatoren}
\begin{tabular}{|c|c|}
\hline
Operator & Funktion\\ 
\hline
QuatVector = QuatVector & Zuweisungsoperator\\
\hline
QuatVector + QuatVector & Vektorenaddition\\
\hline
QuatVector - QuatVector & Vektorensubtraktion\\
\hline
QuatVector * double & Multiplikation mit Skalar\\
\hline
double * QuatVector & Multiplikation mit Skalar\\
\hline
QuatVector * Quaternion & Multiplikation mit Quaternion\\
\hline
Quaternion * QuatVector & Multiplikation mit Quaternion\\
\hline
Quaternion [int] & Elementzugriff
\end{tabular}

\subsubsection{Elementfunktionen}
\proc{unsigned int}{QuatVector::getDimension}{}
\descr
{
Liefert die Dimension des quaternionenwertigen Vektors.
}
\subsection{Duale Quaternionen}
\hypertarget{DualQuaternion}{}
\subsubsection{Konstruktoren und Destruktoren}
\proch{}{DualQuaternion::DualQuaternion}{}{dualquaternion.h}
\descr
{
Es wird eine mit $\hat{q}=(0,\vec{0})+(0,\vec{0}\varepsilon)$ initialisierte duale
Quaternion angelegt.
}
\proc{}{DualQuaternion::DualQuaternion}{Quaternion\& real, Quaternion\& dual}
\descr
{
Es wird eine duale Quaternion mit Realteil $real$ und denm dualen Anteil 
$dual$ angelegt.
}
\proc{}{DualQuaternion::DualQuaternion}{const DualQuaternion\& b}
\descr
{
Es wird eine Kopie der dualen Quaternion $b$ erzeugt. (Kopier-Konstruktor)
}
\subsubsection{Operatoren}
\begin{tabular}{|c|c|}
\hline
Operator & Funktion\\ 
\hline
DualQuaternion = DualQuaternion & Zuweisungsoperator\\
\hline
DualQuaternion + DualQuaternion & Addition dualer Quaternionen\\
\hline
DualQuaternion - DualQuaternion & Subtraktion dualer Quaternionen\\
\hline
-DualQuaternion & Negation der dualen Quaternion\\
\hline
DualQuaternion * double & Multiplikation mit Skalar\\
\hline
double * DualQuaternion & Multiplikation mit Skalar\\
\hline
DualQuaternion * DualQuaternion & Multiplikation der dualen Quaternionen\\
\hline
\end{tabular}

\subsubsection{Elementfunktionen}
\proc{Quaternion}{DualQuaternion::getReal}{}
\descr
{
Liefert den Realteil der dualen Quaternion.
}

\proc{Quaternion}{DualQuaternion::getDual}{}
\descr
{
Liefert den Dualteil der dualen Quaternion.
}

\proc{void}{DualQuaternion::setReal}{Quaternion\& real}
\descr
{
Setzt den Realteil der dualen Quaternion auf $real$.
}

\proc{void}{DualQuaternion::setDual}{Quaternion\& dual}
\descr
{
Setzt den Dualteil der dualen Quaternion auf $dual$.
}

\proc{DualQuaternion}{DualQuaternion::getNegate}{}
\descr
{
Gibt die negierte duale Quaternion zurück.
}

\proc{DualQuaternion}{DualQuaternion::getConjugate}{}
\descr
{
Gibt die konjugierte duale Quaternion zurück.
}

\proc{DualQuaternion}{DualQuaternion::getTilde}{}
\descr
{
Gibt das Ergebnis der Anwendung des Tildeoperators zurück.
}

\proc{DualQuaternion}{DualQuaternion::getInverse}{}
\descr
{
Gibt die inverse duale Quaternion zurück, falls vorhanden, sonst Fehlermeldung.
}

\proc{DualQuaternion}{DualQuaternion::getQuasiNorm}{}
\descr
{
Gibt die Quasi-Norm der dualen Quaternion zurück.
}

\proc{bool}{DualQuaternion::isUnitDualQuaternion}{}
\descr
{
Liefert true, falls die duale Einheitsquaternion.
}
\subsection{Duale Transformationsquaternionen}
\hypertarget{TrafoDualQuaternion}{}
\subsubsection{Konstruktoren und Destruktoren}
\proch{}{TrafoDualQuaternion::TrafoDualQuaternion}{}{trafodualquaternion.h}
\descr
{
Es wird eine mit $\hat{q}=(1,\vec{0})+(0,\vec{0}\varepsilon)$ initialisierte duale
Transformationsquaternion angelegt.
}
\proc{}{TrafoDualQuaternion::TrafoDualQuaternion}{RotQuaternion\& rot, vector3d\& trans}
\descr
{
Es wird eine duale Transformationsquaternion aus dem Rotationsanteil $rot$ und dem
Translatiosvektor \textit{trans} angelegt.
}
\proc{}{TrafoDualQuaternion::TrafoDualQuaternion}{const TrafoDualQuaternion\& b}
\descr
{
Es wird eine Kopie der dualen Transformationsquaternion $b$ erzeugt.
(Kopier-Konstruktor)
}

\subsubsection{Operatoren}
\begin{tabular}{|c|c|}
\hline
Operator & Funktion\\ 
\hline
TrafoDualQuaternion = TrafoDualQuaternion & Zuweisungsoperator\\
-TrafoDualQuaternion & Negation einer dualen
Transformationsquaternion\\
\hline
TrafoDualQuaternion * TrafoDualQuaternion & Multiplikation dualer
Transformationsquaternionen\\
\hline
\end{tabular}

Operatoren, die den Bereich der dualen Transformationsquaternionen verlassen und eine
duale Quaternion als Rückgabewert liefern.

\subsubsection{Operatoren}
\begin{tabular}{|c|c|}
\hline
Operator & Funktion\\ 
\hline
TrafoDualQuaternion + TrafoDualQuaternion & Addition zweier dualer
Transformationsquaternioen\\
\hline
TrafoDualQuaternion + DualQuaternion & Addition duale Quaternion und duale
Transformationsquaternion\\
\hline
DualQuaternion + TrafoDualQuaternion & Addition duale Quaternion und duale
Transformationsquaternion\\
\hline
TrafoDualQuaternion - TrafoDualQuaternion & Subtraktion zweier dualer
Transformationsquaternioen\\
\hline
TrafoDualQuaternion - DualQuaternion & Subtraktion duale Transformationsquaternion und
duale duale Quaternion\\
\hline
DualQuaternion - TrafoDualQuaternion & Subtraktion duale Quaternion und duale
Transformationsquaternion\\
\hline
double * TrafoDualQuaternion & Multiplikation mit Skalar\\
\hline
TrafoDualQuaternion * double & Multiplikation mit Skalar\\
\hline
DualQuaternion * TrafoDualQuaternion & Multiplikation mit dualer Quaternion\\
\hline
TrafoDualQuaternion * DualQuaternion & Multiplikation mit dualer Quaternion\\
\hline
(TrafoDualQuaternion)* & Castingoperator\\
\hline
\end{tabular}

\subsubsection{Elementfunktionen}
\proc{Quaternion}{TrafoDualQuaternion::getReal}{}
\descr
{
Liefert den Realteil der dualen Quaternion.
}

\proc{Quaternion}{TrafoDualQuaternion::getDual}{}
\descr
{
Liefert den Dualteil der dualen Quaternion.
}

\proc{void}{TrafoDualQuaternion::setRotation}{RotQuaternion\& rot}
\descr
{
Setzt den Rotationsanteil der dualen Transformationsquaternion auf $rot$.
}

\proc{void}{TrafoDualQuaternion::setDual}{vector3d\& trans}
\descr
{
Setzt die Translation der der dualen Transformationsquaternion.
}

\proc{TrafoDualQuaternion}{TrafoDualQuaternion::getNegate}{}
\descr
{
Gibt die negierte duale Transformationsquaternion zurück.
}

\proc{TrafoDualQuaternion}{TrafoDualQuaternion::getConjugate}{}
\descr
{
Gibt die konjugierte duale Transformationsquaternion zurück.
}

\proc{TrafoDualQuaternion}{TrafoDualQuaternion::getTilde}{}
\descr
{
Gibt das Ergebnis der Anwendung des Tildeoperators zurück.
}

\proc{TrafoDualQuaternion}{TrafoDualQuaternion::getInverse}{}
\descr
{
Gibt die inverse duale Quaternion zurück.
}
\proc{Matrix}{TrafoDualQuaternion::getTransformationMatrix}{}
\descr
{
Gibt die zur dualen Transformationsquaternion äquivalente homogene Transformation zurück.
}
\subsubsection{Funktionen mit dualen Transformatiosquaternionen}
\proc{TrafoDualQuaternion}{convertToTrafoDualQuaternion}{const Matrix\& in}
\descr
{
Konvertiert die homogene Transformationsmatrix $in$ 
in eine duale Transformationsquaternion.
}

\proch{TrafoDualQuaternion}{estimateTransformation}{const
Matrix\& orig,const Matrix\& trans}{quatmatch.h}
\descr
{
Berechnet die Transformation (Rotation und Translation), durch die die in $orig$ gegebenen 
dreidimensionalen Originalpunkte in die in $trans$ gegeben dreidimensionalen Punkte
transformiert wurden.
} 
\subsection{Quaternionen-Fourier-Transformation}
\proch{int}{QFourier}{QuatMatrix\& input, QuatMatrix\& output,int option=NORMAL}{qft.h}
\descr
{
Quaternionenwertige Fourier-Transformation der quaternionenwertigen Matrix \textit{input} 
($mode$=NORMAL Hintransformation, $mode$=INVERS Tücktransformation). Das
Ergebnis der Transformation wird in $output$ abgelegt.
}
\subsubsection{Abgeleitete Spektren}
Für die unten aufgeführten abgeleiteten Spektren gilt:
\begin{itemize}
\item mode = CENTER: zentriertes Spektrum
\item mode = NOCENTER: unzentriertes Spektrum
\end{itemize}

\proch{int}{PowerSpektrumQFT}{QuatMatrix\& input, Image\& output,int type=POWER, int
mode=CENTER}{qft.h}
\descr
{
Berechnet das Leistungsspektrum der quaternionenwertigen Matrix \textit{input} und
legt dieses als Bild $output$ ab. Die Matrix $input$ sollte dabei ein
fouriertransformiertes Signal enthalten.\\
Dabei gilt:
\begin{itemize}
\item type=POWER: Spektrum der Quadratnorm
\item type=NORM: Spektrum der Norm
\item type=LOG: Spektrum in logarithmischer Skalierung
\end{itemize}
}

\proch{int}{EigenwinkelSpektrumQFT}{QuatMatrix\& input, Image\& r, Image\& g,
Image\& b, int mode=CENTER}{qft.h}
\descr{ 
Berechnet das Eigenwinkelspektrum der quaternionenwertigen Matrix $input$ und
legt dieses in den Graustufenbilder $r$, $g$ und $b$ ab.
Diese als RGB-Bild dargestellt, ergibt das Eigenwinkelspektrum. Die Funktion 
kann auch zur Visualisierung von quaternionenwertigen Korrelationen verwendet 
werden. }

\proch{int}{EigenachsenSpektrumQFT}{QuatMatrix\& input, Image\& r, Image\& g,
Image\& b, int mode=CENTER}{qft.h}
\descr
{Berechnet das Eigenachsenspektrum er quaternionenwertigen Matrix $input$ und
legt dieses in den Graustufenbilder $r$, $g$ und $b$ ab.
Diese als RGB-Bild dargestellt, ergibt das Eigenachsenspektrum. Die Funktion 
kann auch zur Visualisierung von quaternionenwertigen Korrelationen verwendet werden.}

\proch{int}{PhasenSpektrumQFT}{QuatMatrix\& input, Image\& alpha, Image\& beta,
Image\& delta, int mode=CENTER}{qft.h}
\descr
{ 
Berechnet das Phasenspektren der Winkel für die $\alpha,\beta,\delta)$ Exponentialform
einer Quaternion und legt diese als Graustufenbil $alpha$, $beta$ und
$delta$ ab.
}
 
\newpage
\makeatletter{}\nsection{Fehlerbehandlung}{errorHandling}

\subsection{Grundsätzliches}
\label{Fehlerbehandlung}
Bei fehlerhafter Abarbeitung (z.B. durch falsche Parameter) geben Funktionen
normalerweise eine Fehlermeldung aus. Die Abarbeitung des Programms kann dann
interaktiv abgebrochen oder fortgesetzt werden. Um eine Fehlerbehandlung durch
das Anwenderprogramm zu ermöglichen, kann diese Form der Fehlermeldung durch
spezielle Funktionen ein- und ausgeschaltet werden. Eine Fehlerdiagnose ist
mit Hilfe der Funktion GetError() möglich, mit der der Fehlercode abgefragt 
werden kann.

\noindent Bezüglich der Rückgabewerte bei Fehlern existieren in ICE drei 
verschiedene Funktionstypen:
\begin{itemize}
\item Funktionen, die keinen funktionsspezifischen Rückgabewert liefern: Der
Rückgabewert ist hier vom Typ $int$ und enthält den Fehlercode. Der Wert
$OK$ steht hier für ``kein Fehler''.
\item Funktionen, die Zeiger zurückliefern: Bei Fehler liefern diese
Funktionen den Nullpointer als Rückgabewert. Die genaue Fehlerbeschreibung 
(der Fehlercode) ist mit der Funktion GetError() abzufragen.
\item Funktionen mit einem funktionsspezifischen Rückgabewert: Der
Rückgabewert liefert hier keine Information über aufgetretene Fehler. 
Hier besteht nur die Möglichkeit, mit \bsee{GetError} abzufragen, ob und 
welcher Fehler aufgetreten ist.
\end{itemize}
\subsection{Fehlerbehandlungsfunktionen}
\proc{void}{Message}{char *name, char *msg, int code}
\descr{Ausgabe einer Fehlermeldung. $name$ ist der Funktionsname, {\em
msg} ist der Text der Fehlernachricht und $code$ ist ein Fehlercode, der
intern gesetzt wird und mit GetError() abgefragt werden kann. 
Vordefinierte Fehlermeldungen und Rückkehrcodes befinden sich im defs.h.
Eine besondere Bedeutung besitzt die Meldung (der Zeiger) $M\_0$. Er bewirkt, 
dass die von einer untergeordneten, gerufenen Funktion erzeugte Fehlermeldung
ausgegeben wird. }
\proc{void}{OffMessage}{void}
\descr{Ausschalten der Fehlermeldungen. Treten bei einem Funktionsaufruf
Fehler auf, so werden diese nicht angezeigt und können von der rufenden
Funktion selber ausgewertet werden. Um die Funktion des gesamten Systems 
zu gewährleisten, ist sicherzustellen, daß die Fehlermeldungen vor dem 
Verlassen der Funktion wieder eingeschaltet werden. Dies muß vor 
der Ausgabe eigener Fehlermeldungen geschehen, damit diese angezeigt werden. }
\proc{void}{OnMessage}{void}
\descr{Einschalten der Fehlermeldungen.}
\proc{void}{SetOk}{void}
\descr{Der interne Fehlercode wird zurückgesetzt. Damit kann die
Programmabarbeitung fortgesetzt werden.}
\proc{int}{GetError}{void}
\descr{Als Funktionswert wird der interne Fehlercode zurückgegeben.}
\subsection{Beispiele für Standardfehlerbehandlung in ICE-Funktionen}
\begin{itemize}
\item Funktion in der ein Fehler auftreten kann.\\
In diesem Beispiel kann ein Fehler durch falsche Parameterangabe bzw. 
bei Speicheranforderungen auftreten.
\begprogr
\begin{verbatim}
//  Anlegen eines neuen Bildes 
// Beispiel veraltet !!!
#define FNAME "NewImg"

Image NewImg(int xsize, int ysize, int maxval)
{
 Image img;
 if ((xsize<=0)||(ysize<=0)||(maxval<=0)); // Parametertestung
    {
        Message(FNAME,M_WRONG_PARAM,WRONG_PARAM); // Fehlermeldung
        return NULL; // Rückgabewert NULL als Zeichen für Fehler
    }
 img=(Image )malloc(sizeof(struct Image_)); // Speicheranforderung
 if (img==NULL)
    {
        Message(FNAME,M_NO_MEM,NO_MEM); // Nicht genug Speicher melden
        return NULL; // Rückgabewert NULL als Zeichen für Fehler
    }
// Etliche weitere Schritte zur Verwaltung der Bildspeicher 
// durch ICE folgen
...
//
 return img; // Bei Erfolg Bildzeiger zurückgeben
}
#undef FNAME
\end{verbatim}
\endprogr
\item Funktion, die eine andere ICE-Funktion aufruft.\\
Das Durchreichen der Fehlermeldungen bis zur obersten Ebene hat den 
Vorteil, daß der Anwender aus der Fehlermeldung leichter die Fehlerursache 
erkennt, da er ja die intern indirekt aufgerufenen Funktionen nicht kennt.
\begprogr
\begin{verbatim}
// Anlegen eines neuen Bildes mit einem (einfachen) Testmuster
#define FNAME "GenImg"
Image GenImg(int xsize,int ysize,int maxval)
{
  Image img;
  // Die Parametertestung wird durch NewImg vorgenommen
  OffMessage(); // Fehlermeldungen deaktivieren
  img = NewImg(xsize,ysize,maxval); // Bild neu anlegen
  OnMessage();  // Fehlermeldungen wieder einschalten !
  if (!img.isValid()) // Ist ein Fehler aufgetreten ?
    {
      int errorcode=GetError();
      Message(FNAME,M_0,errorcode); // Fehler von NewImg weiterreichen (M_0)
                                    // ErrorCode ebenfalls wie gemeldet 
      return img; // Rückkehr mit ungültigem (invalid) Bild
    }
  for (int y=0; y < ysize; y++)
    for (int x=0;x < xsize; x++)
      PutVal(img, x, y, (x + y) 
  return img; // Zeiger auf neues Bild zurückgeben
}
#undef FNAME
\end{verbatim}\endprogr
\end{itemize}
\subsection{Makros für Standardfälle der Fehlerbehandlung}
Zur Erleichterung der Behandlung von Fehlern sind Makros definiert, die
einige Standardfälle abdecken. Diese setzen die Definition des Makros FNAME 
voraus, welches den Namen der Funktion als Zeichenkette enthält.
\proc{}{ReturnNullIfFailed}{function}
\descr{
Bricht bei Fehler bei der Abarbeitung von function ab und kehrt mit
dem Nullpointer zur aufrufenden Funktion zurück. Dieses Makro ist geeignet
für Funktionen, die normalerweise einen Zeiger zurückgeben.
}
Unter Verwendung von ReturnNullIfFailed vereinfacht sich das obige Beispiel 
stark:
\begprogr\begin{verbatim}
// Anlegen eines neuen Bildes mit einem (einfachen) Testmuster
#define FNAME "GenImg"
Image GenImg(int xsize,int ysize,int maxval)
{
Image img;
// Aufruf NewImg und Fehlerbehandlung
ReturnNullIfFailed(img=NewImg(xsize,ysize,maxval)); 

for (int y=0;y<ysize;y++)
 for (int x=0;x<xsize;x++)
   PutVal(img,x,y,(x+y)
return img; // Zeiger auf neues Bild zurückgeben
}
#undef FNAME
\end{verbatim}\endprogr

\proc{}{ReturnErrorIfFailed}{function}
\descr{
Bricht bei Fehler bei der Abarbeitung von $function$ ab und kehrt mit
dem Wert des Fehlers zur aufrufenden Funktion zurück. Dieses Makro ist 
geeignet für Funktionen vom typ $int$, die keinen funktionsspezifischen
Wert zurückgeben, sondern einen Fehlerkode.
}
\proc{}{IfFailed}{function}
\descr{
Aufruf der Funktion $function$ und Fehlerauswertung.
Dieses Makro stellt eine if-Anweisung dar. Die Bedingung ist erfüllt,
wenn ein Fehler aufgetreten ist. Im Körper der if-Anweisung ist 
entsprechend auf den Fehler zu reagieren. 
}

\noindent Das Makro IfFailed ist in folgender Form anwendbar:
\begin{verbatim}
IfFailed(img=NewImg(x,y,v))
    \{
        // Reaktion auf Fehler, z.B. files schließen ..
        ...
        Message(FNAME,M_0,ERROR);
        return NULL;
    \}

\end{verbatim}
Dieses Makro ist geeignet, wenn bei Fehlern individuell reagiert werden muß. 
Gründe dafür können sein:
\begin{itemize}
\item Ein spezieller Rückgabewert
\item Freigabe von Resourcen vor Fehlermeldung und Rückkehr
\item Tolerierung von Fehlern, wenn die Funktion trotzdem erfolgreich
beendet werden kann. Im Block nach IfFailed ist die spezielle Behandlung 
bei Fehler zu realisieren und der Fehlerzustand mit SetOK() zurückzusetzen,
damit die Abarbeitung ohne weitere Fehlermeldungen forgesetzt werden kann.
\end{itemize}

 
\newpage
\makeatletter{}\nsection{Richtlinien zum Schreiben von ICE-Funktionen}{styleGuide}

\subsection{Äußere Form}
Die Bibliothek {\bf ICE} unterliegt der LGPL, der GNU Lesser General Public
License. Neue Module, die Bestandteil der Bibliothek werden sollen, müssen
unter den gleichen Bedingungen freigegeben werden. Dazu muss am Anfang jeder
Datei der entsprechende Copyright-Eintrag vorgenommen werden.

\begin{verbatim}
/*
 * ICE - C++ - Library for image processing 
 *
 * Copyright (C) 2011 FSU Jena, Digital Image Processing Group
 * Contact: ice@uni-jena.de
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License 
 * along with this library; if not, see <http://www.gnu.org/licenses/>.
 */
\end{verbatim}

Es wird empfohlen, dass der jeweilige Autor sich darunter(!) mit der Jahreszahl
einträgt.

\begin{verbatim}
// Mark Schuster, 2012
\end{verbatim}

Ein Block-Kommentar der Form
\begin{verbatim}
/*
 * foo.cpp
 * Implementierung der Aumentisierung als ICE-Funktion
 */
\end{verbatim}
sollte die in der Datei implementierten Funktionen grundsätzlich erklären.

Die Länge der Zeilen im Quelltext sollte 78 Zeichen nicht überschreiten. Alle
Quellcodedateien müssen im utf8-Code kodiert sein. Um Kodierungsproblemen
generell aus dem Weg zu gehen, sollten Umlaute und andere Sonderzeichen nicht
verwendet werden. 

\subsection{Programm-Stil}
Unter einem Modul soll eine Sammlung von Funktionen verstanden werden, die
ähnliche Inhalte für verschiedene Datentypen bereitstellen (zum Beispiel
geometrische Transformationen für Punkte, Bilder und Vektoren) oder Funktionen,
deren unmittelbares Zusammenspiel zum Erreichen einer Wirkung erforderlich
ist (zum Beispiel Startpunktsuche und Konturfolge). 

Ein Modul kann ein oder mehrere .cpp-Dateien mit Quellcode und ein oder
mehrere .h-Header-Dateien umfassen. Oft ist es sinnvoll, {\bf eine} 
Header-Datei und {\bf mehrere} Quellcode-Dateien zu verwenden.

Jede Quellcode-Datei soll den zugehörigen Header einschließen. Dies ist 
notwendig und sinnvoll, weil
\begin{itemize}
\item in den Header-Dateien definierte Konstanten in der Quelldatei angewendet
  werden sollten,
\item Fehler bei Widersprüchen zwischen Deklaration in der Header-Datei und 
Implemetierung eher erkannt werden können.
\end{itemize}

Jede Datei soll genau die Header-Dateien einschließen, die zu ihrer
Übersetzung nötig sind. 
Die ``Sammel-Includedatei'' $image.h$ ist nur für die vereinfachte
Programmierung einfacher Anwendungen gedacht und sollte in 
ICE-Funktionsmodulen nicht verwendet werden. Eine Verwendung in 
ICE-Funktionen selbst hätte zur Folge, dass jede Änderung einer 
Header-Datei die Neuübersetzung aller dieser Module auslöst.

Konstante Werte aller Art sollten in den Header-Dateien als Konstanten 
definiert werden. Konstanten von generellem Interesse sind in ``defs.h''
konzentriert. Konstanten der einzelnen Module oder einzelner Funktionen
sollten in der jeweiligen Header-Datei definiert werden und sollten einen
den Modul oder die Funktion charakterisierenden Prefix erhalten, um
Kollisionen auszuschließen (zum Beispiel: TRM\_SHIFT, TRM\_AFFINE als 
Konstanten für Transformationen). 

Konstanten in Form von Präprozessor-Makros müssen groß geschrieben werden.
Generell sind Konstanten der Form \verb+const int vier = 4;+ Präprozessor-Makros
vorzuziehen. Insbesondere sollten in Klassen statische Klassen-Konstanten
verwendet werden.

Alle ICE-Funktionen sind im Namensraum {\bf ice} zu definieren.

Alle Namen sollten so gewählt werden, dass der Sinn der Funktion, Methode oder
Klasse möglichst gut erkennbar ist. Klassennamen sollten groß geschrieben 
werden, Funktions- und Methoden-Namen klein.
Der Name von Funktionen und Methoden sollte mit einem Verb beginnen.
Schlecht ist zum Beispiel der Name der Funktion {\bf Line()} zum 
Zeichnen von Geraden und Strecken, weil dies keine Aktion beinhaltet. 
Besser wäre also {\bf drawLine()}. 
Einzelne selbständige Namensbestandteile werden groß geschrieben, 
unabhängig davon ob es sich um Substantive handelt oder nicht, 
z.B. fitPolygonContur (CamelCase-Schreibweise).

Neue Datentypen werden vorzugsweise als Klassen angelegt. 
Basisfunktionalität zur Arbeit mit der Klasse sollte als Methode 
implementiert werden. Dazu gehören besonders Konstruktoren, 
Typwandlungskonstruktoren, Zugriffsmethoden.

Bei Typwandlungskonstruktoren ist zu prüfen, wieweit eine versehentliche,
ungewollte Typwandlung auftreten könnte: Ist dies der Fall, sollte der 
Konstruktor durch das Schlüsselwort {\bf explicit} gekennzeichnet werden.

Im Normalfall sollten alle Methoden als {\bf virtual} deklariert
werden. Ausnahmen sind nur bei {\bf zeitkritischen Methoden}
sinnvoll. Dies sollte auch klar dokumentiert werden, da sonst in 
Zusammenhang mit abgeleiteten Klassen ein unerwartetes Verhalten 
auftreten kann.

Umfangreichere Funktionalität sollte nicht als Methode, sondern als Funktion
implementiert werden, da bei Verwendung einer Klasse in einem Programm alle
Methoden dazugelinkt werden.

\subsection{Fehlerbehandlung}
Ziel der Fehlerbehandlung ist, dass Fehlermeldungen möglichst nur durch die
vom Anwender aufgerufenen Funktionen erfolgen. Deshalb muss jede ICE-Funktion,
die andere Funktionen aufruft, bei denen Fehler auftreten können, diese
auswerten und ihrerseits geeignet reagieren.

Das bedeutet, dass vor Aufruf einer Funktion die Fehlermeldungen auszuschalten
sind (\see{OffMessage}) und danach wieder einzuschalten. Die Funktionen zum
Ein- und Ausschalten müssen unbedingt symmetrisch aufgerufen werden, da bei 
Verschachtelung durch Aufruf anderer ICE-Funktionen jedes Ausschalten 
wieder aufgehoben werden muss. 
Nach dem Aufruf ist auf Fehler zu testen und bei Fehler geeignet zu 
reagieren. Das kann auch das einfache Weiterreichen des Fehlers sein 
(mit eventuell angepaßter Fehlermeldung).

Details zur Fehlerbehandlung und geeignete Werkzeuge finden sich im Abschnitt
\see{Fehlerbehandlung}.

\subsection{Dokumentation}
Jede Funktion ist in die Dokumentation aufzunehmen. Die Dokumenation erfolgt
im TEX-Format, woraus sowohl eine druckbare Version als auch eine HTML-Version
erzeugt wird.

Die Funktionen müssen in eine geeignete Sektion eingeordnet werden. Ist keine
entsprechende Sektion vorhanden, so muss diese angelegt werden. Neue Sektionen
sollten neben den Funktionsbeschreibungen auch eine kurze allgemeine Einführung
beinhalten. Diese soll insbesondere die zugrundeliegende Philosophie der
Funktionen verdeutlichen.

Die Beschreibung der Funktionen erfolgt mit folgenden Makros:
\begin{itemize}
\item
\begin{verbatim}
\proch{returntype}{funktionsname}{parameterliste}{includefile}
\end{verbatim}
Kopf der Funktionsdeklaration.
\item
\begin{verbatim}
\procf{returntype}{funktionsname}{parameterliste}
\end{verbatim}
Weitere mögliche Form des Aufrufs, eine Deklaration mit {\bf proch} muss
vorangegangen sein.
\item
\begin{verbatim}
\descr{beschreibung}
\end{verbatim}
Inhaltliche Erklärung der Funktion.
\end{itemize}

Für Klassen erleichtern folgende Latex-Makros die Arbeit:
\begin{itemize}
\item
\begin{verbatim}
\ctor{klassenname}{parameterliste}{includefile}
\end{verbatim}
Der erste Konstruktor einer Klasse.
\item
\begin{verbatim}
\ctorf{klassenname}{parameterliste}
\end{verbatim}
Folgende Konstruktoren einer Klasse. Die Verwendung von \verb+\ctor+ muss
vorausgegangen sein.
\item
\begin{verbatim}
\method{returntype}{methodenname}{parameterliste}
\end{verbatim}
Methoden einer Klasse. Die Verwendung von \verb+\ctor+ muss vorausgegangen 
sein. Die Beschreibung der Methode wird mit \verb+\descr+ angehängt.
\end{itemize}

In der Funktionsbeschreibung werden die Namen von Parametern im 
mathematischen Modus geschrieben, also mit \$ eingeklammert.\\

Beispiel:
\begin{verbatim}
\proch{void}{OpenAlpha}{unsigned char *windowname}{visual.h}
\descr{
Es wird ein Textfenster mit dem Namen $windowname$ angelegt und 
geöffnet. Auch ohne expliziten Aufruf dieser Funktion wird ein 
Textfenster geöffnet, wenn eine Funktion zur Ausgabe bzw. Eingabe 
aufgerufen wird.
}
\end{verbatim}

 
\newpage
\makeatletter{}\nsection{Veraltete Datenstrukturen und Funktionen}{obsolet}
Die in dieser Sektion gesammelten Datenstrukturen und Funktionen sind
veraltet. Ihre Dokumentation ist nur informativ, die Funktionen und Strukturen
sollten nicht mehr genutzt werden. 

\subsection{Vektoren als C-Array}
Die Klassen \class{Vector} bzw. \class{Vector3d} und ihre Methoden 
ersetzen die Funktionen dieses Abschnitts. 
Ein Einsatz sollte nicht mehr erfolgen.

\subsubsection{Dreidimensionale Vektoren}
\proc{double*}{MoveVec}{double v1[3],double v2[3]}
\descr{
Der Vektor $v1$ wird auf den Vektor $v2$ kopiert.
}
\proc{double}{LengthVec}{double v[3]}
\descr{
  Die Euklidische Länge des Vektors $v$ wird berechnet.
}
\proc{double*}{AddVec}{double v1[3],double v2[3],double v3[3]}
\descr{
Die Vektoren $v1$ und $v2$ werden addiert. Das Ergebnis wird auf $v3$
bereitgestellt.
}
\proc{double*}{SubVec}{double v1[3],double v2[3],double v3[3]}
\descr{
Die Vektoren $v1$ und $v2$ werden subtrahiert. Das Ergebnis wird auf $v3$
bereitgestellt.
}
\proc{double*}{NormVec}{double v1[3],double v2[3]}
\descr{
Der Vektor $v1$ wird auf die Länge 1 normiert. Das Ergebnis wird auf
$v2$ bereitgestellt.
}
\proc{double*}{ScaleVec}{double v1[3],double fac,double v2[3]}
\descr{
Die Komponenten des Vektors $v1$ werden mit $fac$ multipliziert. Das Ergebnis wird auf
$v2$ bereitgestellt.
}
\proc{double}{ScalProdVec}{double v1[3],double v2[3]}
\descr{
Rückgabewert ist das Skalarprodukt der Vektoren $v1$ und $v2$.
}
\proc{double*}{CrossProdVec}{double v1[3],double v2[3],double v3[3]}
\descr{
Auf $v3$ wird das Kreuzprodukt der Vektoren $v1$ und $v2$ bereitgestellt.
}
\proc{double}{SpatProdVec}{double v1[3],double v2[3],double v3[3]}
\descr{
Rückgabewert ist das Spatprodukt der Vektoren $v1$, $v2$ und $v3$.
}
\proc{double}{AngleVec}{double v1[3],double v2[3]}
\descr{
Rückgabewert ist der Winkel zwischen Vektoren $v1$ und $v2$.
}

\subsubsection{N-dimensionale Vektoren}

Der Parameter $dim$ in den folgenden Funktionen gibt jeweils die Dimension der
Vektoren an.

\proc{double*}{MoveVecRn}{double *v1,int dim,double *v2}
\descr{
Der Vektor $v1$ wird auf den Vektor $v2$ kopiert.
}
\proc{double}{LengthVecRn}{double *v,int dim}
\descr{
Die Euklidische Länge des Vektors $v$ wird berechnet
}
\proc{double*}{AddVecRn}{double *v1,double *v2,int dim,double *v3}
\descr{
Die Vektoren $v1$ und $v2$ werden addiert. Das Ergebnis wird auf $v3$
bereitgestellt.
}
\proc{double*}{SubVecRn}{double *v1,double *v2,int dim,double *v3}
\descr{
Die Vektoren $v1$ und $v2$ werden subtrahiert. Das Ergebnis wird auf $v3$
bereitgestellt.
}
\proc{double*}{NormVecRn}{double *v1,int dim,double *v2}
\descr{
Der Vektor $v1$ wird auf die Länge 1 normiert. Das Ergebnis wird auf
$v2$ bereitgestellt.
}
\proc{double*}{ScaleVecRn}{double *v1,int dim,double fac,double *v2}
\descr{
Die Komponenten des Vektors $v1$ werden mit $fac$ multipliziert. Das Ergebnis wird auf
$v2$ bereitgestellt.
}
\proc{double}{ScalProdVecRn}{double *v1,double *v2,int dim}
\descr{
Rückgabewert ist das Skalarprodukt der Vektoren $v1$ und $v2$.
}
\proc{double}{AngleVecRn}{double *v1,double *v2,int dim}
\descr{
Rückgabewert ist der Winkel zwischen Vektoren $v1$ und $v2$.
}
\proc{void}{PrintVecRn}{char *str,double *v,int dim}
\descr{Ausgabe von Vektoren auf Standardausgabegerät}

\subsection{Matrizen alten Typs}
\label{MatrixStruct}
Die Klasse \see{Matrix} und ihre Methoden ersetzen die Definitionen und
Funktionen dieses Abschnitts. 
Der Typ $MatrixStruct$ sollte nicht mehr eingesetzt werden.

Die Handhabung von Matrizen ist mit Hilfe von Pointern des Typs $MatrixStruct$
möglich. In der Datenstruktur ist die Größe der Matrix mit abgelegt. Die
Koeffizienten können vom Typ $double$, $int$ oder $char$ sein.

\begprogr\begin{verbatim}
typedef struct MatrixStruct_
{
  int type;
  int rsize,csize;
  double **data;
  int **datai;
  unsigned char **datac;
}  *MatrixStruct;
\end{verbatim}\endprogr

\proc{MatrixStruct}{NewMatrix}{int typ,int rows,int columns}
\descr{
  Es wird eine Matrix mit $rows$ Zeilen, $columns$ Spalten angelegt. Der Typ der
  Koeffizienten ist $double$ für $typ$=MAT\_DOUBLE, $int$ für $typ$=MAT\_INT und
  $char$ für $typ$=MAT\_CHAR.
  Für den Zugriff auf die Koeffizienten einer Matrix ist in Abhängigkeit vom
  vereinbarten Typ der Pointer data (MAT\_DOUBLE), datai (MAT\_INT) oder datac
  (MAT\_CHAR) zu verwenden.
}
\proc{int}{FreeMatrix}{MatrixStruct mat}
\descr{
Die Matrix $mat$ wird freigegeben.
}
\proc{int}{IsMatrix}{MatrixStruct mat}
\descr{
Es wird getestet, ob die Matrix $mat$ eine gültige Matrix ist, d.h ob sie in
der internen Verwaltung geführt ist. Wenn das der Fall ist, wird TRUE
zurückgegeben, sonst FALSE.
}
\proc{MatrixStruct}{MoveMat}{MatrixStruct m1,MatrixStruct m2}
\descr{
Die Matrix $m1$ wird auf die Matrix $m2$ kopiert. Wenn für $m2$ der
NULL-Pointer übergeben wird, wird die Zielmatrix intern angelegt. Rückgabewert
ist bei fehlerfreier Ausführung die Zielmatrix, sonst der NULL-Pointer.
}
\proc{MatrixStruct}{TranspMat}{MatrixStruct m1,MatrixStruct m2}
\descr{
Die Matrix $m1$ wird transponiert und auf die Matrix $m2$ kopiert. Wenn für
$m2$ der NULL-Pointer übergeben wird, wird die Zielmatrix intern
angelegt. Rückgabewert ist bei fehlerfreier Ausführung die Zielmatrix, sonst
der NULL-Pointer. $m1$ bleibt unverändert.
}
\proc{MatrixStruct}{MulMat}{MatrixStruct m1,MatrixStruct m2,MatrixStruct m3}
\descr{
Es wird das Matrizenprodukt $m3=m1*m2$ berechnet. Die Spaltenzahl von $m1$ muß
mit der Zeilenzahl von $m2$ übereinstimmen. Wenn für $m3$ der NULL-Pointer
übergeben wird, wird die Ergebnismatrix intern angelegt. Rückgabewert ist die
Ergebnismatrix bzw. im Fehlerfall der Nullpointer.
}
\proc{int}{MulMatVec}{MatrixStruct A,double *b,double *x}
\descr{
Es wird das Produkt der Matrix $A$ mit dem Vektor $b$ berechnet und auf $x$
bereitgestellt. Die Dimension der Vektoren $b$ bzw. $x$ muß mindestens so groß
wie die Spalten- bzw. Zeilenzahl der Matrix $A$ sein.
}
\proc{MatrixStruct}{InvertMat}{MatrixStruct A,MatrixStruct B}
\descr{
Es wird die Matrix $B$ als Inverse der quadratischen Matrix $A$
berechnet. Wenn für $B$ der NULL-Pointer übergeben wird, wird die Zielmatrix
intern angelegt. Rückgabewert ist bei fehlerfreier Ausführung die Zielmatrix,
sonst der NULL-Pointer. Die Matrix $A$ bleibt unverändert. 
}
\proc{MatrixStruct}{SortMatrix}{MatrixStruct A,int col,int mode}
\descr{
Es wird eine Matrix erzeugt und zurückgegeben, die die Zeilen der Matrix $A$
sortiert enthält. Durch $col$ wird die Spalte angegeben, nach deren Elementen
die Matrix sortiert wird. Mit $mode>=0$ wird in aufsteigender Reihenfolge und
mit $mode<0$ in absteigender Reihenfolge sortiert. Im Fehlerfall wird der
NULL-Pointer zurückgegeben.
}

Die Anwendung von Matrizen soll im folgenden Beispiel verdeutlicht werden:
\begprogr\begin{verbatim}
/*Anwendung von Matrizen*/
#include <stdio.h>
#include <image.h>
void main(void)
{
  MatrixStruct A,B,I;
  int i,j;
  double b[3],x[3];
  A=NewMatrix(MAT_DOUBLE,3,3);           /* Koeffizientenmatrix */
  A->data[0][0]= 3;  A->data[0][1]= 5;  A->data[0][2]=-1;
  A->data[1][0]= 7;  A->data[1][1]=-2;  A->data[1][2]= 3;
  A->data[2][0]=-2;  A->data[2][1]= 1;  A->data[2][2]= 8;
  b[0]=10;  b[1]=12;  b[2]=24;           /* Inhomogenitätsvektor */
  EquationSys(A,b,x);                    /* Gleichungssystem lösen */
  printf("  NormalEquationSys(A,b,x);              /* Diese Lösung ist äquivalent */
  printf("  B=InvertMat(A,NULL);                   /* Koeffizientenmatrix invertieren */
  MulMatVec(B,b,x);                      /* Multiplikation mit Inhomogenität */
  printf("  I=MulMat(A,B,NULL);                    /* Das Produkt ist die Einheitsmatrix */
  for(i=0;i<3;i++)
  { 
    for(j=0;j<3;j++) printf("    printf("\n");
  }
  FreeMatrix(A);                         /* Matrizen freigeben */
  FreeMatrix(B);
  FreeMatrix(I);
} 
\end{verbatim}\endprogr

\subsection{Geometrische Transformationen als double[3][3]}
Projektive und affine 2D-2D-Transformationen können als 3x3-Matrix
(\verb+double m[3][3]+) beschrieben werden.
 
Für neue Anwendungen ist die Klasse \class{Trafo} vorzuziehen.

Es gibt Funktionen, die das Zusammensetzen einer Transformation
aus speziellen affinen Transformationen erlauben. Dabei wird die zu der
hinzuzufügenden Transformation gehörende Matrix jeweils von links mit der
bereits vorhandenen Transformation multipliziert.
\proc{int}{InitTrans}{double tr[3][3]}
\descr{Initialisieren einer Transformationsmatrix (Einheitsmatrix)}
\proc{int}{ShiftTrans}{double x0, double y0, double tr[3][3]}
\descr{Hinzufügen einer Translation mit $(x0,y0)$}
\proc{int}{RotTrans}{double x0, double y0, double phi, double tr[3][3]}
\descr{Hinzufügen einer Rotation mit dem Winkel $phi$ (Bogenmaß) um den 
Punkt $(x0,y0)$} 
\proc{int}{ScaleTrans}{double x0, double y0, double a, double b, double
tr[3][3]}
\descr{Hinzufügen einer anisotropen Skalierung mit dem Faktor $a$ in
x-Richtung und dem Faktor $b$ in y-Richtung}
\proc{int}{InvertTrans}{double tr[3][3]}
\descr{Die Transformation $tr$ wird invertiert.}
\proc{int}{FitAffineTrans}{PointList pl1,PointList pl2,double tr[3][3]}
\descr{Es wird mittels Ausgleichsrechnung eine affine Transformation
bestimmt, die die Punkte der Liste $pl1$ auf die Punkte der Liste $pl2$
transformiert. Punkte mit gleichem Index werden jeweils als Korrespondenzpaar
interpretiert. Die Punktepaare werden mit dem Gewicht aus der Liste $pl2$
gewichtet.
}
\seealso{MatchPointlists}
\seealsonext{AffinFitMoments}
\proc{int}{FitProjectiveTrans}{PointList pl1,PointList pl2,double tr[3][3]}
\descr{Es wird mittels Ausgleichsrechnung eine projektive Transformation
bestimmt, die die Punkte der Liste $pl1$ auf die Punkte der Liste $pl2$
transformiert. Punkte mit gleichem Index werden jeweils als Korrespondenzpaar
interpretiert. Die Punktepaare werden mit dem Gewicht aus der Liste $pl2$
gewichtet. 
}
\proc{double*}{TransPoint}{double p1[2],double tr[3][3],double p2[2]}
\descr{Der Punkt $p1$ wird mit der Transformation $tr$ in den Punkt $p2$
transformiert.
}
\proc{int}{TransImg}{Image imgs,double tr[3][3],int mode,Image imgd}
\descr{Das Bild $imgs$ wird mit der Transformation $tr$ in das Bild $imgd$
transformiert. Da man bei der Transformation der Bildpunkte im allgemeinen
keine ganzzahligen Koordinaten erhält, werden die Grauwerte für
$mode$=INTERPOL bilinear interpoliert, bei $mode$=DEFAULT werden die
Koordinaten gerundet.
}
\seealso{Transform}
\proc{Contur}{TransContur}{Contur c,double tr[3][3]}
\descr{
Es wird eine Kontur angelegt, die sich aus der Transformation der Kontur $c$
mit $tr$ ergibt.
}

\subsection{Statistische Maßzahlen mehrdimensionaler Zufallsvariablen}

Im Normalfall sollten die neuen Statistikfunktionen zur Klasse
\class{Statistics} verwendet werden.

Diese Funktionen zur Berechnung von statistischen Maßzahlen mehrdimensionaler
Zufallsvariablen (Mittelwertvektor, Kovarianz- und Korrelationsmatrix)
arbeiten mit einer Datenstruktur, auf die über einen Pointer vom Typ
$Statistic$ zugegriffen wird.

\proc{Statistic}{InitStatistic}{int dim}
\descr{Initialisierung eines Statistikbereiches für Zufallsvektoren der
Dimension $dim$
}
\proc{int}{PutStatistic}{Statistic st,double v[dim],double weight}
\descr{Gewichteter Eintrag eines Zufallsvektors in den Statistikbereich. Die
Dimension muß mit der bei der Initialisierung angegebenen Dimension
Übereinstimmen.
}
\proc{int}{GetStatisticDim}{Statistic st,int *dim}
\descr{Dimension $dim$ des Statistikbereiches abfragen.}
\proc{int}{GetStatisticWeight}{Statistic st,double *sweight}
\descr{Es wird die Summe der Gewichte bestimmt.}
\proc{int}{GetStatisticMean}{Statistic st,double *mean}
\descr{Es wird der Mittelwertvektor bestimmt.}
\proc{MatrixStruct}{GetStatisticCov}{Statistic st,MatrixStruct cov}
\descr{
Für die in $st$ akkumulierten Realisierungen wird die Kovarianzmatrix
$cov$ bestimmt. $cov$ muß eine Gleitkomma-Matrix sein, ihre Dimension muß mit
derjenigen der Zufallsvektoren übereinstimmen. Wenn für $cov$ der NULL-Pointer
übergeben wird, wird die Kovarianzmatrix intern angelegt. Rückgabewert ist die
Kovarianzmatrix oder bei Fehlern der NULL-Pointer
}
\proc{MatrixStruct}{GetStatisticCor}{Statistic st,MatrixStruct cor}
\descr{
Für die in $st$ akkumulierten Realisierungen wird die Korrelationsmatrix
$cor$ bestimmt. $cor$ muß eine Gleitkomma-Matrix sein, ihre Dimension muß mit
derjenigen der Zufallsvektoren übereinstimmen. Wenn für $cov$ der NULL-Pointer
übergeben wird, wird die Korrelationsmatrix intern angelegt. Rückgabewert ist die
Korrelationsmatrix oder bei Fehlern der NULL-Pointer
}
\proc{int}{WriteStatistic}{Statistic st,char *file}
\descr{Die Daten des Statistikbereiches werden für eine spätere
Weiterbearbeitung in ein Textfile $file$ geschrieben.}
\proc{Statistic}{ReadStatistic}{char *file}
\descr{Ein mit WriteStatistic() geschriebener Statistikbereich wird vom File
$file$ eingelesen.}

\subsection{Momente als Feld vom Typ double}

Einige veraltete Funktionen verwenden Felder vom Typ $double$ um Momente
abzulegen. Diese sollten nicht mehr verwendet werden. Ersatz dafür ist 
die Klasse \class{Moments}.

Momente werden in Feldern vom Typ $double$ in der Reihenfolge $m_{00}$,
$m_{10}$, $m_{01}$, $m_{20}$, $m_{11}$, $m_{02}$, $m_{30}$, $m_{21}$,
$m_{12}$, $m_{03}$, $m_{40}$, $m_{31}$, $m_{22}$, $m_{13}$, $m_{04}$
abgelegt. Bei der Berechnung der Momente erfolgt keine Normierung auf den
Schwerpunkt.

\proc{int}{MomentPolygon}{PointList p,double m[15],double s[2]}
\procf{int}{MomentPolygon}{const Matrix \&p,double m[15],double s[2]}
\descr{Es werden die Flächenmomente des durch die Punktliste $pl$
beschriebenen Polygons berechnet. Auf $s$ wird der Flächenschwerpunkt
bereitgestellt. Die Vorzeichen der Momente sind von der Orientierung
(Umlaufsinn) des Polygons abhängig.}
\proc{int}{PointListMoment}{PointList pl,int a1,int a2,double m[15],double s[2]}
\descr{Es werden die Flächenmomente eines Teilpolygons berechnet, dessen
Eckpunkte in der Punktliste $pl$ von Adresse $a1$ bis Adresse $a2$ stehen. Auf
$s$ wird der Flächenschwerpunkt bereitgestellt.}
\proc{int}{MomentRegion}{Contur c, double m[15], double s[2]}
\descr{Es werden die Flächenmomente der durch die Kontur $c$ umschlossenen
Fläche berechnet. Auf $s$ wird der Flächenschwerpunkt bereitgestellt.
Das Moment $m_{00}$ ist hier immer nichtnegativ.}

\subsubsection{Transformation von Momenten}

\proc{int}{TranslateMoments}{const double m1[15],double x,double y,double m2[15]}
\descr{
Transformation der Momente $m1$ entsprechend einer Translation mit $(x,y)$.}
\proc{int}{AffinTransMoments}{const double m1[15],double tr[3][3],double m2[15]}
\descr{Affine Transformation der Momente $m1$ entsprechend der
Transformationsmatrix $tr$.}
\proc{int}{XShearMoments}{const double m[15],double a,double ms[15]}
\descr{Transformation der Momente durch X-Scherung.}
\proc{int}{YShearMoments}{const double m1[15],double b,double m2[15]}
\descr{Transformation der Momente durch Y-Scherung.}
\proc{int}{ScaleMoments}{const double m1[15],double a,double b, double m2[15]}
\descr{Transformation der Momente durch anisotrope Skalierung.}
\proc{int}{RotateMoments}{const double m1[15],double c,double s, double m2[15]}
\descr{Transformation der Momente durch Rotation. $c$ und $s$ geben den
Cosinus bzw. den Sinus des Rotationswinkels an.}

\proc{int}{CalcCentralMoments}{const double m[15],double mc[15]}
\descr{Berechnet aus den Momenten in $m$ die zentralen Momente $mc$.}

\proc{int}{NormalizeMoments}{const double m1[15],double m2[15]}
\descr{Normierung der Momente $m1$ auf vergleichbare Größen, 
indem die n-ten Momente
durch $m_{00}^{(1+{n \over 2})}$ dividiert werden. Die normierten Momente
werden auf $m2$ bereitgestellt.}

\subsubsection{Algebraische Momentinvarianten}

\proc{int}{AffinAlgebraicInvar}{double m[15],double flu[4]} 
\descr{Aus den Momenten $m$ werden algebraische Invarianten nach Flusser
  berechnet und auf $flu$ bereitgestellt.}  
\proc{int}{AffinHuInvar}{double m[15],double hu[7]}
\descr{Nach einer Scherungsnormierung werden aus den Momenten $m$ 7
  Invarianten nach Hu berechnet und auf $hu$ bereitgestellt, die affin
  invariant sind.}

\subsubsection{Affine Standardlagen}

Durch die Normierung bestimmter Momente können affine Transformationen
bestimmt werden, die das zugehörige Objekt in eine Standardlage überführen.
\proc{int}{AffinNormMoments}{double m[21],double maf[21],double atr[3][3]}
\descr{ Berechnung einer Standardlage durch Normierung von Momenten
  auf $(m_{20}=1; m_{11}=0; m_{02}=1; m_{30}+m_{12}=0)$. Die Momente in der
  Standardlage werden auf $maf$ bereitgestellt, die affine Transformation zur
  Überführung in die Standardlage auf $atr$.}
\proc{int}{PolyNormMoments}{double m[21],double maf[21],double atr[3][3]}
\descr{ Berechnung einer Standardlage mit der Polynommethode durch Normierung
  der Momente auf $(m_{30}=0; m_{11}=0; m_{20}=1; m_{02}=1)$. Die Momente in
  der Standardlage werden auf $maf$ bereitgestellt, die affine Transformation
  zur Überführung in die Standardlage auf $atr$.}
\proc{int}{AffinIterateMoments}{double m[21],double maf[21],double atr[3][3]}
\descr{Berechnung einer Standardlage mit der Iterationsmethode durch
  Normierung der Momente auf $(m_{31}=0; m_{13}=0; m_{20}=1; m_{02}=1)$. Die
  Momente in der Standardlage werden auf $maf$ bereitgestellt, die affine
  Transformation zur Überführung in die Standardlage auf $atr$.  }

\subsubsection{Fitting mit Momenten}

\proc{double}{AffinFitMoments}{double m1[15],double m2[15],double tr[3][3]}
\descr{ Es wird eine affine Transformation bestimmt, die approximativ das
  Objekt mit den Momenten $m1$ in das Objekt mit den Momenten $m2$ überführt.
  Rückgabewert ist ein Fehlermaß, das die Abweichung der mit $tr$
  transformierten Momente $m1$ von $m2$ beschreibt. Der Algorithmus ist sehr
  schnell, versagt aber bei Objekten, die ausgezeichnete Symmetrien aufweisen,
  z.B. ähnlich einem Dreieck, einem Rechteck oder Quadrat. Bei Objekten, bei
  denen man a priori solche Symmetrien ausschliessen kann, arbeitet der
  Algorithmus sicher und ist sehr robust.}
\seealso{MatchObject}
\proc{double}{AffinFitPolygons}{PointList pl1,PointList pl2,double tr[3][3]}
\descr{ Es wird eine affine Transformation bestimmt, die approximativ das
  Objekt (Polygon) $pl1$ in das Objekt $pl22$ überführt. Rückgabewert ist ein
  Fehlermaß, das die Abweichung der mit $tr$ transformierten Punktliste $pl1$
  von $pl2$ beschreibt. Der Algorithmus ist sehr
  schnell, versagt aber bei Objekten, die ausgezeichnete Symmetrien aufweisen,
  z.B. ähnlich einem Dreieck, einem Rechteck oder Quadrat. Bei Objekten, bei
  denen man a priori solche Symmetrien ausschliessen kann, arbeitet der
  Algorithmus sicher und ist sehr robust.}
\proc{int}{FitTriangleMoments}{double moment[15],double corner[3][2]}
\descr{
Es werden die drei Eckpunkte $corner$ eines Dreiecks bestimmt, das mit der 
Polynommethode an das Objekt mit den Flächenmomenten $moment$ angepaßt ist.
}
\proc{int}{FitRectangleMoments}{double moment[15],double corner[4][2]}
\descr{
Es werden die vier Eckpunkte $corner$ eines Rechteckes bestimmt, das mit einer 
Momenten-Normierungsmethode an das Objekt mit den Flächenmomenten $moment$ angepaßt ist.
}
\proc{int}{FitParallelogramMoments}{double moment[15],double corner[4][2]}
\descr{
Es werden die vier Eckpunkte $corner$ eines Parallelogrammes bestimmt, das mit einer 
Momenten-Normierungsmethode an das Objekt mit den Flächenmomenten $moment$ angepaßt ist.
}
\proc{int}{FitParallelogramMoments}{double moment[15],double corner[4][2], double \& guetemass}
\descr{
Es werden die vier Eckpunkte $corner$ eines Parallelogrammes bestimmt, das mit einer 
Momenten-Normierungsmethode an das Objekt mit den Flächenmomenten $moment$ angepaßt ist.
Die Variable $guetemass$ erhält den quadratischen Abstand zwischen den Referenzmomenten
und den normierten Momenten des Objektes.
}

\proc{int}{FitQuadrangleMoments}{double moment[15],double corner[4][2]}
\descr{
Es werden die vier Eckpunkte $corner$ eines beliebigen Vierecks bestimmt, das mit einer 
Momenten-Normierungsmethode an das Objekt mit den Flächenmomenten $moment$ angepaßt ist.
}

\proc{int}{FitCircleMoments}{double moment[15],double \&x0,double \&y0,double \&radius}
\descr{
Es werden der Mittelpunkt $x0,y0$ und der Radius $radius$ eines Kreises bestimmt, der mit einer 
Momenten-Normierungsmethode an das Objekt mit den Flächenmomenten $moment$ angepaßt ist.
}
\proc{int}{FitCircularSegmentMoments}{double moment[15],double
circle\_par[3],double line\_start[2],double line\_end[2]}
\descr{
Eingabe sind die 15 Flächenmomente $moment$ des Objektes. Es wird
an das Objekt ein Kreissegment angepaßt. Dies ist kein Bogensegment eines
Kreises, sondern das gesamte Flächen-Objekt wird aufgefaßt als ein Kreis, von
dem ein Stück abgeschnitten wurde. Das Keissegment wird daher beschrieben
durch die eigentlichen Kreisparameter $circle\_par[3]$ in der Reihenfolge
Mittelpunkt und Radius (\see{DrawCircle}) und durch eine Strecke, die den Kreis
beschneidet. Dabei beschreibt $line\_start[2]$ den Anfangspunkt der Strecke und
$line\_end[2]$ den Endpunkt der Strecke. Als Algorithmus wird eine
Momenten-Normierungs-Methode verwendet.
}
\proc{int}{FitEllipseMoments}{double moment[15],double ell\_par[5]}
\descr{
Eingabe sind die 15 Flächenmomente $moment$ des Objektes. Es wird
an das Objekt eine Ellipse angepaßt. Diese Ellipse ist die bekannte
Trägheitsellipse eines Objektes, wobei die Größe der Trägkeitsellipse noch auf
die Größe des Objektes normiert wurde. Die 5 Ergebnisparameter in $ell\_par[5]$
der Ellipse sind genauso aufgebaut wie in allen anderen Funktionen, siehe (\see{DrawEllipse}).
}

\proc{int}{FitEllipticalSegmentMoments}{double moment[15],double
ell\_par[5],double line\_start[2],double line\_end[2]}
\descr{
Eingabe sind die 15 Flächenmomente $moment$ des Objektes. Es wird
an das Objekt ein Ellipsensegment angepaßt. Dies ist kein Bogensegment einer
Ellipse, sondern das gesamte Flächen-Objekt wird aufgefaßt als eine Ellipse, von
der ein Stück abgeschnitten wurde. Das Ellipsensegment wird daher beschrieben
durch die eigentlichen 5 Ellipsenparameter $ell\_par[5]$
(\see{DrawEllipse})  und durch eine Strecke, die die Ellipse
beschneidet. Dabei beschreibt $line\_start[2]$ den Anfangspunkt der Strecke und
$line\_end[2]$ den Endpunkt der Strecke. Als Algorithmus wird eine
Momenten-Normierungs-Methode verwendet.
}
\proc{int}{FitSuperEllipseMoments}{double moment[15],double
\&c1,double \&f1,double tr1[3][3],double \&c2,double \&f2,double tr2[3][3]}
\descr{
Eingabe sind die 15 Flächenmomente $moment$ des Objektes. Es wird
an das Objekt eine Super-Ellipse angepaßt. Da für bestimmte Situationen zwei
gute Lösungen existieren, werden diese alle beide berechnet. Der
Approximationswert ist $f1$ bzw. $f2$, es sollte die Lösung genommen werden,
für die dieser Wert kleiner ist. Die eigentlichen Super-Ellipse Parameter sind
dann der Exponent $c1$ bzw. $c2$ und eine affine Transformation $tr1[3][3]$
bzw. $tr2[3][3]$. Zur grafischen Darstellung der gefitteten Super-Ellipse kann
die Funktion DrawSuperEllipse (\see{DrawSuperEllipse}) benutzt werden. Als 
Algorithmus wird eine Momenten-Normierungs-Methode verwendet.
}

 
\newpage
\makeatletter{}\nsection{Mitarbeit an ICE}{contribution}

Die Bibliothek ICE wird seit 1992 von der Bildverarbeitungsgruppe der
Friedrich-Schiller-Universität Jena entwickelt.
Die größte Teil entstand als Resultat von Arbeiten der Mitarbeiter der Gruppe.
Zusätzliche Beiträge entstanden im Rahmen von studentischen Arbeiten.

Beiträge durch andere Personen sind erwünscht und werden in die Bibliothek
gern aufgenommen und hier ebenfalls gewürdigt.

\begin{itemize}
\item Dr. Wolfgang Ortmann 1992..
\item Dr. Herbert Süße 1992..
\item Dr. Michael Schubert 1992..1997
\item Dr. Ralf Neubauer 1992..1996
\item Dr. Steffen Abraham 1992..1995
\item Michael Trummer 2005..
\item Erik Rodner 2006
\item Ferid Bajramovic 2005..
\item Olaf Kähler 2005..
\item Torsten Baumbach 1997..2000
\item Udo Toedter 1992..1993
\item Mathias Hegner 1992..1993
\item Stefan Ensslen 2004
\item Fred Thiele 2005
\end{itemize}

 
\newpage
\section{Funktionsliste}
\subsection{Thematisch sortierte Funktionsliste}
\makeatletter{}\subtitle{\hyperlink{SECTION:Images}{Datenstrukturen f\"ur Bilder}}\\
\functionlistentry{\hyperlink{Image}{Image}}{ColorImage::blueImage}{void}{29}{Images}{}
\functionlistentry{}{ColorImage::ColorImage}{}{15}{Images}{}
\functionlistentry{}{ColorImage::ColorImage}{const \hyperlink{ColorImage}{ColorImage} \&img}{16}{Images}{}
\functionlistentry{}{ColorImage::ColorImage}{const \hyperlink{ColorImage}{ColorImage} \&img,const \hyperlink{Window}{Window} \&w,const string \&title=''''}{32}{Images}{}
\functionlistentry{void}{ColorImage::copy}{const \hyperlink{ColorImage}{ColorImage} \&src}{19}{Images}{}
\functionlistentry{void}{ColorImage::create}{int xsize,int ysize,int maxval,const string \&title=''''}{17}{Images}{}
\functionlistentry{void}{ColorImage::create}{const \hyperlink{ColorImage}{ColorImage} \&img,const string \&title=''''}{18}{Images}{}
\functionlistentry{static \hyperlink{ColorImage}{ColorImage}}{ColorImage::createColorImage}{int sizeX, int sizeY, int maxValue, const std::string \&title = ''''}{20}{Images}{}
\functionlistentry{static \hyperlink{ColorImage}{ColorImage}}{ColorImage::createColorImage}{const \hyperlink{ColorImage}{ColorImage} \&src, bool copy, const std::string \&title = ''''}{21}{Images}{}
\functionlistentry{\hyperlink{ColorValue}{ColorValue}}{ColorImage::getPixel}{int x,int y}{36}{Images}{}
\functionlistentry{\hyperlink{ColorValue}{ColorValue}}{ColorImage::getPixel}{IPoint p}{37}{Images}{}
\functionlistentry{\hyperlink{ColorValue}{ColorValue}}{ColorImage::getPixelUnchecked}{int x,int y}{40}{Images}{}
\functionlistentry{\hyperlink{ColorValue}{ColorValue}}{ColorImage::getPixelUnchecked}{IPoint p}{41}{Images}{}
\functionlistentry{\hyperlink{Image}{Image}}{ColorImage::greenImage}{void}{28}{Images}{}
\functionlistentry{bool}{ColorImage::inside}{const IPoint p}{61}{Images}{}
\functionlistentry{bool}{ColorImage::inside}{int x,int y}{62}{Images}{}
\functionlistentry{bool}{ColorImage::inside}{const \hyperlink{Window}{Window} \&w}{63}{Images}{}
\functionlistentry{bool}{ColorImage::isValid}{}{25}{Images}{}
\functionlistentry{\hyperlink{ColorImage}{ColorImage}}{ColorImage::operator()}{const \hyperlink{Window}{Window} \&w}{33}{Images}{}
\functionlistentry{\hyperlink{Image}{Image}}{ColorImage::redImage}{void}{27}{Images}{}
\functionlistentry{void}{ColorImage::setPixel}{int x,int y,\hyperlink{ColorValue}{ColorValue} cv}{48}{Images}{}
\functionlistentry{void}{ColorImage::setPixel}{IPoint p,\hyperlink{ColorValue}{ColorValue} cv}{49}{Images}{}
\functionlistentry{void}{ColorImage::setPixelUnchecked}{int x,int y,\hyperlink{ColorValue}{ColorValue} cv}{52}{Images}{}
\functionlistentry{void}{ColorImage::setPixelUnchecked}{IPoint p,\hyperlink{ColorValue}{ColorValue} cv}{53}{Images}{}
\functionlistentry{int}{ConvImgDImg}{ImageD imgs,\hyperlink{Image}{Image} imgd,int modus=ADAPTIVE,int sign=UNSIGNED}{85}{Images}{}
\functionlistentry{int}{ConvImgImgD}{const \hyperlink{Image}{Image} \&imgs,ImageD imgd,int modus=RAW,int sign=UNSIGNED}{86}{Images}{}
\functionlistentry{static \hyperlink{Image}{Image}}{createImage}{const \hyperlink{Image}{Image} \&src, bool copy, const std::string \&title = ''''}{9}{Images}{}
\functionlistentry{int}{FreeImg}{\hyperlink{Image}{Image} \&img}{12}{Images}{}
\functionlistentry{int}{FreeImg}{\hyperlink{ColorImage}{ColorImage} \&img}{24}{Images}{}
\functionlistentry{int}{FreeImgD}{ImageD img}{87}{Images}{}
\functionlistentry{double}{GetInterpolVal}{\hyperlink{Image}{Image} img,double x,double y}{69}{Images}{}
\functionlistentry{bool}{GetInterpolVal}{\hyperlink{Image}{Image} img,double x,double y,double \&val}{70}{Images}{}
\functionlistentry{int}{GetVal}{const \hyperlink{Image}{Image} \&img,int x,int y}{65}{Images}{}
\functionlistentry{int}{GetVal}{const \hyperlink{Image}{Image} \&img,double x,double y,mode=DEFAULT}{66}{Images}{}
\functionlistentry{int}{GetVal}{const \hyperlink{Image}{Image} img,const IPoint \&p}{68}{Images}{}
\functionlistentry{double}{GetValD}{ImageD img,int x,int y}{81}{Images}{}
\functionlistentry{double}{GetValue}{ImageD img,IPoint p}{83}{Images}{}
\functionlistentry{void*}{Image-$>$getDataPointer}{}{72}{Images}{}
\functionlistentry{int}{Image-$>$ImageType}{}{71}{Images}{}
\functionlistentry{}{Image3d}{int xs, int ys, int zs, int maxval = 255, double xscale = 1.0, double yscale = 1.0, double zscale = 1.0}{73}{Images}{}
\functionlistentry{}{Image3d}{const std::string \&filemask, double xscale = 1.0, double yscale = 1.0, double zscale = 1.0}{74}{Images}{}
\functionlistentry{}{Image3d}{const Image3d \&src, bool copydata = true}{75}{Images}{}
\functionlistentry{}{Image3d}{const Image3d \&src, Window3d w}{76}{Images}{}
\functionlistentry{void}{Image::copy}{const \hyperlink{Image}{Image} \&src}{7}{Images}{}
\functionlistentry{void}{Image::create}{int xsize,int ysize,int maxval,const string \&title=''''}{5}{Images}{}
\functionlistentry{void}{Image::create}{const \hyperlink{Image}{Image} \&img,const string \&title=''''}{6}{Images}{}
\functionlistentry{static \hyperlink{Image}{Image}}{Image::createImage}{int sizeX, int sizeY, int maxValue, const std::string \&title = ''''}{8}{Images}{}
\functionlistentry{int}{Image::getIntensity}{int x,int y}{42}{Images}{}
\functionlistentry{int}{Image::getIntensity}{IPoint p}{43}{Images}{}
\functionlistentry{int}{Image::getIntensityUnchecked}{int x,int y}{44}{Images}{}
\functionlistentry{int}{Image::getIntensityUnchecked}{IPoint p}{45}{Images}{}
\functionlistentry{int}{Image::getPixel}{int x,int y}{34}{Images}{}
\functionlistentry{int}{Image::getPixel}{IPoint p}{35}{Images}{}
\functionlistentry{int}{Image::getPixelUnchecked}{int x,int y}{38}{Images}{}
\functionlistentry{int}{Image::getPixelUnchecked}{IPoint p}{39}{Images}{}
\functionlistentry{}{Image::Image}{}{3}{Images}{}
\functionlistentry{}{Image::Image}{const \hyperlink{Image}{Image} \&img}{4}{Images}{}
\functionlistentry{}{Image::Image}{const \hyperlink{Image}{Image} \&img,const \hyperlink{Window}{Window} \&w,const string \&title=''''}{30}{Images}{}
\functionlistentry{bool}{Image::inside}{const IPoint p}{58}{Images}{}
\functionlistentry{bool}{Image::inside}{int x,int y}{59}{Images}{}
\functionlistentry{bool}{Image::inside}{const \hyperlink{Window}{Window} \&w}{60}{Images}{}
\functionlistentry{bool}{Image::isValid}{}{13}{Images}{}
\functionlistentry{\hyperlink{Image}{Image}}{Image::operator()}{const \hyperlink{Window}{Window} \&w}{31}{Images}{}
\functionlistentry{int}{Image::setIntensity}{int x,int y,int value}{54}{Images}{}
\functionlistentry{int}{Image::setIntensity}{IPoint p,int value}{55}{Images}{}
\functionlistentry{int}{Image::setIntensityUnchecked}{int x,int y,int value}{56}{Images}{}
\functionlistentry{int}{Image::setIntensityUnchecked}{IPoint p,int value}{57}{Images}{}
\functionlistentry{void}{Image::setPixel}{int x,int y,int value}{46}{Images}{}
\functionlistentry{void}{Image::setPixel}{IPoint p,int value}{47}{Images}{}
\functionlistentry{void}{Image::setPixelUnchecked}{int x,int y,int value}{50}{Images}{}
\functionlistentry{void}{Image::setPixelUnchecked}{IPoint p,int value}{51}{Images}{}
\functionlistentry{bool}{IsImg}{const \hyperlink{Image}{Image} \&img}{14}{Images}{}
\functionlistentry{bool}{IsImg}{const \hyperlink{ColorImage}{ColorImage} \&img}{26}{Images}{}
\functionlistentry{\hyperlink{Image}{Image}}{NewImg}{int xsize,int ysize,int maxval,const string \&title=''''}{10}{Images}{}
\functionlistentry{\hyperlink{Image}{Image}}{NewImg}{const \hyperlink{Image}{Image} \&img,int copy=false,const string \&title=''''}{11}{Images}{}
\functionlistentry{\hyperlink{ColorImage}{ColorImage}}{NewImg}{int xsize,int ysize,int maxval,const string \&title=''''}{22}{Images}{}
\functionlistentry{\hyperlink{ColorImage}{ColorImage}}{NewImg}{const \hyperlink{ColorImage}{ColorImage} \&img,int copy=false,const string \&title=''''}{23}{Images}{}
\functionlistentry{ImageD}{NewImgD}{int xsize,int ysize,double minval=0.0,double maxval=0.0}{77}{Images}{}
\functionlistentry{ImageD}{NewImgD}{ImageD img,bool copy=false}{78}{Images}{}
\functionlistentry{ImageD}{NewImgD}{const \hyperlink{Image}{Image} \&img,bool copy=false}{79}{Images}{}
\functionlistentry{void}{PutVal}{\hyperlink{Image}{Image} \&img,int x,int y,int val}{64}{Images}{}
\functionlistentry{void}{PutVal}{\hyperlink{Image}{Image} \& img,const IPoint \&p,int val}{67}{Images}{}
\functionlistentry{void}{PutValD}{ImageD img,int x,int y,double val}{80}{Images}{}
\functionlistentry{void}{PutValue}{ImageD img,IPoint p,double val}{82}{Images}{}
\functionlistentry{int}{UpdateLimitImgD}{ImageD img}{84}{Images}{}

\subtitle{\hyperlink{SECTION:Visualisierung}{Visualisierung von Bildern und interaktive Auswahl}}\\
\functionlistentry{int}{Cursor}{int mode,\hyperlink{Image}{Image} img,int x,int y}{95}{Visualisierung}{}
\functionlistentry{int}{InfVis}{int code}{99}{Visualisierung}{}
\functionlistentry{int}{Mouse}{\hyperlink{Image}{Image} img,int *x,int *y}{100}{Visualisierung}{}
\functionlistentry{int}{Mouse}{\hyperlink{Image}{Image} img,int \&x,int \&y}{101}{Visualisierung}{}
\functionlistentry{int}{SelectWindow}{const \hyperlink{Image}{Image} \&img,int mode}{111}{Visualisierung}{}
\functionlistentry{int}{SelPoint}{int mode,const \hyperlink{Image}{Image} \&img,int p[2]}{102}{Visualisierung}{}
\functionlistentry{IPoint}{SelPoint}{int mode,const \hyperlink{Image}{Image} \&img}{103}{Visualisierung}{}
\functionlistentry{IPoint}{SelPoint}{int mode,const \hyperlink{Image}{Image} \&img,int \&rc}{104}{Visualisierung}{}
\functionlistentry{\hyperlink{Point}{Point}}{SelPoint}{const \hyperlink{Image}{Image} \&img,int \&rc}{105}{Visualisierung}{}
\functionlistentry{\hyperlink{Point}{Point}}{SelPoint}{const \hyperlink{Image}{Image} \&img}{106}{Visualisierung}{}
\functionlistentry{IVector}{SelVector}{int mode,const \hyperlink{Image}{Image} \&img,int \&rc}{107}{Visualisierung}{}
\functionlistentry{IVector}{SelVector}{int mode,const \hyperlink{Image}{Image} \&img}{108}{Visualisierung}{}
\functionlistentry{IVector}{SelVector}{const \hyperlink{Image}{Image} \&img,int \&rc}{109}{Visualisierung}{}
\functionlistentry{IVector}{SelVector}{const \hyperlink{Image}{Image} \&img}{110}{Visualisierung}{}
\functionlistentry{int}{SetGreyColor}{int val,int red,int green,int blue}{96}{Visualisierung}{}
\functionlistentry{int}{SetGreyLUT}{int val1,int val2}{97}{Visualisierung}{}
\functionlistentry{int}{SetOverlayColor}{int val,int red,int green,int blue}{98}{Visualisierung}{}
\functionlistentry{int}{Show}{int mode,\hyperlink{Image}{Image} img,const string \& title=''''}{89}{Visualisierung}{}
\functionlistentry{int}{Show}{int mode,\hyperlink{Image}{Image} img1,\hyperlink{Image}{Image} img2,const string \& title=''''}{90}{Visualisierung}{}
\functionlistentry{int}{Show}{int mode,\hyperlink{Image}{Image} img1,\hyperlink{Image}{Image} img2,\hyperlink{Image}{Image} img3,const string \&title=''''}{91}{Visualisierung}{}
\functionlistentry{int}{Show}{const \hyperlink{ColorImage}{ColorImage} \& img, int mode=ON}{92}{Visualisierung}{}
\functionlistentry{int}{Zoom}{\hyperlink{Image}{Image} img,int val,int x,int y}{93}{Visualisierung}{}
\functionlistentry{int}{Zoom}{\hyperlink{Image}{Image} img}{94}{Visualisierung}{}

\subtitle{\hyperlink{SECTION:imageio}{Ein- und Ausgabe von Bilddaten}}\\
\functionlistentry{int}{InfImgFile}{const string \&filename, int \&xsize, int \&ysize, int \&maxval,int \&nr}{117}{imageio}{}
\functionlistentry{int}{InfImgFile}{const string \&filename, int \&xsize, int \&ysize, int \&maxval}{118}{imageio}{}
\functionlistentry{int}{ReadColorImageCache$<$T$>$::FrameNumber}{}{137}{imageio}{}
\functionlistentry{int}{ReadColorImageCache$<$T$>$::getError}{}{139}{imageio}{}
\functionlistentry{bool}{ReadColorImageCache$<$T$>$::Read}{const \hyperlink{ColorImage}{ColorImage} \&img,int frame}{134}{imageio}{}
\functionlistentry{bool}{ReadColorImageCache$<$T$>$::Read}{const \hyperlink{Image}{Image} \&imgr,const \hyperlink{Image}{Image} \&imgg,const \hyperlink{Image}{Image} \&imgb,int frame}{135}{imageio}{}
\functionlistentry{}{ReadColorImageCache$<$T$>$::ReadColorImageCache}{T \&tr,int xsize,int ysize,int maxval,int csize}{132}{imageio}{}
\functionlistentry{int}{ReadImageCache$<$T$>$::FrameNumber}{}{136}{imageio}{}
\functionlistentry{int}{ReadImageCache$<$T$>$::getError}{}{138}{imageio}{}
\functionlistentry{bool}{ReadImageCache$<$T$>$::Read}{const \hyperlink{Image}{Image} \&img,int frame=ReadImagCache$<$T$>$::next}{133}{imageio}{}
\functionlistentry{}{ReadImageCache$<$T$>$::ReadImageCache}{T \&tr,int xsize,int ysize,int maxval,int csize}{131}{imageio}{}
\functionlistentry{\hyperlink{Image}{Image}}{ReadImg}{const string \&filename,\hyperlink{Image}{Image} \&img,int flag=IB\_SCALE}{113}{imageio}{}
\functionlistentry{int}{ReadImg}{const string \&file,\hyperlink{Image}{Image} \&imgr,\hyperlink{Image}{Image} \&imgg,\hyperlink{Image}{Image} \&imgb, int flag=IB\_SCALE}{115}{imageio}{}
\functionlistentry{int}{ScanImg}{int ch,\hyperlink{Image}{Image} \&pi,int interactive=TRUE}{148}{imageio}{}
\functionlistentry{int}{ScanImg}{int ch,\hyperlink{Image}{Image} \&pr,\hyperlink{Image}{Image} \&pg,\hyperlink{Image}{Image} \&pb,int interactive=TRUE}{149}{imageio}{}
\functionlistentry{int}{ScanInfo}{int ch,int \&xm,int \&ym,int \&maxval,int \&channels, int \&flags,string \&descr}{150}{imageio}{}
\functionlistentry{void}{ScanWindow}{int ch,int x1,int y1,int x2,int y2}{147}{imageio}{}
\functionlistentry{void}{VideoFile::getPara}{int \&xs,int \&ys,int \&mv,int \&fps}{122}{imageio}{}
\functionlistentry{int}{VideoFile::open}{const string \&fn,ios\_base::openmode mode = ios\_base::in}{121}{imageio}{}
\functionlistentry{bool}{VideoFile::Read}{\hyperlink{Image}{Image} \&img,int ch=3}{125}{imageio}{}
\functionlistentry{bool}{VideoFile::Read}{\hyperlink{Image}{Image} \&ir,\hyperlink{Image}{Image} \&ig,\hyperlink{Image}{Image} \&ib}{126}{imageio}{}
\functionlistentry{bool}{VideoFile::Read}{\hyperlink{ColorImage}{ColorImage} \&irgb}{127}{imageio}{}
\functionlistentry{void}{VideoFile::setCPara}{const string \&p}{124}{imageio}{}
\functionlistentry{void}{VideoFile::setPara}{int xs,int ys,int mv,int fps,int bitrate=0}{123}{imageio}{}
\functionlistentry{}{VideoFile::VideoFile}{}{119}{imageio}{}
\functionlistentry{}{VideoFile::VideoFile}{const string \&fn,ios\_base::openmode mode = ios\_base::in}{120}{imageio}{}
\functionlistentry{bool}{VideoFile::Write}{const \hyperlink{Image}{Image} \&img}{128}{imageio}{}
\functionlistentry{bool}{VideoFile::Write}{const \hyperlink{Image}{Image} \&ir,const \hyperlink{Image}{Image} \&ig,const \hyperlink{Image}{Image} \&ib}{129}{imageio}{}
\functionlistentry{bool}{VideoFile::Write}{const ImageRGB \&irgb}{130}{imageio}{}
\functionlistentry{int}{VideoFileCached::FrameNumber}{}{145}{imageio}{}
\functionlistentry{int}{VideoFileCached::getError}{}{146}{imageio}{}
\functionlistentry{void}{VideoFileCached::getPara}{int \&xs,int \&ys,int \&mv,int \&fps}{141}{imageio}{}
\functionlistentry{bool}{VideoFileCached::Read}{\hyperlink{Image}{Image} \&ir,\hyperlink{Image}{Image} \&ig,\hyperlink{Image}{Image} \&ib,int frame=\hyperlink{VideoFileCached}{VideoFileCached}::next}{142}{imageio}{}
\functionlistentry{bool}{VideoFileCached::Read}{\hyperlink{ColorImage}{ColorImage} \&img,int frame=\hyperlink{VideoFileCached}{VideoFileCached}::next}{143}{imageio}{}
\functionlistentry{bool}{VideoFileCached::Read}{ImageRGB \&img,int frame=\hyperlink{VideoFileCached}{VideoFileCached}::next}{144}{imageio}{}
\functionlistentry{}{VideoFileCached::VideoFileCached}{const string \&fn,int buffersize}{140}{imageio}{}
\functionlistentry{int}{WriteImg}{const \hyperlink{Image}{Image} \&img,const string \&filename}{114}{imageio}{}
\functionlistentry{int}{WriteImg}{const \hyperlink{Image}{Image} \&ir,const \hyperlink{Image}{Image} \&ig,const \hyperlink{Image}{Image} \&ib,const string \&filename}{116}{imageio}{}

\subtitle{\hyperlink{SECTION:datastructures}{Grundlegende Datenstrukturen}}\\
\functionlistentry{int}{Append}{const \hyperlink{Vector}{Vector} \&v}{266}{datastructures}{}
\functionlistentry{void}{Clear}{}{237}{datastructures}{}
\functionlistentry{double}{ColorValue::abs}{}{290}{datastructures}{}
\functionlistentry{double}{ColorValue::abs2}{}{291}{datastructures}{}
\functionlistentry{int}{ColorValue::absL1}{}{292}{datastructures}{}
\functionlistentry{}{ColorValue::ColorValue}{}{287}{datastructures}{}
\functionlistentry{explicit}{ColorValue::ColorValue}{int val}{288}{datastructures}{}
\functionlistentry{}{ColorValue::ColorValue}{int redval,int greenval,int blueval}{289}{datastructures}{}
\functionlistentry{int}{ColorValue::getGray}{}{293}{datastructures}{}
\functionlistentry{\hyperlink{ColorValue}{ColorValue}}{ColorValue::Limited}{int maxValue}{294}{datastructures}{}
\functionlistentry{vector$<$\hyperlink{Point}{Point}$>$}{ConvexHull}{const vector$<$\hyperlink{Point}{Point}$>$ \&pl}{284}{datastructures}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{ConvexHull}{const \hyperlink{Matrix}{Matrix} \&pl}{285}{datastructures}{}
\functionlistentry{\hyperlink{Contur}{Contur}}{ConvexHull}{const \hyperlink{Contur}{Contur} \&c}{286}{datastructures}{}
\functionlistentry{\hyperlink{Vector}{Vector}}{Cross}{const \hyperlink{Vector}{Vector} \&v1,const \hyperlink{Vector}{Vector} \&v2}{254}{datastructures}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{FitPolygonContur}{const \hyperlink{Matrix}{Matrix} \&pl, const \hyperlink{Contur}{Contur} \&c,int step=0}{283}{datastructures}{}
\functionlistentry{void}{HsiToRgb}{double h, double s, double i, \hyperlink{ColorValue}{ColorValue} \&dst, int maxval = 255}{303}{datastructures}{}
\functionlistentry{void}{HsiToRgb}{double h, double s, double i, double \&r, double \&g, double \&b}{307}{datastructures}{}
\functionlistentry{bool}{InsidePolygon}{const \hyperlink{Matrix}{Matrix} \&pl,const \hyperlink{Point}{Point} \&p}{280}{datastructures}{}
\functionlistentry{int}{isPolygon}{const \hyperlink{Matrix}{Matrix} \& pl}{279}{datastructures}{}
\functionlistentry{void}{LabToRgb}{double l, double a, double b, \hyperlink{ColorValue}{ColorValue} \&dst, int maxval = 255}{306}{datastructures}{}
\functionlistentry{void}{LabToRgb}{double l, double a, double b, double \&rr, double \&gg, double \&bb}{316}{datastructures}{}
\functionlistentry{void}{LabToXyz}{double l, double a, double b, double \&x, double \&y, double \&z}{314}{datastructures}{}
\functionlistentry{int}{Matrix::AddDyadicProd}{const \hyperlink{Vector}{Vector} \& v,const \hyperlink{Vector}{Vector} \& w,double factor}{276}{datastructures}{}
\functionlistentry{int}{Matrix::AddDyadicProd}{const \hyperlink{Vector}{Vector} \& v, double factor}{277}{datastructures}{}
\functionlistentry{int}{Matrix::cols}{}{265}{datastructures}{}
\functionlistentry{int}{Matrix::DeleteCol}{int n}{271}{datastructures}{}
\functionlistentry{int}{Matrix::DeleteCol}{int n1,int n2}{272}{datastructures}{}
\functionlistentry{int}{Matrix::DeleteRow}{int n}{269}{datastructures}{}
\functionlistentry{int}{Matrix::DeleteRow}{int n1,int n2}{270}{datastructures}{}
\functionlistentry{void}{Matrix::ExchangeCol}{int i1,int i2}{268}{datastructures}{}
\functionlistentry{void}{Matrix::ExchangeRow}{int i1,int i2}{267}{datastructures}{}
\functionlistentry{}{Matrix::Matrix}{}{255}{datastructures}{}
\functionlistentry{}{Matrix::Matrix}{const int rows,const int cols,int initmode=0}{256}{datastructures}{}
\functionlistentry{explicit}{Matrix::Matrix}{const int rows,const int cols,double *init}{257}{datastructures}{}
\functionlistentry{}{Matrix::Matrix}{const \hyperlink{Matrix}{Matrix}\& m}{258}{datastructures}{}
\functionlistentry{}{Matrix::Matrix}{const IMatrix\& im}{259}{datastructures}{}
\functionlistentry{explicit}{Matrix::Matrix}{const \hyperlink{Image}{Image}\& m,int mode=RAW,int sign=UNSIGNED}{260}{datastructures}{}
\functionlistentry{explicit}{Matrix::Matrix}{const ImageD \& m}{261}{datastructures}{}
\functionlistentry{double}{Matrix::MaxVal}{}{273}{datastructures}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{Matrix::MulTrans}{const \hyperlink{Matrix}{Matrix} \&m2}{262}{datastructures}{}
\functionlistentry{\hyperlink{Vector}{Vector}}{Matrix::MulTrans}{const \hyperlink{Vector}{Vector} \&v}{263}{datastructures}{}
\functionlistentry{int}{Matrix::rows}{}{264}{datastructures}{}
\functionlistentry{int}{Matrix::Sort}{int col=0,bool asc=true}{278}{datastructures}{}
\functionlistentry{void}{Matrix::SumCols}{\hyperlink{Vector}{Vector} \&sum}{275}{datastructures}{}
\functionlistentry{void}{Matrix::SumRows}{\hyperlink{Vector}{Vector} \&sum}{274}{datastructures}{}
\functionlistentry{}{Neighbor4Walker::Neighbor4Walker}{IPoint p}{191}{datastructures}{}
\functionlistentry{}{Neighbor8Walker::Neighbor8Walker}{IPoint p}{192}{datastructures}{}
\functionlistentry{\hyperlink{Vector}{Vector}}{Normalize}{const \hyperlink{Vector}{Vector} \&v}{253}{datastructures}{}
\functionlistentry{\hyperlink{Point}{Point}}{Point::normalized}{}{173}{datastructures}{}
\functionlistentry{bool}{Point::operator !=}{const \hyperlink{Point}{Point} \&p}{160}{datastructures}{}
\functionlistentry{\hyperlink{Point}{Point}}{Point::operator *}{double f}{165}{datastructures}{}
\functionlistentry{double}{Point::operator *}{\hyperlink{Point}{Point} second}{167}{datastructures}{}
\functionlistentry{\hyperlink{Point}{Point}}{Point::operator *=}{double f}{166}{datastructures}{}
\functionlistentry{\hyperlink{Point}{Point}}{Point::operator +}{const \hyperlink{Point}{Point} \&p}{161}{datastructures}{}
\functionlistentry{\hyperlink{Point}{Point}}{Point::operator +=}{const \hyperlink{Point}{Point} \&p}{162}{datastructures}{}
\functionlistentry{\hyperlink{Point}{Point}}{Point::operator -}{const \hyperlink{Point}{Point} \&p}{163}{datastructures}{}
\functionlistentry{\hyperlink{Point}{Point}}{Point::operator -=}{const \hyperlink{Point}{Point} \&p}{164}{datastructures}{}
\functionlistentry{\hyperlink{Point}{Point}}{Point::operator /}{double d}{168}{datastructures}{}
\functionlistentry{\hyperlink{Point}{Point}}{Point::operator /=}{double d}{169}{datastructures}{}
\functionlistentry{bool}{Point::operator ==}{const \hyperlink{Point}{Point} \&p}{159}{datastructures}{}
\functionlistentry{double}{Point::phi}{}{172}{datastructures}{}
\functionlistentry{}{Point::Point}{}{152}{datastructures}{}
\functionlistentry{}{Point::Point}{double x, double y}{153}{datastructures}{}
\functionlistentry{explicit}{Point::Point}{const \hyperlink{Vector}{Vector} \&v}{154}{datastructures}{}
\functionlistentry{explicit}{Point::Point}{const IVector \&v}{155}{datastructures}{}
\functionlistentry{explicit}{Point::Point}{double d[]}{156}{datastructures}{}
\functionlistentry{double}{Point::r}{}{171}{datastructures}{}
\functionlistentry{int}{Point::Shift}{double dx,double dy}{170}{datastructures}{}
\functionlistentry{double}{Point::X}{}{157}{datastructures}{}
\functionlistentry{double}{Point::Y}{}{158}{datastructures}{}
\functionlistentry{}{PointListWalker::PointListWalker}{}{185}{datastructures}{}
\functionlistentry{}{PointListWalker::PointListWalker}{IPoint p}{186}{datastructures}{}
\functionlistentry{}{PointListWalker::PointListWalker}{const vector\textless {}IPoint\textgreater  \&pl,int idx = 0}{187}{datastructures}{}
\functionlistentry{}{PointListWalker::PointListWalker}{const \hyperlink{Contur}{Contur} \&c}{188}{datastructures}{}
\functionlistentry{void}{PointListWalker::setPointList}{const vector\textless {}IPoint\textgreater  \&v,int idx = 0}{189}{datastructures}{}
\functionlistentry{void}{PointListWalker::setStartIndex}{int idx = 0}{190}{datastructures}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{ReducePolygon}{const \hyperlink{Matrix}{Matrix} \&pl,int n}{281}{datastructures}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{ReducePolygon}{const \hyperlink{Contur}{Contur} \&c,int n}{282}{datastructures}{}
\functionlistentry{}{RegionWalker::RegionWalker}{const \hyperlink{Region}{Region} \&region}{193}{datastructures}{}
\functionlistentry{}{RegionWalker::RegionWalker}{const \hyperlink{Contur}{Contur} \&contur}{194}{datastructures}{}
\functionlistentry{void}{Resize}{int n}{238}{datastructures}{}
\functionlistentry{void}{RgbToHsi}{const \hyperlink{ColorValue}{ColorValue} \&src, int maxval, double \&h, double \&s, double \&i}{295}{datastructures}{}
\functionlistentry{void}{RgbToHsi}{const \hyperlink{ColorValue}{ColorValue} \&src, double \&h, double \&s, double \&i}{296}{datastructures}{}
\functionlistentry{void}{RgbToHsi}{double r, double g, double b, double \&h, double \&s, double \&i}{308}{datastructures}{}
\functionlistentry{void}{RgbToLab}{const \hyperlink{ColorValue}{ColorValue} \&src, int maxval, double \&x, double \&y, double \&z}{301}{datastructures}{}
\functionlistentry{void}{RgbToLab}{const \hyperlink{ColorValue}{ColorValue} \&src, double \&x, double \&y, double \&z}{302}{datastructures}{}
\functionlistentry{void}{RgbToLab}{double r, double g, double b, double \&x, double \&y, double \&z}{315}{datastructures}{}
\functionlistentry{void}{RgbToXyz}{const \hyperlink{ColorValue}{ColorValue} \&src, int maxval, double \&x, double \&y, double \&z}{299}{datastructures}{}
\functionlistentry{void}{RgbToXyz}{const \hyperlink{ColorValue}{ColorValue} \&src, double \&x, double \&y, double \&z}{300}{datastructures}{}
\functionlistentry{void}{RgbToXyz}{double r, double g, double b, double \&x, double \&y, double \&z}{311}{datastructures}{}
\functionlistentry{void}{RgbToYuv}{const \hyperlink{ColorValue}{ColorValue} \&src, int maxval, double \&h, double \&s, double \&i}{297}{datastructures}{}
\functionlistentry{void}{RgbToYuv}{const \hyperlink{ColorValue}{ColorValue} \&src, double \&h, double \&s, double \&i}{298}{datastructures}{}
\functionlistentry{void}{RgbToYuv}{double r, double g, double b, double \&h, double \&s, double \&i}{310}{datastructures}{}
\functionlistentry{void}{Vector3d::Normalize}{}{203}{datastructures}{}
\functionlistentry{\hyperlink{Vector3d}{Vector3d}}{Vector3d::Normalized}{}{202}{datastructures}{}
\functionlistentry{\hyperlink{Vector}{Vector}}{Vector3d::operator Vector}{}{201}{datastructures}{}
\functionlistentry{}{Vector3d::Vector3d}{}{195}{datastructures}{}
\functionlistentry{}{Vector3d::Vector3d}{const \hyperlink{Vector3d}{Vector3d} \&p}{196}{datastructures}{}
\functionlistentry{}{Vector3d::Vector3d}{double xp,double yp,double zp}{197}{datastructures}{}
\functionlistentry{explicit}{Vector3d::Vector3d}{const \hyperlink{Vector}{Vector} \&v}{198}{datastructures}{}
\functionlistentry{explicit}{Vector3d::Vector3d}{const IVector \&v}{199}{datastructures}{}
\functionlistentry{explicit}{Vector3d::Vector3d}{double p[]}{200}{datastructures}{}
\functionlistentry{void}{Vector::Append}{double val}{245}{datastructures}{}
\functionlistentry{void}{Vector::Append}{const \hyperlink{Vector}{Vector} \&v}{246}{datastructures}{}
\functionlistentry{double \&}{Vector::at}{int idx}{233}{datastructures}{}
\functionlistentry{void}{Vector::Delete}{int i1,int i2}{248}{datastructures}{}
\functionlistentry{void}{Vector::Delete}{int i}{249}{datastructures}{}
\functionlistentry{bool}{Vector::empty}{}{236}{datastructures}{}
\functionlistentry{void}{Vector::Exchange}{int i1,int i2}{247}{datastructures}{}
\functionlistentry{double}{Vector::Length}{}{250}{datastructures}{}
\functionlistentry{void}{Vector::Normalize}{}{251}{datastructures}{}
\functionlistentry{void}{Vector::Set}{double val}{239}{datastructures}{}
\functionlistentry{void}{Vector::SetV}{double d1}{240}{datastructures}{}
\functionlistentry{void}{Vector::SetV}{double d1,double d2}{241}{datastructures}{}
\functionlistentry{void}{Vector::SetV}{double d1,double d2,double d3}{242}{datastructures}{}
\functionlistentry{void}{Vector::SetV}{double d1,double d2,double d3,double d4}{243}{datastructures}{}
\functionlistentry{void}{Vector::SetV}{double d1,double d2,double d3,double d4,double d5}{244}{datastructures}{}
\functionlistentry{int}{Vector::Size}{}{234}{datastructures}{}
\functionlistentry{unsigned int}{Vector::size}{}{235}{datastructures}{}
\functionlistentry{void}{Vector::Sort}{int order=0}{252}{datastructures}{}
\functionlistentry{}{Vector::Vector}{}{224}{datastructures}{}
\functionlistentry{}{Vector::Vector}{int n}{225}{datastructures}{}
\functionlistentry{}{Vector::Vector}{int n,double *data}{226}{datastructures}{}
\functionlistentry{}{Vector::Vector}{const \hyperlink{Vector}{Vector} \&v}{227}{datastructures}{}
\functionlistentry{explicit}{Vector::Vector}{const vector<double> \&v}{228}{datastructures}{}
\functionlistentry{}{Vector::Vector}{double d1,double d2}{229}{datastructures}{}
\functionlistentry{}{Vector::Vector}{double d1,double d2,double d3}{230}{datastructures}{}
\functionlistentry{}{Vector::Vector}{double d1,double d2,double d3,double d4}{231}{datastructures}{}
\functionlistentry{}{Vector::Vector}{double d1,double d2,double d3,double d4,double d5}{232}{datastructures}{}
\functionlistentry{void}{Walker::init}{}{178}{datastructures}{}
\functionlistentry{void}{Walker::moveTo}{IPoint p}{177}{datastructures}{}
\functionlistentry{void}{Walker::next}{}{179}{datastructures}{}
\functionlistentry{void}{Walker::next}{int steps}{180}{datastructures}{}
\functionlistentry{bool}{Walker::ready}{}{181}{datastructures}{}
\functionlistentry{}{Walker::Walker}{}{174}{datastructures}{}
\functionlistentry{}{Walker::Walker}{IPoint p}{175}{datastructures}{}
\functionlistentry{}{Walker::Walker}{int x, int y}{176}{datastructures}{}
\functionlistentry{int}{Window::GetBottom}{}{214}{datastructures}{}
\functionlistentry{int}{Window::GetLeft}{}{208}{datastructures}{}
\functionlistentry{int}{Window::GetRight}{}{210}{datastructures}{}
\functionlistentry{IPoint}{Window::getSize}{}{218}{datastructures}{}
\functionlistentry{int}{Window::GetTop}{}{212}{datastructures}{}
\functionlistentry{int}{Window::Height}{}{207}{datastructures}{}
\functionlistentry{bool}{Window::Inside}{const IPoint \&p}{219}{datastructures}{}
\functionlistentry{bool}{Window::Inside}{int x,int y}{220}{datastructures}{}
\functionlistentry{bool}{Window::operator !=}{const \hyperlink{Window}{Window} \&w}{222}{datastructures}{}
\functionlistentry{bool}{Window::operator ==}{const \hyperlink{Window}{Window} \&w}{221}{datastructures}{}
\functionlistentry{const IPoint \&}{Window::P1}{}{216}{datastructures}{}
\functionlistentry{const IPoint \&}{Window::P2}{}{217}{datastructures}{}
\functionlistentry{int}{Window::Shift}{int dx,int dy}{223}{datastructures}{}
\functionlistentry{int}{Window::Width}{}{206}{datastructures}{}
\functionlistentry{}{Window::Window}{}{204}{datastructures}{}
\functionlistentry{}{Window::Window}{int x1,int y1,int x2,int y2}{205}{datastructures}{}
\functionlistentry{int}{Window::XA}{}{211}{datastructures}{}
\functionlistentry{int}{Window::XI}{}{209}{datastructures}{}
\functionlistentry{int}{Window::YA}{}{215}{datastructures}{}
\functionlistentry{int}{Window::Yi}{}{213}{datastructures}{}
\functionlistentry{}{WindowWalker::WindowWalker}{const \hyperlink{Window}{Window} \&w}{182}{datastructures}{}
\functionlistentry{}{WindowWalker::WindowWalker}{const \hyperlink{Image}{Image} \&img center}{183}{datastructures}{}
\functionlistentry{}{WindowWalker::WindowWalker}{IPoint center, int sizex, int sizey = -1}{184}{datastructures}{}
\functionlistentry{void}{XyzToLab}{double x, double y, double z, double \&l, double \&a, double \&b}{313}{datastructures}{}
\functionlistentry{void}{XyzToRgb}{double x, double y, double z, \hyperlink{ColorValue}{ColorValue} \&dst, int maxval = 255}{305}{datastructures}{}
\functionlistentry{void}{XyzToRgb}{double x, double y, double z, double \&r, double \&g, double \&b}{312}{datastructures}{}
\functionlistentry{void}{YuvToRgb}{double y, double u, double v, \hyperlink{ColorValue}{ColorValue} \&dst, int maxval = 255}{304}{datastructures}{}
\functionlistentry{void}{YuvToRgb}{double y, double u, double v, double \&r, double \&g, double \&b}{309}{datastructures}{}

\subtitle{\hyperlink{SECTION:filter}{Filter}}\\
\functionlistentry{int}{BoxImg}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&dest,int n=3}{343}{filter}{}
\functionlistentry{int}{BoxImg}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&dest,int nx,int ny}{344}{filter}{}
\functionlistentry{int}{CalcDirectionImg}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&dir,int dsize=11}{360}{filter}{}
\functionlistentry{int}{CalcDirectionImg}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&dir,int dsize=11,ImageD eval}{361}{filter}{}
\functionlistentry{int}{CalcDirectionStructImg}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&dir,int dsize=11}{362}{filter}{}
\functionlistentry{int}{CalcDirectionStructImg}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&dir,int dsize=11,ImageD lambda1,ImageD lambda2}{363}{filter}{}
\functionlistentry{int}{ClosingImg}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&dest,int nx=3, int ny=-1}{381}{filter}{}
\functionlistentry{int}{ClosingImg}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&dest,const IMatrix \&mask}{382}{filter}{}
\functionlistentry{int}{DilateImg}{const \hyperlink{Image}{Image} \&src,int nx,int ny,\hyperlink{Image}{Image} \&dest}{373}{filter}{}
\functionlistentry{int}{DilateImg}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&dest,int nx=3, int ny=-1}{374}{filter}{}
\functionlistentry{int}{DilateImg}{const \hyperlink{Image}{Image} \&src,int neighb,int *mask,\hyperlink{Image}{Image} \&dest}{375}{filter}{}
\functionlistentry{int}{DilateImg}{const \hyperlink{Image}{Image} \&src,int nx,int ny,int *mask,\hyperlink{Image}{Image} \&dest}{376}{filter}{}
\functionlistentry{int}{DilateImg}{const \hyperlink{Image}{Image} \&src,const Imatrix \&mask,\hyperlink{Image}{Image} \&dest}{377}{filter}{}
\functionlistentry{int}{DilateImg}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&dest,const IMatrix \&mask}{378}{filter}{}
\functionlistentry{int}{DoBImg}{\hyperlink{Image}{Image} src,\hyperlink{Image}{Image} dest,int n1,int n2,int mode=SMD\_SHIFT}{345}{filter}{}
\functionlistentry{int}{ErodeImg}{const \hyperlink{Image}{Image} \&src,int nx,int ny,\hyperlink{Image}{Image} \&dest}{367}{filter}{}
\functionlistentry{int}{ErodeImg}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&dest,int nx=3, int ny=-1}{368}{filter}{}
\functionlistentry{int}{ErodeImg}{const \hyperlink{Image}{Image} \&src,int neighb,int *mask,\hyperlink{Image}{Image} \&dest}{369}{filter}{}
\functionlistentry{int}{ErodeImg}{const \hyperlink{Image}{Image} \&src,int nx,int ny,int *mask,\hyperlink{Image}{Image} \&dest}{370}{filter}{}
\functionlistentry{int}{ErodeImg}{const \hyperlink{Image}{Image} \&src,const Imatrix \&mask,\hyperlink{Image}{Image} \&dest}{371}{filter}{}
\functionlistentry{int}{ErodeImg}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&dest,const IMatrix \&mask}{372}{filter}{}
\functionlistentry{int}{GaussImg}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&dest,int neighb,double sigma}{352}{filter}{}
\functionlistentry{int}{GaussImg}{const \hyperlink{Image}{Image} \&src,ImageD dest,int neighb,double sigma}{353}{filter}{}
\functionlistentry{int}{GaussImg}{ImageD src,ImageD dest,int neighb,double sigma}{354}{filter}{}
\functionlistentry{int}{GradDirImg}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&dest}{359}{filter}{}
\functionlistentry{int}{GradImg}{const \hyperlink{Image}{Image} \&src,int norm,\hyperlink{Image}{Image} \&dest}{358}{filter}{}
\functionlistentry{int}{GradXImg}{\hyperlink{Image}{Image} src,int norm,\hyperlink{Image}{Image} dest}{346}{filter}{}
\functionlistentry{int}{GradYImg}{\hyperlink{Image}{Image} src,int norm,\hyperlink{Image}{Image} dest}{347}{filter}{}
\functionlistentry{int}{LaplaceImg}{\hyperlink{Image}{Image} src,int norm,\hyperlink{Image}{Image} dest}{351}{filter}{}
\functionlistentry{int}{LaplaceXImg}{\hyperlink{Image}{Image} src,int norm,\hyperlink{Image}{Image} dest}{349}{filter}{}
\functionlistentry{int}{LaplaceYImg}{\hyperlink{Image}{Image} src,int norm,\hyperlink{Image}{Image} dest}{350}{filter}{}
\functionlistentry{int}{LSIFilter::Filter}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&dst,int offset}{330}{filter}{}
\functionlistentry{int}{LSIFilter::Filter}{const \hyperlink{Image}{Image} \&src,ImageD dst}{331}{filter}{}
\functionlistentry{int}{LSIFilter::Filter}{ImageD src,ImageD dst}{332}{filter}{}
\functionlistentry{double}{LSIFilter::getMask}{int x,int y}{323}{filter}{}
\functionlistentry{}{LSIFilter::LSIFilter}{}{318}{filter}{}
\functionlistentry{}{LSIFilter::LSIFilter}{const \hyperlink{LSIFilter}{LSIFilter} \&f}{319}{filter}{}
\functionlistentry{}{LSIFilter::LSIFilter}{const \hyperlink{Matrix}{Matrix} \&m}{320}{filter}{}
\functionlistentry{}{LSIFilter::LSIFilter}{const IMatrix \&m,int norm}{321}{filter}{}
\functionlistentry{}{LSIFilter::LSIFilter}{int *m,int norm}{322}{filter}{}
\functionlistentry{void}{LSIFilter::NegateMask}{}{324}{filter}{}
\functionlistentry{double}{LSIFilter::proposeOffset}{const \hyperlink{Image}{Image} \&img}{325}{filter}{}
\functionlistentry{int}{LSIImg}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&dst,const \hyperlink{LSIFilter}{LSIFilter} \&f,int offset}{333}{filter}{}
\functionlistentry{int}{LSIImg}{\hyperlink{Image}{Image} src,int nx,int ny,int *mask,int norm,int offset,\hyperlink{Image}{Image} dest}{334}{filter}{}
\functionlistentry{int}{LSIImg}{\hyperlink{Image}{Image} src,int nx,int ny,double *mask,int offset,\hyperlink{Image}{Image} dest}{335}{filter}{}
\functionlistentry{int}{LSIImg}{\hyperlink{Image}{Image} src,const \hyperlink{Matrix}{Matrix} \&mask,int offset,\hyperlink{Image}{Image} dest}{336}{filter}{}
\functionlistentry{int}{LSIImg}{\hyperlink{Image}{Image} src,const IMatrix \&mask,int norm,int offset,\hyperlink{Image}{Image} dest}{337}{filter}{}
\functionlistentry{int}{MeanImg}{\hyperlink{Image}{Image} src,\hyperlink{Image}{Image} dest}{348}{filter}{}
\functionlistentry{int}{MedianImg}{const \hyperlink{Image}{Image} \&img,int size,\hyperlink{Image}{Image} \&dest}{386}{filter}{}
\functionlistentry{int}{MexicanHatImg}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&dest,double sigma,int neighb=0}{355}{filter}{}
\functionlistentry{int}{MexicanHatImg}{const \hyperlink{Image}{Image} \&src,ImageD dest,double sigma,int neighb=0}{356}{filter}{}
\functionlistentry{int}{MexicanHatImg}{ImageD src,ImageD dest,double sigma,int neighb=0}{357}{filter}{}
\functionlistentry{int}{MinMaxImg}{const \hyperlink{Image}{Image} \&src,int nx, int ny,\hyperlink{Image}{Image} \&minimg, \hyperlink{Image}{Image} \&maximg}{383}{filter}{}
\functionlistentry{\hyperlink{LSIFilter}{LSIFilter}}{mkDirDoBFilter}{int n,double dir,double len,double width}{328}{filter}{}
\functionlistentry{\hyperlink{LSIFilter}{LSIFilter}}{mkDirEdgeFilter}{int n,double dir,double rad}{329}{filter}{}
\functionlistentry{\hyperlink{LSIFilter}{LSIFilter}}{mkDirSmearFilter}{int n,double dir,double len,double width}{327}{filter}{}
\functionlistentry{\hyperlink{LSIFilter}{LSIFilter}}{mkPolynomFilter}{int n,int grad,int i,int j}{326}{filter}{}
\functionlistentry{int}{OpeningImg}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&dest,int nx=3, int ny=-1}{379}{filter}{}
\functionlistentry{int}{OpeningImg}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&dest,const IMatrix \&mask}{380}{filter}{}
\functionlistentry{int}{OrientedDoBImg}{const \hyperlink{Image}{Image} \&src,const \hyperlink{Image}{Image} \&dir, \hyperlink{Image}{Image} \&dest,int fsize=11,int flength=10,int fwidth=1}{365}{filter}{}
\functionlistentry{int}{OrientedEdgeImg}{const \hyperlink{Image}{Image} \&src,const \hyperlink{Image}{Image} \&dir, \hyperlink{Image}{Image} \&dest,int fsize=11,int rad=10}{366}{filter}{}
\functionlistentry{int}{OrientedSmearImg}{const \hyperlink{Image}{Image} \&src,const \hyperlink{Image}{Image} \&dir, \hyperlink{Image}{Image} \&dest,int fsize=11,int flength=10,int fwidth=1}{364}{filter}{}
\functionlistentry{int}{RankImg}{const \hyperlink{Image}{Image} \&src,int neighb,int rank,\hyperlink{Image}{Image} \&dest}{384}{filter}{}
\functionlistentry{int}{RankImg}{const \hyperlink{Image}{Image} \&src,int nx,int ny,int rank,\hyperlink{Image}{Image} \&dest}{385}{filter}{}
\functionlistentry{int}{RelaxImg}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&dest,int neighb=3}{388}{filter}{}
\functionlistentry{int}{SkelettImg}{const \hyperlink{Image}{Image} \&src,const \hyperlink{Image}{Image} \&dest,int lvl=1}{389}{filter}{}
\functionlistentry{int}{SmearImg}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&dest,int n=3}{338}{filter}{}
\functionlistentry{int}{SmearImg}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&dest,int nx,int ny}{339}{filter}{}
\functionlistentry{int}{SmearImg}{const \hyperlink{Image}{Image} \&img,int n}{340}{filter}{}
\functionlistentry{int}{SmearImgD}{ImageD src,ImageD dest,int nx,int ny}{341}{filter}{}
\functionlistentry{int}{SmearImgD}{ImageD src,ImageD dest,int n}{342}{filter}{}
\functionlistentry{int}{SubRankImg}{const \hyperlink{Image}{Image} \&src,int neighb,int rank,\hyperlink{Image}{Image} \&dest}{387}{filter}{}

\subtitle{\hyperlink{SECTION:conturs}{Konturen, Kanten und Regionen}}\\
\functionlistentry{\hyperlink{Contur}{Contur}}{CalcContur}{\hyperlink{Image}{Image} iv,\hyperlink{Image}{Image} io,object\_rc (*cls)(),int thr,int ps[2],int lng=0,object\_rc marked=isunderground,object\_rc outside=isunderground}{440}{conturs}{}
\functionlistentry{\hyperlink{Contur}{Contur}}{CalcContur}{\hyperlink{Image}{Image} iv,\hyperlink{Image}{Image} io,object\_rc (*cls)(),int thr,const IPoint \&ps,int lng=0,object\_rc marked=isunderground,object\_rc outside=isunderground}{441}{conturs}{}
\functionlistentry{\hyperlink{Contur}{Contur}}{CalcGradContur}{\hyperlink{Image}{Image} iv,\hyperlink{Image}{Image} io,int thr,int maxg,int ps[2],int lng}{449}{conturs}{}
\functionlistentry{\hyperlink{Contur}{Contur}}{CalcRidgeContur}{\hyperlink{Image}{Image} imgv,\hyperlink{Image}{Image} imgo,int thr,int ps[2],int lng}{452}{conturs}{}
\functionlistentry{double}{CalcThreshold}{const \hyperlink{Hist}{Hist} \&h}{432}{conturs}{}
\functionlistentry{double}{CalcThreshold}{const \hyperlink{Hist}{Hist} \&h,double \&discmax}{433}{conturs}{}
\functionlistentry{int}{CalcThreshold}{const \hyperlink{Histogram}{Histogram} \&h}{434}{conturs}{}
\functionlistentry{int}{CalcThreshold}{const \hyperlink{Histogram}{Histogram} \&h,double \&discmax}{435}{conturs}{}
\functionlistentry{int}{CalcThreshold}{\hyperlink{Image}{Image} img}{436}{conturs}{}
\functionlistentry{int}{CalcThreshold}{\hyperlink{Image}{Image} img,double \&discmax,int diff=1}{437}{conturs}{}
\functionlistentry{int}{Contur::Add}{\hyperlink{Freeman}{Freeman} dir}{400}{conturs}{}
\functionlistentry{int}{Contur::Add}{IPoint p}{401}{conturs}{}
\functionlistentry{int}{Contur::Add}{int x,int y}{402}{conturs}{}
\functionlistentry{int}{Contur::Add}{const \hyperlink{Contur}{Contur} \&c}{403}{conturs}{}
\functionlistentry{void}{Contur::Close}{}{405}{conturs}{}
\functionlistentry{}{Contur::Contur}{}{391}{conturs}{}
\functionlistentry{}{Contur::Contur}{const \hyperlink{Contur}{Contur} \&c}{392}{conturs}{}
\functionlistentry{}{Contur::Contur}{IPoint p}{393}{conturs}{}
\functionlistentry{}{Contur::Contur}{int x,int y}{394}{conturs}{}
\functionlistentry{int}{Contur::DirCode}{int i}{425}{conturs}{}
\functionlistentry{IPoint}{Contur::End}{}{413}{conturs}{}
\functionlistentry{int}{Contur::EndX}{}{416}{conturs}{}
\functionlistentry{int}{Contur::EndY}{}{417}{conturs}{}
\functionlistentry{\hyperlink{Freeman}{Freeman}}{Contur::getDirection}{int i}{420}{conturs}{}
\functionlistentry{const std::vector\textless {}\hyperlink{Freeman}{Freeman}\textgreater {}\&}{Contur::getDirections}{}{421}{conturs}{}
\functionlistentry{int}{Contur::getDirections}{std::vector\textless {}\hyperlink{Freeman}{Freeman}\textgreater {}\& fc}{422}{conturs}{}
\functionlistentry{int}{Contur::getPairs}{std::vector\textless {}IPoint\textgreater {} \&opl,std::vector\textless {}IPoint\textgreater {} \&upl}{423}{conturs}{}
\functionlistentry{int}{Contur::getPairs}{std::vector\textless {}IPoint\textgreater {} \&pl,std::vector\textless {}\hyperlink{Freeman}{Freeman}\textgreater {} \&fc}{424}{conturs}{}
\functionlistentry{IPoint}{Contur::getPoint}{int nr}{426}{conturs}{}
\functionlistentry{int}{Contur::getPoint}{int nr,int \&x,int \&y}{427}{conturs}{}
\functionlistentry{void}{Contur::getPoints}{vector<IPoint> \&pl,bool close=false}{428}{conturs}{}
\functionlistentry{int}{Contur::getRect}{int \&xi,int \&yi,int \&xa,int \&ya}{419}{conturs}{}
\functionlistentry{int}{Contur::InvDir}{}{406}{conturs}{}
\functionlistentry{int}{Contur::isClosed}{}{411}{conturs}{}
\functionlistentry{int}{Contur::isHole}{}{418}{conturs}{}
\functionlistentry{int}{Contur::isValid}{}{408}{conturs}{}
\functionlistentry{double}{Contur::Length}{}{410}{conturs}{}
\functionlistentry{int}{Contur::Number}{}{409}{conturs}{}
\functionlistentry{\hyperlink{Contur}{Contur} \&}{Contur::operator =}{const \hyperlink{Trafo}{Trafo} \&}{407}{conturs}{}
\functionlistentry{int}{Contur::Reset}{}{395}{conturs}{}
\functionlistentry{int}{Contur::Reset}{IPoint p}{396}{conturs}{}
\functionlistentry{int}{Contur::Reset}{int x,int y}{397}{conturs}{}
\functionlistentry{int}{Contur::SetStart}{IPoint p}{398}{conturs}{}
\functionlistentry{int}{Contur::SetStart}{int x,int y}{399}{conturs}{}
\functionlistentry{IPoint}{Contur::Start}{}{412}{conturs}{}
\functionlistentry{int}{Contur::StartX}{}{414}{conturs}{}
\functionlistentry{int}{Contur::StartY}{}{415}{conturs}{}
\functionlistentry{}{conturFromPolygon}{const \hyperlink{Matrix}{Matrix} \&pl,\hyperlink{Contur}{Contur} \&c}{463}{conturs}{}
\functionlistentry{int}{ConturList::Add}{const \hyperlink{Contur}{Contur} \&c}{456}{conturs}{}
\functionlistentry{}{ConturList::ConturList}{}{453}{conturs}{}
\functionlistentry{}{ConturList::ConturList}{const \hyperlink{ConturList}{ConturList}\& cl}{454}{conturs}{}
\functionlistentry{int}{ConturList::Del}{int i}{457}{conturs}{}
\functionlistentry{\hyperlink{Contur}{Contur} *}{ConturList::GetContur}{int i}{458}{conturs}{}
\functionlistentry{\hyperlink{ConturList}{ConturList} \&}{ConturList::operator=}{const \hyperlink{ConturList}{ConturList}\& cl}{455}{conturs}{}
\functionlistentry{IMatrix}{ConturPointlist}{const \hyperlink{Contur}{Contur} \&c,int diff=1,bool close=true}{429}{conturs}{}
\functionlistentry{int}{FeatureContur}{\hyperlink{Contur}{Contur} c,double \&length,double \&area,double \&form,double \&conv}{430}{conturs}{}
\functionlistentry{}{Freeman::Freeman}{}{464}{conturs}{}
\functionlistentry{}{Freeman::Freeman}{int dir}{465}{conturs}{}
\functionlistentry{}{Freeman::Freeman}{const \hyperlink{Freeman}{Freeman} \&sec}{466}{conturs}{}
\functionlistentry{int}{Freeman::Int}{}{467}{conturs}{}
\functionlistentry{void}{Freeman::move}{int x,int y,int \&xn,int \&yn}{468}{conturs}{}
\functionlistentry{void}{Freeman::move}{int \&x,int \&y}{469}{conturs}{}
\functionlistentry{void}{Freeman::move}{IPoint p1,IPoint \&p2}{470}{conturs}{}
\functionlistentry{void}{Freeman::move}{IPoint \&p}{471}{conturs}{}
\functionlistentry{IPoint}{Freeman::step}{IPoint \&p}{472}{conturs}{}
\functionlistentry{\hyperlink{Contur}{Contur}}{GetContur}{int ps[2],int (*cls)(int,int,void*),void *par,int lng}{442}{conturs}{}
\functionlistentry{int}{GradThreshold}{\hyperlink{Image}{Image} img}{445}{conturs}{}
\functionlistentry{\hyperlink{Freeman}{Freeman}}{Inverse}{}{473}{conturs}{}
\functionlistentry{int}{LocalSeg}{\hyperlink{Image}{Image} source,\hyperlink{Image}{Image} oimg,int neighb,int level}{443}{conturs}{}
\functionlistentry{int}{LocalSeg}{\hyperlink{Image}{Image} source,\hyperlink{Image}{Image} oimg,int neighb,int level1,int level2}{444}{conturs}{}
\functionlistentry{\hyperlink{Contur}{Contur}}{operator+}{const \hyperlink{Contur}{Contur} \&c1,const \hyperlink{Contur}{Contur} \&c2}{404}{conturs}{}
\functionlistentry{bool}{pointInside}{double x,double y,const \hyperlink{Contur}{Contur} \&c}{459}{conturs}{}
\functionlistentry{bool}{pointInside}{const \hyperlink{Point}{Point} \&p,const \hyperlink{Contur}{Contur} \&c}{460}{conturs}{}
\functionlistentry{bool}{pointInside}{double x,double y,const \hyperlink{Matrix}{Matrix} \&pl}{461}{conturs}{}
\functionlistentry{bool}{pointInside}{const \hyperlink{Point}{Point} \&p,const \hyperlink{Matrix}{Matrix} \&pl}{462}{conturs}{}
\functionlistentry{void}{Region::add}{int x,int y}{477}{conturs}{}
\functionlistentry{void}{Region::add}{const IPoint \&p}{478}{conturs}{}
\functionlistentry{void}{Region::add}{const \hyperlink{Point}{Point} \&p}{479}{conturs}{}
\functionlistentry{void}{Region::add}{int x1,int y1,int x2,int y2}{480}{conturs}{}
\functionlistentry{void}{Region::add}{const \hyperlink{Window}{Window} \&w}{481}{conturs}{}
\functionlistentry{void}{Region::add}{const \hyperlink{Region}{Region} \&r}{482}{conturs}{}
\functionlistentry{int}{Region::CalcMoments}{\hyperlink{Moments}{Moments} \&m}{494}{conturs}{}
\functionlistentry{void}{Region::del}{int x,int y}{485}{conturs}{}
\functionlistentry{void}{Region::del}{const \hyperlink{Point}{Point} \&p}{486}{conturs}{}
\functionlistentry{void}{Region::del}{const IPoint \&p}{487}{conturs}{}
\functionlistentry{void}{Region::del}{int x1,int y1,int x2,int y2}{488}{conturs}{}
\functionlistentry{void}{Region::del}{const \hyperlink{Region}{Region} \&r}{489}{conturs}{}
\functionlistentry{int}{Region::getArea}{}{493}{conturs}{}
\functionlistentry{void}{Region::getPoints}{vector\textless {}IPoint\textgreater  \&points}{495}{conturs}{}
\functionlistentry{bool}{Region::inside}{int x,int y}{491}{conturs}{}
\functionlistentry{bool}{Region::isEmpty}{void}{492}{conturs}{}
\functionlistentry{\hyperlink{Region}{Region}}{Region::operator +}{const \hyperlink{Region}{Region} \&r1,const \hyperlink{Region}{Region} \&r2}{484}{conturs}{}
\functionlistentry{const \hyperlink{Region}{Region} \&}{Region::operator +=}{const \hyperlink{Region}{Region} \&r2}{483}{conturs}{}
\functionlistentry{\hyperlink{Region}{Region}}{Region::operator -}{const \hyperlink{Region}{Region} \&r1,const \hyperlink{Region}{Region} \&r2}{490}{conturs}{}
\functionlistentry{}{Region::Region}{}{474}{conturs}{}
\functionlistentry{}{Region::Region}{const \hyperlink{Region}{Region} \&r}{475}{conturs}{}
\functionlistentry{}{Region::Region}{const \hyperlink{Contur}{Contur} \&c}{476}{conturs}{}
\functionlistentry{int}{RidgeThreshold}{\hyperlink{Image}{Image} img}{450}{conturs}{}
\functionlistentry{double}{RoughnessContur}{\hyperlink{Contur}{Contur} c, int diff}{431}{conturs}{}
\functionlistentry{int}{SearchCircStart}{\hyperlink{Image}{Image} iv,\hyperlink{Image}{Image} io,int c[2],int r,int pgl,int ps[2]}{447}{conturs}{}
\functionlistentry{int}{SearchCStart}{\hyperlink{Image}{Image} iv,\hyperlink{Image}{Image} io,\hyperlink{Contur}{Contur} c,int *ptr,int pgl,int ps[2]}{448}{conturs}{}
\functionlistentry{int}{SearchGradStart}{\hyperlink{Image}{Image} iv,\hyperlink{Image}{Image} io,int thr,int diff,int ps[2],int mode}{446}{conturs}{}
\functionlistentry{int}{SearchRidgeStart}{\hyperlink{Image}{Image} imgv,\hyperlink{Image}{Image} imgo,int thr,int diff,int ps[2],int mode}{451}{conturs}{}
\functionlistentry{int}{SearchStart}{\hyperlink{Image}{Image} iv,\hyperlink{Image}{Image} io,object\_rc (*cls)(),int thr,int diff,int ps[2],int mode=HORZ}{438}{conturs}{}
\functionlistentry{int}{SearchStart}{\hyperlink{Image}{Image} iv,\hyperlink{Image}{Image} io,int (*cls)(),int thr,int diff,IPoint \&ps,int mode=HORZ}{439}{conturs}{}

\subtitle{\hyperlink{SECTION:geoObject}{Klassen-Hierarchie Geometrisches Objekt}}\\
\functionlistentry{}{Circle::Circle}{}{514}{geoObject}{}
\functionlistentry{}{Circle::Circle}{const \hyperlink{Circle}{Circle} \&c}{515}{geoObject}{}
\functionlistentry{}{Circle::Circle}{double xm,double ym,double r}{516}{geoObject}{}
\functionlistentry{}{Circle::Circle}{\hyperlink{Point}{Point} m,double r}{517}{geoObject}{}
\functionlistentry{explicit}{Circle::Circle}{const \hyperlink{Vector}{Vector} \&c}{518}{geoObject}{}
\functionlistentry{explicit}{Circle::Circle}{const double d[]}{519}{geoObject}{}
\functionlistentry{double}{Circle::getR}{}{520}{geoObject}{}
\functionlistentry{void}{Circle::setR}{double val}{521}{geoObject}{}
\functionlistentry{}{CircleSeg::CircleSeg}{}{522}{geoObject}{}
\functionlistentry{}{CircleSeg::CircleSeg}{const \hyperlink{CircleSeg}{CircleSeg} \&c}{523}{geoObject}{}
\functionlistentry{}{CircleSeg::CircleSeg}{double xm,double ym,double r, double phi1,double phi2}{524}{geoObject}{}
\functionlistentry{}{CircleSeg::CircleSeg}{\hyperlink{Point}{Point} p,double r,double phi1,double phi2}{525}{geoObject}{}
\functionlistentry{explicit}{CircleSeg::CircleSeg}{const \hyperlink{Vector}{Vector} \&c}{526}{geoObject}{}
\functionlistentry{explicit}{CircleSeg::CircleSeg}{const double d[]}{527}{geoObject}{}
\functionlistentry{double }{CircleSeg::getPhi1}{}{528}{geoObject}{}
\functionlistentry{double}{CircleSeg::getPhi2}{}{530}{geoObject}{}
\functionlistentry{void}{CircleSeg::setPhi1}{double val}{529}{geoObject}{}
\functionlistentry{void}{CircleSeg::setPhi2}{double val}{531}{geoObject}{}
\functionlistentry{int}{Draw}{const \hyperlink{Circle}{Circle} \&c,\hyperlink{Image}{Image} \&img,int val,int fval=-1}{623}{geoObject}{}
\functionlistentry{int}{Draw}{const \hyperlink{CircleSeg}{CircleSeg} \&c,\hyperlink{Image}{Image} \&img,int val,int fval=-1}{624}{geoObject}{}
\functionlistentry{int}{Draw}{const \hyperlink{Ellipse}{Ellipse} \&c,\hyperlink{Image}{Image} \&img,int val,int fval=-1}{625}{geoObject}{}
\functionlistentry{int}{Draw}{const \hyperlink{EllipseSeg}{EllipseSeg} \&c,\hyperlink{Image}{Image} \&img,int val,int fval=-1}{626}{geoObject}{}
\functionlistentry{int}{Draw}{const \hyperlink{LineSeg}{LineSeg} \&c,\hyperlink{Image}{Image} \&img,int val}{627}{geoObject}{}
\functionlistentry{int}{Draw}{const \hyperlink{Polygon}{Polygon} \&c,\hyperlink{Image}{Image} \&img,int val,int fval=-1}{628}{geoObject}{}
\functionlistentry{void}{edge}{int i,\hyperlink{LineSeg}{LineSeg} \&l}{601}{geoObject}{}
\functionlistentry{void}{edge}{int i,\hyperlink{LineSeg}{LineSeg} \&l}{620}{geoObject}{}
\functionlistentry{}{Ellipse::Ellipse}{}{532}{geoObject}{}
\functionlistentry{}{Ellipse::Ellipse}{const \hyperlink{Ellipse}{Ellipse} \&c}{533}{geoObject}{}
\functionlistentry{}{Ellipse::Ellipse}{double xm,double ym,double r1,double r2,double phi}{534}{geoObject}{}
\functionlistentry{explicit}{Ellipse::Ellipse}{const \hyperlink{Vector}{Vector} \&c}{535}{geoObject}{}
\functionlistentry{explicit}{Ellipse::Ellipse}{const double d[]}{536}{geoObject}{}
\functionlistentry{double}{Ellipse::getR1}{}{537}{geoObject}{}
\functionlistentry{double}{Ellipse::getR2}{}{539}{geoObject}{}
\functionlistentry{void}{Ellipse::setR1}{double val}{538}{geoObject}{}
\functionlistentry{void}{Ellipse::setR2}{double val}{540}{geoObject}{}
\functionlistentry{}{EllipseSeg::EllipseSeg}{void}{541}{geoObject}{}
\functionlistentry{}{EllipseSeg::EllipseSeg}{const \hyperlink{EllipseSeg}{EllipseSeg} \&c}{542}{geoObject}{}
\functionlistentry{}{EllipseSeg::EllipseSeg}{double xm,double ym,double r1,double r2,double phi,double phi1,double phi2}{543}{geoObject}{}
\functionlistentry{explicit}{EllipseSeg::EllipseSeg}{const \hyperlink{Vector}{Vector} \&c}{544}{geoObject}{}
\functionlistentry{explicit}{EllipseSeg::EllipseSeg}{const double d[]}{545}{geoObject}{}
\functionlistentry{double}{EllipseSeg::Phi1}{void}{546}{geoObject}{}
\functionlistentry{double}{EllipseSeg::Phi2}{void}{548}{geoObject}{}
\functionlistentry{void}{EllipseSeg::setPhi1}{double val}{547}{geoObject}{}
\functionlistentry{void}{EllipseSeg::setPhi2}{double val}{549}{geoObject}{}
\functionlistentry{double}{GeoObject::Distance}{double x,double y}{507}{geoObject}{}
\functionlistentry{double}{GeoObject::Distance}{IPoint p}{508}{geoObject}{}
\functionlistentry{double}{GeoObject::Distance}{\hyperlink{Point}{Point} p}{509}{geoObject}{}
\functionlistentry{double}{GeoObject::Distance}{const \hyperlink{GeoObject}{GeoObject} \&obj}{510}{geoObject}{}
\functionlistentry{}{GeoObject::GeoObject}{}{497}{geoObject}{}
\functionlistentry{}{GeoObject::GeoObject}{const \hyperlink{GeoObject}{GeoObject} \&c}{498}{geoObject}{}
\functionlistentry{}{GeoObject::GeoObject}{double xm,double ym}{499}{geoObject}{}
\functionlistentry{explicit}{GeoObject::GeoObject}{\hyperlink{Point}{Point} m}{500}{geoObject}{}
\functionlistentry{explicit}{GeoObject::GeoObject}{IPoint m}{501}{geoObject}{}
\functionlistentry{explicit}{GeoObject::GeoObject}{const \hyperlink{Vector}{Vector} \&v}{502}{geoObject}{}
\functionlistentry{\hyperlink{Point}{Point}}{GeoObject::getPos}{}{503}{geoObject}{}
\functionlistentry{bool}{GeoObject::Inside}{double xp,double yp}{511}{geoObject}{}
\functionlistentry{bool}{GeoObject::Inside}{IPoint p}{512}{geoObject}{}
\functionlistentry{bool}{GeoObject::Inside}{\hyperlink{Point}{Point} p}{513}{geoObject}{}
\functionlistentry{void}{GeoObject::setPos}{\hyperlink{Point}{Point} x}{504}{geoObject}{}
\functionlistentry{void}{GeoObject::Shift}{double dx,double dy}{505}{geoObject}{}
\functionlistentry{void}{GeoObject::Shift}{\hyperlink{Point}{Point} p}{506}{geoObject}{}
\functionlistentry{int}{getClosestCorner}{\hyperlink{Point}{Point} p}{605}{geoObject}{}
\functionlistentry{int}{getClosestEdge}{\hyperlink{Point}{Point} p}{606}{geoObject}{}
\functionlistentry{double}{LineSeg::Angle}{const \hyperlink{LineSeg}{LineSeg} \&sec}{570}{geoObject}{}
\functionlistentry{void}{LineSeg::CalcHesse}{double \&p,double \&phi}{566}{geoObject}{}
\functionlistentry{\hyperlink{Point}{Point}}{LineSeg::ClosestPoint}{\hyperlink{Point}{Point} p}{573}{geoObject}{}
\functionlistentry{\hyperlink{Point}{Point}}{LineSeg::ClosestPoint}{\hyperlink{Point}{Point} p,double \&my}{574}{geoObject}{}
\functionlistentry{double}{LineSeg::Distance}{\hyperlink{Point}{Point} p}{575}{geoObject}{}
\functionlistentry{\hyperlink{Point}{Point}}{LineSeg::getP1}{}{558}{geoObject}{}
\functionlistentry{\hyperlink{Point}{Point}}{LineSeg::getP2}{}{559}{geoObject}{}
\functionlistentry{bool}{LineSeg::Intersection}{const \hyperlink{LineSeg}{LineSeg} \&second}{576}{geoObject}{}
\functionlistentry{bool}{LineSeg::Intersection}{const \hyperlink{LineSeg}{LineSeg} \&second,\hyperlink{Point}{Point} \&ip}{577}{geoObject}{}
\functionlistentry{bool}{LineSeg::Intersection}{const \hyperlink{LineSeg}{LineSeg} \&second,\hyperlink{Point}{Point} \&ip,double \&my1,double \&my2}{578}{geoObject}{}
\functionlistentry{bool}{LineSeg::LeftOf}{\hyperlink{Point}{Point} p}{572}{geoObject}{}
\functionlistentry{double}{LineSeg::LimitedMy}{double my}{565}{geoObject}{}
\functionlistentry{}{LineSeg::LineSeg}{}{550}{geoObject}{}
\functionlistentry{}{LineSeg::LineSeg}{\hyperlink{Point}{Point} p1,\hyperlink{Point}{Point} p2,int type=\hyperlink{LineSeg}{LineSeg}::segment}{551}{geoObject}{}
\functionlistentry{}{LineSeg::LineSeg}{IPoint p1,IPoint p2,int type=\hyperlink{LineSeg}{LineSeg}::segment}{552}{geoObject}{}
\functionlistentry{}{LineSeg::LineSeg}{const \hyperlink{LineSeg}{LineSeg} \&p}{553}{geoObject}{}
\functionlistentry{}{LineSeg::LineSeg}{double x1,double y1,double x2,double y2,int type=\hyperlink{LineSeg}{LineSeg}::segment}{554}{geoObject}{}
\functionlistentry{}{LineSeg::LineSeg}{double p,double phi}{555}{geoObject}{}
\functionlistentry{explicit}{LineSeg::LineSeg}{const \hyperlink{Vector}{Vector} \&v,int type=\hyperlink{LineSeg}{LineSeg}::segment}{556}{geoObject}{}
\functionlistentry{explicit}{LineSeg::LineSeg}{double d[],int type=\hyperlink{LineSeg}{LineSeg}::segment}{557}{geoObject}{}
\functionlistentry{\hyperlink{Point}{Point}}{LineSeg::Normal}{}{579}{geoObject}{}
\functionlistentry{double}{LineSeg::OrientationAngle}{}{569}{geoObject}{}
\functionlistentry{double}{LineSeg::P}{}{567}{geoObject}{}
\functionlistentry{double}{LineSeg::Phi}{}{568}{geoObject}{}
\functionlistentry{\hyperlink{Point}{Point}}{LineSeg::RelPoint}{double my}{564}{geoObject}{}
\functionlistentry{bool}{LineSeg::RightOf}{\hyperlink{Point}{Point} p}{571}{geoObject}{}
\functionlistentry{void}{LineSeg::setP1}{\hyperlink{Point}{Point} p}{560}{geoObject}{}
\functionlistentry{void}{LineSeg::setP2}{\hyperlink{Point}{Point} p}{561}{geoObject}{}
\functionlistentry{void}{LineSeg::setType}{int type}{563}{geoObject}{}
\functionlistentry{int}{LineSeg::Type}{}{562}{geoObject}{}
\functionlistentry{\hyperlink{Contur}{Contur}}{MakeContur}{}{604}{geoObject}{}
\functionlistentry{\hyperlink{LineSeg}{LineSeg}}{Polygon::edge}{int i}{619}{geoObject}{}
\functionlistentry{const \hyperlink{Point}{Point} \&}{Polygon::operator[]}{int i}{618}{geoObject}{}
\functionlistentry{}{Polygon::Polygon}{}{611}{geoObject}{}
\functionlistentry{}{Polygon::Polygon}{const \hyperlink{Polygon}{Polygon} \&p}{612}{geoObject}{}
\functionlistentry{}{Polygon::Polygon}{\hyperlink{Point}{Point} p}{613}{geoObject}{}
\functionlistentry{explicit}{Polygon::Polygon}{const \hyperlink{Matrix}{Matrix} \&m}{614}{geoObject}{}
\functionlistentry{}{Polygon::Polygon}{const vector<\hyperlink{Point}{Point}> \&pl}{615}{geoObject}{}
\functionlistentry{explicit}{Polygon::Polygon}{const \hyperlink{Contur}{Contur} \&c}{616}{geoObject}{}
\functionlistentry{void}{Polygon::Reset}{}{621}{geoObject}{}
\functionlistentry{void}{Polygon::Reset}{\hyperlink{Point}{Point} p}{622}{geoObject}{}
\functionlistentry{int}{Polygon::size}{}{617}{geoObject}{}
\functionlistentry{\hyperlink{LineSeg}{LineSeg}}{PolygonalCurve::edge}{int i}{600}{geoObject}{}
\functionlistentry{bool}{PolygonalCurve::isClosed()}{}{598}{geoObject}{}
\functionlistentry{const \hyperlink{Point}{Point} \&}{PolygonalCurve::operator[]}{int i}{599}{geoObject}{}
\functionlistentry{}{PolygonalCurve::PolygonalCurve}{bool closed=false}{591}{geoObject}{}
\functionlistentry{}{PolygonalCurve::PolygonalCurve}{const \hyperlink{PolygonalCurve}{PolygonalCurve} \&p}{592}{geoObject}{}
\functionlistentry{}{PolygonalCurve::PolygonalCurve}{\hyperlink{Point}{Point} p,bool closed=false}{593}{geoObject}{}
\functionlistentry{explicit}{PolygonalCurve::PolygonalCurve}{const \hyperlink{Matrix}{Matrix} \&m, bool closed=false}{594}{geoObject}{}
\functionlistentry{}{PolygonalCurve::PolygonalCurve}{const vector<\hyperlink{Point}{Point}> \&pl,bool closed=false}{595}{geoObject}{}
\functionlistentry{explicit}{PolygonalCurve::PolygonalCurve}{const \hyperlink{Contur}{Contur} \&c, bool closed=false}{596}{geoObject}{}
\functionlistentry{\hyperlink{PolygonalCurve}{PolygonalCurve}}{PolygonalCurve::ReducedToPrecision}{double prec,int mode=1}{609}{geoObject}{}
\functionlistentry{void}{PolygonalCurve::ReducedToPrecision}{double prec,\hyperlink{PolygonalCurve}{PolygonalCurve} \&res,int mode=1}{610}{geoObject}{}
\functionlistentry{void}{PolygonalCurve::Reset}{}{602}{geoObject}{}
\functionlistentry{void}{PolygonalCurve::Reset}{\hyperlink{Point}{Point} p}{603}{geoObject}{}
\functionlistentry{int}{PolygonalCurve::size}{}{597}{geoObject}{}
\functionlistentry{\hyperlink{PolygonalCurve}{PolygonalCurve}}{Reduced}{int nr, int mode=1}{607}{geoObject}{}
\functionlistentry{void}{Reduced}{int nr, \hyperlink{PolygonalCurve}{PolygonalCurve} \&p, int mode=1}{608}{geoObject}{}
\functionlistentry{void}{Triangle2Region}{const \hyperlink{Triangle}{Triangle} \&t, \hyperlink{Region}{Region} \&r}{590}{geoObject}{}
\functionlistentry{\hyperlink{Point}{Point}}{Triangle::getCCCenter}{}{587}{geoObject}{}
\functionlistentry{double}{Triangle::getCCRadius}{}{588}{geoObject}{}
\functionlistentry{\hyperlink{Point}{Point}}{Triangle::getCorner}{int i}{583}{geoObject}{}
\functionlistentry{bool}{Triangle::isInsideCC}{\hyperlink{Point}{Point} point}{589}{geoObject}{}
\functionlistentry{bool}{Triangle::isValid}{}{582}{geoObject}{}
\functionlistentry{const \hyperlink{Point}{Point} \&}{Triangle::P1}{}{584}{geoObject}{}
\functionlistentry{const \hyperlink{Point}{Point} \&}{Triangle::P2}{}{585}{geoObject}{}
\functionlistentry{const \hyperlink{Point}{Point} \&}{Triangle::P3}{}{586}{geoObject}{}
\functionlistentry{}{Triangle::Triangle}{}{580}{geoObject}{}
\functionlistentry{}{Triangle::Triangle}{\hyperlink{Point}{Point} p1, \hyperlink{Point}{Point} p2, \hyperlink{Point}{Point} p3}{581}{geoObject}{}

\subtitle{\hyperlink{SECTION:geoObject3d}{Klassen-Hierarchie Geometrisches 3D-Objekt}}\\
\functionlistentry{double}{GeoObject3d::Distance}{double dx,double dy,double dz}{646}{geoObject3d}{}
\functionlistentry{double}{GeoObject3d::Distance}{const \hyperlink{Vector3d}{Vector3d} \&ob}{647}{geoObject3d}{}
\functionlistentry{}{GeoObject3d::GeoObject3d}{void}{630}{geoObject3d}{}
\functionlistentry{}{GeoObject3d::GeoObject3d}{const \hyperlink{GeoObject3d}{GeoObject3d} \&p}{631}{geoObject3d}{}
\functionlistentry{}{GeoObject3d::GeoObject3d}{const \hyperlink{Vector3d}{Vector3d} \&p}{632}{geoObject3d}{}
\functionlistentry{}{GeoObject3d::GeoObject3d}{double xp,double yp,double zp}{633}{geoObject3d}{}
\functionlistentry{explicit}{GeoObject3d::GeoObject3d}{const \hyperlink{Vector}{Vector} \&v}{634}{geoObject3d}{}
\functionlistentry{explicit}{GeoObject3d::GeoObject3d}{double p[]}{635}{geoObject3d}{}
\functionlistentry{\hyperlink{Vector3d}{Vector3d} \&}{GeoObject3d::Pos}{}{643}{geoObject3d}{}
\functionlistentry{void}{GeoObject3d::set}{const \hyperlink{Vector}{Vector} \&v}{642}{geoObject3d}{}
\functionlistentry{void}{GeoObject3d::setX}{double x}{639}{geoObject3d}{}
\functionlistentry{void}{GeoObject3d::setY}{double y}{640}{geoObject3d}{}
\functionlistentry{void}{GeoObject3d::setZ}{double z}{641}{geoObject3d}{}
\functionlistentry{void}{GeoObject3d::Shift}{double dx,double dy,double dz}{644}{geoObject3d}{}
\functionlistentry{void}{GeoObject3d::Shift}{const \hyperlink{Vector3d}{Vector3d} \&v}{645}{geoObject3d}{}
\functionlistentry{double}{GeoObject3d::Volume}{}{648}{geoObject3d}{}
\functionlistentry{double}{GeoObject3d::X}{void}{636}{geoObject3d}{}
\functionlistentry{double}{GeoObject3d::Y}{void}{637}{geoObject3d}{}
\functionlistentry{double}{GeoObject3d::Z}{void}{638}{geoObject3d}{}
\functionlistentry{\hyperlink{Vector3d}{Vector3d} \&}{Line3d::DP}{}{676}{geoObject3d}{}
\functionlistentry{double}{Line3d::DX}{}{673}{geoObject3d}{}
\functionlistentry{double}{Line3d::DY}{}{674}{geoObject3d}{}
\functionlistentry{double}{Line3d::DZ}{}{675}{geoObject3d}{}
\functionlistentry{}{Line3d::Line3d}{}{659}{geoObject3d}{}
\functionlistentry{}{Line3d::Line3d}{double xp,double yp,double zp,double x2p,double y2p,double z2p}{660}{geoObject3d}{}
\functionlistentry{}{Line3d::Line3d}{const Point3d \&p1,const Point3d \&p2}{661}{geoObject3d}{}
\functionlistentry{}{Line3d::Line3d}{const \hyperlink{Line3d}{Line3d} \&p}{662}{geoObject3d}{}
\functionlistentry{explicit}{Line3d::Line3d}{const \hyperlink{Vector}{Vector} \&v}{663}{geoObject3d}{}
\functionlistentry{explicit}{Line3d::Line3d}{double d[]}{664}{geoObject3d}{}
\functionlistentry{\hyperlink{Vector3d}{Vector3d}}{Line3d::operator()}{double p}{677}{geoObject3d}{}
\functionlistentry{\hyperlink{Vector3d}{Vector3d} \&}{Line3d::P1}{}{668}{geoObject3d}{}
\functionlistentry{\hyperlink{Vector3d}{Vector3d}}{Line3d::P2}{}{672}{geoObject3d}{}
\functionlistentry{double}{Line3d::Volume}{}{678}{geoObject3d}{}
\functionlistentry{double}{Line3d::X1}{}{665}{geoObject3d}{}
\functionlistentry{double}{Line3d::X2}{}{669}{geoObject3d}{}
\functionlistentry{double}{Line3d::Y1}{}{666}{geoObject3d}{}
\functionlistentry{double}{Line3d::Y2}{}{670}{geoObject3d}{}
\functionlistentry{double}{Line3d::Z1}{}{667}{geoObject3d}{}
\functionlistentry{double}{Line3d::Z2}{}{671}{geoObject3d}{}
\functionlistentry{double}{Sphere::R}{}{656}{geoObject3d}{}
\functionlistentry{void}{Sphere::setR}{double vr}{657}{geoObject3d}{}
\functionlistentry{}{Sphere::Sphere}{}{649}{geoObject3d}{}
\functionlistentry{}{Sphere::Sphere}{double xp,double yp,double zp,double rp}{650}{geoObject3d}{}
\functionlistentry{}{Sphere::Sphere}{const \hyperlink{Vector3d}{Vector3d} \&p,double rp}{651}{geoObject3d}{}
\functionlistentry{}{Sphere::Sphere}{const Point3d \&p,double rp}{652}{geoObject3d}{}
\functionlistentry{}{Sphere::Sphere}{const \hyperlink{Sphere}{Sphere} \&p}{653}{geoObject3d}{}
\functionlistentry{explicit}{Sphere::Sphere}{const \hyperlink{Vector}{Vector} \&v}{654}{geoObject3d}{}
\functionlistentry{explicit}{Sphere::Sphere}{double d[]}{655}{geoObject3d}{}
\functionlistentry{double}{Sphere::Volume}{}{658}{geoObject3d}{}

\subtitle{\hyperlink{SECTION:geoTrafo}{Geometrische Transformationen}}\\
\functionlistentry{double}{Distortion0::D2}{void}{750}{geoTrafo}{}
\functionlistentry{}{Distortion0::Distortion0}{void}{728}{geoTrafo}{}
\functionlistentry{}{Distortion0::Distortion0}{double x0,double y0,double d2=0.0}{732}{geoTrafo}{}
\functionlistentry{}{Distortion0::Distortion0}{const \hyperlink{Matrix}{Matrix} \&mark,const \hyperlink{Matrix}{Matrix} \&orig,\hyperlink{Trafo}{Trafo} \&tr,const \hyperlink{Vector}{Vector} \&ImageCenter}{736}{geoTrafo}{}
\functionlistentry{}{Distortion0::Distortion0}{const \hyperlink{Matrix}{Matrix} \&mark,const \hyperlink{Matrix}{Matrix} \&orig,const \hyperlink{Vector}{Vector} \&ImageCenter}{737}{geoTrafo}{}
\functionlistentry{}{Distortion0::Distortion0}{const \hyperlink{Matrix}{Matrix} \&mark,const \hyperlink{Matrix}{Matrix} \&orig}{738}{geoTrafo}{}
\functionlistentry{double}{Distortion1::D2}{void}{751}{geoTrafo}{}
\functionlistentry{double}{Distortion1::D4}{void}{752}{geoTrafo}{}
\functionlistentry{}{Distortion1::Distortion1}{void}{729}{geoTrafo}{}
\functionlistentry{}{Distortion1::Distortion1}{double x0,double y0,double d2=0.0, double d4=0.0}{733}{geoTrafo}{}
\functionlistentry{}{Distortion1::Distortion1}{const \hyperlink{Matrix}{Matrix} \&mark,const \hyperlink{Matrix}{Matrix} \&orig,\hyperlink{Trafo}{Trafo} \&tr,const \hyperlink{Vector}{Vector} \&ImageCenter}{739}{geoTrafo}{}
\functionlistentry{}{Distortion1::Distortion1}{const \hyperlink{Matrix}{Matrix} \&mark,const \hyperlink{Matrix}{Matrix} \&orig,const \hyperlink{Vector}{Vector} \&ImageCenter}{740}{geoTrafo}{}
\functionlistentry{}{Distortion1::Distortion1}{const \hyperlink{Matrix}{Matrix} \&mark,const \hyperlink{Matrix}{Matrix} \&orig}{741}{geoTrafo}{}
\functionlistentry{double}{Distortion2::D2}{void}{753}{geoTrafo}{}
\functionlistentry{double}{Distortion2::D2}{void}{756}{geoTrafo}{}
\functionlistentry{double}{Distortion2::D3}{void}{754}{geoTrafo}{}
\functionlistentry{double}{Distortion2::D4}{void}{755}{geoTrafo}{}
\functionlistentry{double}{Distortion2::D4}{void}{757}{geoTrafo}{}
\functionlistentry{double}{Distortion2::D6}{void}{758}{geoTrafo}{}
\functionlistentry{}{Distortion2::Distortion2}{void}{730}{geoTrafo}{}
\functionlistentry{}{Distortion2::Distortion2}{double x0,double y0,double d2=0.0, double d3=0.0,double d4=0.0}{734}{geoTrafo}{}
\functionlistentry{}{Distortion2::Distortion2}{const \hyperlink{Matrix}{Matrix} \&mark,const \hyperlink{Matrix}{Matrix} \&orig,\hyperlink{Trafo}{Trafo} \&tr,const \hyperlink{Vector}{Vector} \&ImageCenter}{742}{geoTrafo}{}
\functionlistentry{}{Distortion2::Distortion2}{const \hyperlink{Matrix}{Matrix} \&mark,const \hyperlink{Matrix}{Matrix} \&orig,const \hyperlink{Vector}{Vector} \&ImageCenter}{743}{geoTrafo}{}
\functionlistentry{}{Distortion2::Distortion2}{const \hyperlink{Matrix}{Matrix} \&mark,const \hyperlink{Matrix}{Matrix} \&orig}{744}{geoTrafo}{}
\functionlistentry{}{Distortion3::Distortion3}{void}{731}{geoTrafo}{}
\functionlistentry{}{Distortion3::Distortion3}{double x0,double y0,double d2=0.0, double d4=0.0,double d6=0.0}{735}{geoTrafo}{}
\functionlistentry{}{Distortion3::Distortion3}{const \hyperlink{Matrix}{Matrix} \&mark,const \hyperlink{Matrix}{Matrix} \&orig,\hyperlink{Trafo}{Trafo} \&tr,const \hyperlink{Vector}{Vector} \&ImageCenter}{745}{geoTrafo}{}
\functionlistentry{}{Distortion3::Distortion3}{const \hyperlink{Matrix}{Matrix} \&mark,const \hyperlink{Matrix}{Matrix} \&orig,const \hyperlink{Vector}{Vector} \&ImageCenter}{746}{geoTrafo}{}
\functionlistentry{}{Distortion3::Distortion3}{const \hyperlink{Matrix}{Matrix} \&mark,const \hyperlink{Matrix}{Matrix} \&orig}{747}{geoTrafo}{}
\functionlistentry{int}{Distortion::Distort}{double \&x,double \&y}{759}{geoTrafo}{}
\functionlistentry{int}{Distortion::Distort}{double x,double y,double \&xd,double \&yd}{760}{geoTrafo}{}
\functionlistentry{\hyperlink{Vector}{Vector}}{Distortion::Distort}{const \hyperlink{Vector}{Vector} \&p}{761}{geoTrafo}{}
\functionlistentry{\hyperlink{Point}{Point}}{Distortion::Distort}{const \hyperlink{Point}{Point} \&p}{762}{geoTrafo}{}
\functionlistentry{int}{Distortion::Rect}{double \&x,double \&y}{763}{geoTrafo}{}
\functionlistentry{int}{Distortion::Rect}{double x,double y,double \&xr,double \&yr}{764}{geoTrafo}{}
\functionlistentry{\hyperlink{Vector}{Vector}}{Distortion::Rect}{const \hyperlink{Vector}{Vector} \&p}{765}{geoTrafo}{}
\functionlistentry{\hyperlink{Point}{Point}}{Distortion::Rect}{const \hyperlink{Point}{Point} \&p}{766}{geoTrafo}{}
\functionlistentry{\hyperlink{Image}{Image}}{Distortion::RectImg}{\hyperlink{Image}{Image} source,int mode=DEFAULT}{767}{geoTrafo}{}
\functionlistentry{\hyperlink{Image}{Image}}{Distortion::RectImg}{\hyperlink{Image}{Image} source,\hyperlink{Image}{Image} dest,int mode=DEFAULT}{768}{geoTrafo}{}
\functionlistentry{double}{Distortion::X0}{void}{748}{geoTrafo}{}
\functionlistentry{double}{Distortion::Y0}{void}{749}{geoTrafo}{}
\functionlistentry{\hyperlink{Trafo}{Trafo}}{operator *}{const \hyperlink{Trafo}{Trafo} \&,const \hyperlink{Trafo}{Trafo} \&}{687}{geoTrafo}{}
\functionlistentry{\hyperlink{Vector}{Vector}}{operator *}{const \hyperlink{Trafo}{Trafo} \&,const \hyperlink{Vector}{Vector} \&}{688}{geoTrafo}{}
\functionlistentry{int}{Trafo::DimD}{void}{690}{geoTrafo}{}
\functionlistentry{int}{Trafo::DimS}{void}{689}{geoTrafo}{}
\functionlistentry{int}{Trafo::Flip}{int axis}{704}{geoTrafo}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{Trafo::Init}{void}{692}{geoTrafo}{}
\functionlistentry{\hyperlink{Trafo}{Trafo}}{Trafo::Inverse}{}{694}{geoTrafo}{}
\functionlistentry{int}{Trafo::Invert}{}{693}{geoTrafo}{}
\functionlistentry{double \&}{Trafo::operator ()}{int x,int y}{686}{geoTrafo}{}
\functionlistentry{\hyperlink{Trafo}{Trafo} \&}{Trafo::operator =}{const \hyperlink{Trafo}{Trafo} \&}{684}{geoTrafo}{}
\functionlistentry{\hyperlink{Trafo}{Trafo} \&}{Trafo::operator =}{const \hyperlink{Matrix}{Matrix} \&}{685}{geoTrafo}{}
\functionlistentry{int}{Trafo::Projective}{void}{713}{geoTrafo}{}
\functionlistentry{int}{Trafo::Rotate}{double x0,double y0,double phi}{699}{geoTrafo}{}
\functionlistentry{int}{Trafo::Rotate}{vector3d point,vector3d dir,double phi}{700}{geoTrafo}{}
\functionlistentry{int}{Trafo::RotateX}{double phi}{701}{geoTrafo}{}
\functionlistentry{int}{Trafo::RotateY}{double phi}{702}{geoTrafo}{}
\functionlistentry{int}{Trafo::RotateZ}{double phi}{703}{geoTrafo}{}
\functionlistentry{int}{Trafo::Scale}{double x0, double y0, double f}{707}{geoTrafo}{}
\functionlistentry{int}{Trafo::Scale}{double x0, double y0, double fx,double fy}{708}{geoTrafo}{}
\functionlistentry{int}{Trafo::Scale}{vector3d v, double f}{709}{geoTrafo}{}
\functionlistentry{int}{Trafo::Scale}{vector3d v, double fx,double fy,double fz}{710}{geoTrafo}{}
\functionlistentry{int}{Trafo::Scale}{\hyperlink{Vector}{Vector} v, double f}{711}{geoTrafo}{}
\functionlistentry{int}{Trafo::Scale}{\hyperlink{Vector}{Vector} v, \hyperlink{Vector}{Vector} f}{712}{geoTrafo}{}
\functionlistentry{int}{Trafo::ShearX}{double dxy}{705}{geoTrafo}{}
\functionlistentry{int}{Trafo::ShearY}{double dyx}{706}{geoTrafo}{}
\functionlistentry{int}{Trafo::Shift}{double x0,double y0}{695}{geoTrafo}{}
\functionlistentry{int}{Trafo::Shift}{double x0,double y0,double y0}{696}{geoTrafo}{}
\functionlistentry{int}{Trafo::Shift}{vector3d v}{697}{geoTrafo}{}
\functionlistentry{int}{Trafo::Shift}{\hyperlink{Vector}{Vector} v}{698}{geoTrafo}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{Trafo::Tmatrix}{void}{691}{geoTrafo}{}
\functionlistentry{}{Trafo::Trafo}{void}{680}{geoTrafo}{}
\functionlistentry{}{Trafo::Trafo}{const \hyperlink{Trafo}{Trafo} \&}{681}{geoTrafo}{}
\functionlistentry{}{Trafo::Trafo}{const \hyperlink{Matrix}{Matrix} \&}{682}{geoTrafo}{}
\functionlistentry{}{Trafo::Trafo}{int dims,int dimd}{683}{geoTrafo}{}
\functionlistentry{int}{Transform}{const \hyperlink{Trafo}{Trafo} \&,double \&x,double \&y}{714}{geoTrafo}{}
\functionlistentry{int}{Transform}{const \hyperlink{Trafo}{Trafo} \&,\hyperlink{Point}{Point} \&p}{715}{geoTrafo}{}
\functionlistentry{int}{Transform}{const \hyperlink{Trafo}{Trafo} \&,double x,double y,double \&xt,double \&yt}{716}{geoTrafo}{}
\functionlistentry{int}{Transform}{const \hyperlink{Trafo}{Trafo} \&,\hyperlink{Point}{Point} p1,\hyperlink{Point}{Point} \&p2}{717}{geoTrafo}{}
\functionlistentry{int}{Transform}{const \hyperlink{Trafo}{Trafo} \&,double \&x,double \&y,double \&z)}{720}{geoTrafo}{}
\functionlistentry{int}{Transform}{const \hyperlink{Trafo}{Trafo} \&,double x,double y,double z,double \&xt,double \&yt,double \&zt}{721}{geoTrafo}{}
\functionlistentry{int}{Transform}{const \hyperlink{Trafo}{Trafo} \&,double x,double y,double z,double \&xt,double \&yt}{722}{geoTrafo}{}
\functionlistentry{\hyperlink{Contur}{Contur}}{Transform}{const \hyperlink{Trafo}{Trafo} \& tr,const \hyperlink{Contur}{Contur} \& c}{725}{geoTrafo}{}
\functionlistentry{int}{Transform}{const \hyperlink{Trafo}{Trafo} \&,const \hyperlink{Image}{Image} \&simg,\hyperlink{Image}{Image} \&dimg,int mode=DEFAULT}{726}{geoTrafo}{}
\functionlistentry{int}{Transform}{const \hyperlink{Trafo}{Trafo} \&,const \hyperlink{Image}{Image} \&simg,\hyperlink{Image}{Image} \&dimg,int mode, \hyperlink{Image}{Image} \&mark,int val=1}{727}{geoTrafo}{}
\functionlistentry{int}{TransformAndRound}{const \hyperlink{Trafo}{Trafo} \&,int \&x,int \&y}{718}{geoTrafo}{}
\functionlistentry{int}{TransformAndRound}{const \hyperlink{Trafo}{Trafo} \&,int x,int y,int \&xt,int \&yt}{719}{geoTrafo}{}
\functionlistentry{int}{TransformList}{const \hyperlink{Trafo}{Trafo} \&tr,\hyperlink{Matrix}{Matrix} \&m}{723}{geoTrafo}{}
\functionlistentry{int}{TransformList}{const \hyperlink{Trafo}{Trafo} \&tr,const \hyperlink{Matrix}{Matrix} \&m,\hyperlink{Matrix}{Matrix} \&m2}{724}{geoTrafo}{}

\subtitle{\hyperlink{SECTION:cameraModel}{Kameramodelle}}\\
\functionlistentry{int}{AssignCalibPattern}{\hyperlink{Image}{Image} \&image, \hyperlink{Matrix}{Matrix} \&imagepoints, \hyperlink{Matrix}{Matrix} \&worldpoints, \hyperlink{Image}{Image} debug\_image = \hyperlink{Image}{Image}(), \hyperlink{Image}{Image} debug\_mark = \hyperlink{Image}{Image}()}{794}{cameraModel}{}
\functionlistentry{int}{AssignCalibPattern}{\hyperlink{Image}{Image} \&image, \hyperlink{Matrix}{Matrix} \&imagepoints, \hyperlink{Matrix}{Matrix} \&worldpoints, \hyperlink{Camera}{Camera} \&c, \hyperlink{Image}{Image} debug\_image = \hyperlink{Image}{Image}(), \hyperlink{Image}{Image} debug\_mark = \hyperlink{Image}{Image}()}{795}{cameraModel}{}
\functionlistentry{int}{Calibrate}{vector$<$\hyperlink{Image}{Image}$>$ \&images, \hyperlink{Camera}{Camera} \&c, bool dist=true, \hyperlink{Image}{Image} debug\_image = \hyperlink{Image}{Image}(), \hyperlink{Image}{Image} debug\_mark = \hyperlink{Image}{Image}()}{792}{cameraModel}{}
\functionlistentry{int}{Calibrate}{vector$<$\hyperlink{Image}{Image}$>$ \&images, vector$<$\hyperlink{Camera}{Camera}$>$ \&cv, bool dist=true, \hyperlink{Image}{Image} debug\_image = \hyperlink{Image}{Image}(), \hyperlink{Image}{Image} debug\_mark = \hyperlink{Image}{Image}()}{793}{cameraModel}{}
\functionlistentry{int}{CalibrateWithHomographies}{vector$<$\hyperlink{Trafo}{Trafo}$>$ \&H, \hyperlink{Camera}{Camera} \&c}{799}{cameraModel}{}
\functionlistentry{int}{CalibrateWithHomographies}{vector$<$\hyperlink{Trafo}{Trafo}$>$ \&H, vector$<$\hyperlink{Camera}{Camera}$>$ \&cv}{800}{cameraModel}{}
\functionlistentry{int}{CalibrateWithPattern}{vector$<$\hyperlink{Matrix}{Matrix}$>$ \&imagepoints, vector$<$\hyperlink{Matrix}{Matrix}$>$ \&worldpoints, \hyperlink{Camera}{Camera} \&c}{797}{cameraModel}{}
\functionlistentry{int}{CalibrateWithPattern}{vector$<$\hyperlink{Matrix}{Matrix}$>$ \&imagepoints, vector$<$\hyperlink{Matrix}{Matrix}$>$ \&worldpoints, vector$<$\hyperlink{Camera}{Camera}$>$ \&cv}{798}{cameraModel}{}
\functionlistentry{}{Camera::Camera}{int dtyp=1}{770}{cameraModel}{}
\functionlistentry{}{Camera::Camera}{const \hyperlink{Vector}{Vector} \&v,int dtyp=1}{771}{cameraModel}{}
\functionlistentry{}{Camera::Camera}{const \hyperlink{Camera}{Camera} \&c}{772}{cameraModel}{}
\functionlistentry{const Distortion}{Camera::Dist}{}{779}{cameraModel}{}
\functionlistentry{int}{Camera::DistType}{}{780}{cameraModel}{}
\functionlistentry{void}{Camera::Get}{double \&fp,double \&ap,double \&sp,double \&u0p,double \&v0p}{777}{cameraModel}{}
\functionlistentry{void}{Camera::GetExt}{double \&dxp,double \&dyp,double \&dzp, double \&ap,double \&bp,double \&cp}{778}{cameraModel}{}
\functionlistentry{\hyperlink{Vector}{Vector}}{Camera::MakeVector}{int what=\hyperlink{Camera}{Camera}::all}{782}{cameraModel}{}
\functionlistentry{void}{Camera::Set}{double fp,double ap,double sp, double u0p,double v0p,const Distortion \&d}{774}{cameraModel}{}
\functionlistentry{void}{Camera::Set}{double fp,double ap,double sp,double u0p,double v0p}{775}{cameraModel}{}
\functionlistentry{void}{Camera::Set}{const \hyperlink{Vector}{Vector} \&v,int what=\hyperlink{Camera}{Camera}::all}{783}{cameraModel}{}
\functionlistentry{void}{Camera::SetDist}{const Distortion \&d}{781}{cameraModel}{}
\functionlistentry{void}{Camera::SetExt}{double dxp,double dyp,double dzp,double ap,double bp,double cp}{776}{cameraModel}{}
\functionlistentry{string}{Camera::toString}{const string \&del}{791}{cameraModel}{}
\functionlistentry{\hyperlink{Vector}{Vector}}{Camera::Transform}{const \hyperlink{Vector}{Vector} \&v}{784}{cameraModel}{}
\functionlistentry{\hyperlink{Point}{Point}}{Camera::Transform}{const \hyperlink{Vector3d}{Vector3d} \&v}{785}{cameraModel}{}
\functionlistentry{\hyperlink{Point}{Point}}{Camera::Transform}{const Point3d \&v}{786}{cameraModel}{}
\functionlistentry{void}{Camera::Transform}{double x,double y,double z,double \&u,double \&v}{787}{cameraModel}{}
\functionlistentry{int}{ComputeHomography}{\hyperlink{Matrix}{Matrix} \&imagepoints, \hyperlink{Matrix}{Matrix} \&worldpoints, \hyperlink{Trafo}{Trafo} \&H}{796}{cameraModel}{}
\functionlistentry{\hyperlink{Image}{Image}}{DrawPattern}{int dimx, int dimy}{801}{cameraModel}{}
\functionlistentry{\hyperlink{Camera}{Camera} \&}{operator=}{const \hyperlink{Camera}{Camera} \&c}{773}{cameraModel}{}
\functionlistentry{\hyperlink{Line3d}{Line3d}}{Ray}{const \hyperlink{Point}{Point} \&bp}{788}{cameraModel}{}
\functionlistentry{\hyperlink{Line3d}{Line3d}}{Ray}{double u,double v}{789}{cameraModel}{}
\functionlistentry{\hyperlink{Line3d}{Line3d}}{Ray}{const \hyperlink{Vector}{Vector} \&bp}{790}{cameraModel}{}

\subtitle{\hyperlink{SECTION:moments}{Momente und Standardlagen}}\\
\functionlistentry{\hyperlink{Trafo}{Trafo}}{AffineFit}{const \hyperlink{Moments}{Moments} \&m1,const \hyperlink{Moments}{Moments} \&m2}{839}{moments}{}
\functionlistentry{int}{FitCircle}{const \hyperlink{Moments}{Moments} \&m,double \&x0,double \&y0,double \&radius}{854}{moments}{}
\functionlistentry{\hyperlink{Circle}{Circle}}{FitCircle}{const \hyperlink{Moments}{Moments} \&m}{855}{moments}{}
\functionlistentry{\hyperlink{Ellipse}{Ellipse}}{FitEllipse}{const \hyperlink{Moments}{Moments} \&m}{856}{moments}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{FitEquilateralTriangle}{const \hyperlink{Moments}{Moments} \&m}{841}{moments}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{FitEquilateralTriangle}{const \hyperlink{Moments}{Moments} \&m,double \&guetemass}{842}{moments}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{FitIsoscelesTriangle}{const \hyperlink{Moments}{Moments} \&m}{843}{moments}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{FitIsoscelesTriangle}{const \hyperlink{Moments}{Moments} \&m,double \&guetemass}{844}{moments}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{FitParallelogram}{const \hyperlink{Moments}{Moments} \&m}{849}{moments}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{FitParallelogram}{const \hyperlink{Moments}{Moments} \&m,double \& guetemass}{850}{moments}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{FitPolygon}{const \hyperlink{Moments}{Moments} \&m,const \hyperlink{Matrix}{Matrix} \&pl}{852}{moments}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{FitPolygon}{const \hyperlink{Moments}{Moments} \&m,const \hyperlink{Matrix}{Matrix} \&pl,double \&guetemass}{853}{moments}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{FitQuadrangle}{const \hyperlink{Moments}{Moments} \&m}{851}{moments}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{FitRectangle}{const \hyperlink{Moments}{Moments} \&m}{847}{moments}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{FitRectangle}{const \hyperlink{Moments}{Moments} \&m,double \&guetemass}{848}{moments}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{FitSquare}{const \hyperlink{Moments}{Moments} \&m}{845}{moments}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{FitSquare}{const \hyperlink{Moments}{Moments} \&m,double \& guetemass}{846}{moments}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{FitTriangle}{const \hyperlink{Moments}{Moments} \&m}{840}{moments}{}
\functionlistentry{\hyperlink{Vector}{Vector}}{Moments::AffineAlgebraicInvariants}{}{821}{moments}{}
\functionlistentry{\hyperlink{Vector}{Vector}}{Moments::AffineHuInvariants}{}{823}{moments}{}
\functionlistentry{\hyperlink{Moments}{Moments}}{Moments::AffineTransform}{const \hyperlink{Trafo}{Trafo} \&tr}{820}{moments}{}
\functionlistentry{\hyperlink{Moments}{Moments}}{Moments::CentralMoments}{}{813}{moments}{}
\functionlistentry{void}{Moments::getCentroid}{double \&xc,double \&yc}{812}{moments}{}
\functionlistentry{\hyperlink{Vector}{Vector}}{Moments::HuInvariants}{}{822}{moments}{}
\functionlistentry{double *}{Moments::Mom}{}{810}{moments}{}
\functionlistentry{}{Moments::Moments}{}{803}{moments}{}
\functionlistentry{}{Moments::Moments}{double m[15]}{804}{moments}{}
\functionlistentry{}{Moments::Moments}{const \hyperlink{Region}{Region} \&r}{805}{moments}{}
\functionlistentry{}{Moments::Moments}{const \hyperlink{Contur}{Contur} \&c}{806}{moments}{}
\functionlistentry{}{Moments::Moments}{const \hyperlink{Matrix}{Matrix} \&p}{807}{moments}{}
\functionlistentry{}{Moments::Moments}{PointList p}{808}{moments}{}
\functionlistentry{}{Moments::Moments}{PointList p,int a1,int a2}{809}{moments}{}
\functionlistentry{\hyperlink{Moments}{Moments}}{Moments::Normalize}{\hyperlink{Trafo}{Trafo} \&tr,nmode mode=\hyperlink{Moments}{Moments}::standard}{837}{moments}{}
\functionlistentry{\hyperlink{Moments}{Moments}}{Moments::Normalize}{nmode mode=\hyperlink{Moments}{Moments}::standard}{838}{moments}{}
\functionlistentry{\hyperlink{Moments}{Moments}}{Moments::NormalizeRotation}{}{834}{moments}{}
\functionlistentry{\hyperlink{Moments}{Moments}}{Moments::NormalizeRotation}{double \&phi}{835}{moments}{}
\functionlistentry{\hyperlink{Moments}{Moments}}{Moments::NormalizeRotation}{double \&c,double \&s}{836}{moments}{}
\functionlistentry{\hyperlink{Moments}{Moments}}{Moments::NormalizeScaling}{scalemode mode=anisotropic}{831}{moments}{}
\functionlistentry{\hyperlink{Moments}{Moments}}{Moments::NormalizeScaling}{double \&alpha}{832}{moments}{}
\functionlistentry{\hyperlink{Moments}{Moments}}{Moments::NormalizeScaling}{double \&alpha,double \&beta}{833}{moments}{}
\functionlistentry{\hyperlink{Moments}{Moments}}{Moments::NormalizeSign}{}{824}{moments}{}
\functionlistentry{\hyperlink{Moments}{Moments}}{Moments::NormalizeTranslation}{}{825}{moments}{}
\functionlistentry{\hyperlink{Moments}{Moments}}{Moments::NormalizeTranslation}{double \&x,double \&y}{826}{moments}{}
\functionlistentry{\hyperlink{Moments}{Moments}}{Moments::NormalizeXShearing}{}{827}{moments}{}
\functionlistentry{\hyperlink{Moments}{Moments}}{Moments::NormalizeXShearing}{double \&beta}{828}{moments}{}
\functionlistentry{\hyperlink{Moments}{Moments}}{Moments::NormalizeYShearing}{}{829}{moments}{}
\functionlistentry{\hyperlink{Moments}{Moments}}{Moments::NormalizeYShearing}{double \&beta}{830}{moments}{}
\functionlistentry{\hyperlink{Moments}{Moments}}{Moments::Rotate}{double phi}{815}{moments}{}
\functionlistentry{\hyperlink{Moments}{Moments}}{Moments::Scale}{double a}{818}{moments}{}
\functionlistentry{\hyperlink{Moments}{Moments}}{Moments::Scale}{double a,double b}{819}{moments}{}
\functionlistentry{\hyperlink{Moments}{Moments}}{Moments::Translate}{double dx,double dy}{814}{moments}{}
\functionlistentry{\hyperlink{Moments}{Moments}}{Moments::XShear}{double s}{816}{moments}{}
\functionlistentry{\hyperlink{Moments}{Moments}}{Moments::YShear}{double s}{817}{moments}{}
\functionlistentry{double \&}{operator ()}{int xi,int yi}{811}{moments}{}
\functionlistentry{double}{Orientation}{const \hyperlink{Moments}{Moments} \&m}{857}{moments}{}

\subtitle{\hyperlink{SECTION:statistics}{Statistik}}\\
\functionlistentry{}{accu1::accu1}{}{917}{statistics}{}
\functionlistentry{}{accu1::accu1}{int n,double min=0.0,double max=1.0,bool mod=false}{919}{statistics}{}
\functionlistentry{void}{accu1::Add}{double val}{923}{statistics}{}
\functionlistentry{void}{accu1::getMax}{double \&val}{927}{statistics}{}
\functionlistentry{void}{accu1::getMax}{double \&val,double \&ct}{928}{statistics}{}
\functionlistentry{void}{accu1::setDim}{int n,double min=0.0,double max=1.0,bool mod=false}{921}{statistics}{}
\functionlistentry{}{accu2::accu2}{}{918}{statistics}{}
\functionlistentry{}{accu2::accu2}{int n1,double min1,double max1,bool mod1, int n1,double min2, double max2,bool mod2,int smear=1}{920}{statistics}{}
\functionlistentry{void}{accu2::Add}{double val1,double val2}{924}{statistics}{}
\functionlistentry{void}{accu2::Add}{const \hyperlink{Vector}{Vector} \&v}{925}{statistics}{}
\functionlistentry{void}{accu2::Add}{\hyperlink{Point}{Point} v}{926}{statistics}{}
\functionlistentry{void}{accu2::getMax}{double \&val1,double \&val2}{929}{statistics}{}
\functionlistentry{void}{accu2::getMax}{double \&val1,double \&val2,double \&ct}{930}{statistics}{}
\functionlistentry{\hyperlink{Point}{Point}}{accu2::getMax}{}{931}{statistics}{}
\functionlistentry{\hyperlink{Point}{Point}}{accu2::getMax}{double \&ct}{932}{statistics}{}
\functionlistentry{void}{accu2::setDim}{int dim,int n,double min=0.0,double max=1.0,bool mod=false}{922}{statistics}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{Correlation}{const \hyperlink{Statistics}{Statistics} \&st}{871}{statistics}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{Covariance}{const \hyperlink{Statistics}{Statistics} \&st}{870}{statistics}{}
\functionlistentry{\hyperlink{LineSeg}{LineSeg}}{DetectLine}{const vector<\hyperlink{Point}{Point}> \&pointlist}{933}{statistics}{}
\functionlistentry{\hyperlink{LineSeg}{LineSeg}}{DetectLine}{const vector<\hyperlink{Point}{Point}> \&pointlist,int pairs}{934}{statistics}{}
\functionlistentry{\hyperlink{LineSeg}{LineSeg}}{DetectLine}{const \hyperlink{Matrix}{Matrix} \&pointlist}{935}{statistics}{}
\functionlistentry{\hyperlink{LineSeg}{LineSeg}}{DetectLine}{const \hyperlink{Matrix}{Matrix} \&pointlist,int pairs}{936}{statistics}{}
\functionlistentry{double}{Distance}{const \hyperlink{Histogram}{Histogram} \&h1,const \hyperlink{Histogram}{Histogram} \&h2}{900}{statistics}{}
\functionlistentry{double}{GaussRandom}{double sigma}{862}{statistics}{}
\functionlistentry{int}{Hist::Add}{double val}{908}{statistics}{}
\functionlistentry{int}{Hist::Count}{int index}{909}{statistics}{}
\functionlistentry{}{Hist::Hist}{}{903}{statistics}{}
\functionlistentry{}{Hist::Hist}{const \hyperlink{Hist}{Hist} \&h}{904}{statistics}{}
\functionlistentry{}{Hist::Hist}{int knumber,double diff=1.0,double lower=-0.5}{905}{statistics}{}
\functionlistentry{int}{Hist::Limits}{double \&min,double \&max}{911}{statistics}{}
\functionlistentry{int}{Hist::Limits}{double \&min,double \&max,double quant}{912}{statistics}{}
\functionlistentry{double}{Hist::Rel}{int index}{910}{statistics}{}
\functionlistentry{int}{Hist::Reset}{}{906}{statistics}{}
\functionlistentry{int}{Hist::Reset}{int knumber,double diff=1.0,double lower=-0.5}{907}{statistics}{}
\functionlistentry{int}{Hist::Statistic}{int \&nbr,double \&mean,double \&dispers}{914}{statistics}{}
\functionlistentry{int}{Hist::Vis}{int val,\hyperlink{Image}{Image} img}{916}{statistics}{}
\functionlistentry{\hyperlink{Hist}{Hist}}{HistImg}{\hyperlink{Image}{Image} img,int diff=1,int clw=1}{913}{statistics}{}
\functionlistentry{int}{Histogram::addValue}{int val,int count = 1}{887}{statistics}{}
\functionlistentry{int}{Histogram::getCount}{int nr}{888}{statistics}{}
\functionlistentry{vector\textless {}int\textgreater }{Histogram::getCount}{}{890}{statistics}{}
\functionlistentry{void}{Histogram::getCount}{vector\textless {}int\textgreater  \&v}{891}{statistics}{}
\functionlistentry{int}{Histogram::getLimits}{int \&min, int \&max}{895}{statistics}{}
\functionlistentry{int}{Histogram::getLimits}{int \&min, int \&max, double quantil}{896}{statistics}{}
\functionlistentry{double}{Histogram::getRelative}{int nr}{892}{statistics}{}
\functionlistentry{vector\textless {}double\textgreater }{Histogram::getRelative}{}{893}{statistics}{}
\functionlistentry{void}{Histogram::getRelative}{vector\textless {}double\textgreater  \&v}{894}{statistics}{}
\functionlistentry{}{Histogram::Histogram}{}{880}{statistics}{}
\functionlistentry{}{Histogram::Histogram}{int knumber}{881}{statistics}{}
\functionlistentry{}{Histogram::Histogram}{const \hyperlink{Image}{Image} \&img,int diff=1}{882}{statistics}{}
\functionlistentry{int}{Histogram::isValid}{}{885}{statistics}{}
\functionlistentry{int}{Histogram::nClasses}{}{886}{statistics}{}
\functionlistentry{int}{Histogram::operator []}{int nr}{889}{statistics}{}
\functionlistentry{int}{Histogram::reset}{}{883}{statistics}{}
\functionlistentry{int}{Histogram::reset}{int knumber}{884}{statistics}{}
\functionlistentry{int}{Histogram::Statistic}{int \&sum}{897}{statistics}{}
\functionlistentry{int}{Histogram::Statistic}{int \&sum,double \&xm,double \&xs}{898}{statistics}{}
\functionlistentry{int}{Histogram::Statistic}{int \&sum,double \&xm,double \&xs,double \&skew}{899}{statistics}{}
\functionlistentry{int}{Histogram::Vis}{int val,const \hyperlink{Image}{Image} \&img}{901}{statistics}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{KLT}{const \hyperlink{Matrix}{Matrix} \&m}{876}{statistics}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{KLT}{const \hyperlink{Matrix}{Matrix} \&m,\hyperlink{Vector}{Vector} \&r}{877}{statistics}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{KLT}{const \hyperlink{Statistics}{Statistics} \&st}{878}{statistics}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{KLT}{const \hyperlink{Statistics}{Statistics} \&st,\hyperlink{Vector}{Vector} \&r}{879}{statistics}{}
\functionlistentry{\hyperlink{Vector}{Vector}}{Mean}{const \hyperlink{Statistics}{Statistics} \&st}{868}{statistics}{}
\functionlistentry{ostream \&}{operator <<}{ostream \&s,const \hyperlink{Statistics}{Statistics} \&t}{874}{statistics}{}
\functionlistentry{istream \&}{operator >>}{istream \&s,\hyperlink{Statistics}{Statistics} \&st}{875}{statistics}{}
\functionlistentry{int}{PrintHist}{const \hyperlink{Hist}{Hist} \& h}{915}{statistics}{}
\functionlistentry{int}{PrintHistogram}{const \hyperlink{Histogram}{Histogram} \& h}{902}{statistics}{}
\functionlistentry{int}{Put}{\hyperlink{Statistics}{Statistics} \&st,const \hyperlink{Vector}{Vector} \&val,double weight=1.0}{867}{statistics}{}
\functionlistentry{int}{Random}{int val}{860}{statistics}{}
\functionlistentry{double}{RandomD}{}{861}{statistics}{}
\functionlistentry{void}{Randomize}{}{859}{statistics}{}
\functionlistentry{int}{Read}{\hyperlink{Statistics}{Statistics} \&st,const string \&fn}{873}{statistics}{}
\functionlistentry{int}{Statistics::Init}{}{865}{statistics}{}
\functionlistentry{int}{Statistics::Init}{int dim}{866}{statistics}{}
\functionlistentry{}{Statistics::Statistics}{}{863}{statistics}{}
\functionlistentry{}{Statistics::Statistics}{int dim}{864}{statistics}{}
\functionlistentry{double}{Weight}{const \hyperlink{Statistics}{Statistics} \&st}{869}{statistics}{}
\functionlistentry{int}{Write}{const \hyperlink{Statistics}{Statistics} \&st,const string \&fn}{872}{statistics}{}

\subtitle{\hyperlink{SECTION:classification}{Klassifikation}}\\
\functionlistentry{}{Classifier::Classifier}{}{942}{classification}{}
\functionlistentry{}{Classifier::Classifier}{int classes,int dimension}{943}{classification}{}
\functionlistentry{}{Classifier::Classifier}{const \hyperlink{Classifier}{Classifier} \&c}{944}{classification}{}
\functionlistentry{int}{Classifier::Classify}{const vector\textless {}double\textgreater  \&feat}{958}{classification}{}
\functionlistentry{int}{Classifier::Classify}{const \hyperlink{Vector}{Vector} \&feat}{959}{classification}{}
\functionlistentry{int}{Classifier::Classify}{\hyperlink{Matrix}{Matrix} \&m}{960}{classification}{}
\functionlistentry{int}{Classifier::Classify}{const \hyperlink{Matrix}{Matrix} \&m,IVector \&cl}{961}{classification}{}
\functionlistentry{int}{Classifier::Finish}{}{953}{classification}{}
\functionlistentry{int}{Classifier::Init}{}{945}{classification}{}
\functionlistentry{int}{Classifier::Init}{int classes,int dimension}{946}{classification}{}
\functionlistentry{int}{Classifier::Read}{const string \&fn}{963}{classification}{}
\functionlistentry{double}{Classifier::Test}{const vector\textless {}\hyperlink{ClassSample}{ClassSample}\textgreater  \&samples}{954}{classification}{}
\functionlistentry{double}{Classifier::Test}{const \hyperlink{Matrix}{Matrix} \&m}{955}{classification}{}
\functionlistentry{double}{Classifier::Test}{const \hyperlink{Matrix}{Matrix} \&features,const IVector \&classnr}{956}{classification}{}
\functionlistentry{double}{Classifier::Test}{const \hyperlink{Matrix}{Matrix} \&m,\hyperlink{Matrix}{Matrix} \&f}{957}{classification}{}
\functionlistentry{int}{Classifier::Train}{const \hyperlink{ClassSample}{ClassSample} \&sample}{947}{classification}{}
\functionlistentry{int}{Classifier::Train}{int cl,const vector\textless {}double\textgreater  \&feat}{948}{classification}{}
\functionlistentry{int}{Classifier::Train}{int cl,const \hyperlink{Vector}{Vector} \&feat}{949}{classification}{}
\functionlistentry{int}{Classifier::Train}{const vector\textless {}ClassSamples\textgreater  \&samples}{950}{classification}{}
\functionlistentry{int}{Classifier::Train}{const \hyperlink{Matrix}{Matrix} \&m}{951}{classification}{}
\functionlistentry{int}{Classifier::Train}{const \hyperlink{Matrix}{Matrix} \&features,const IVector \&classnr}{952}{classification}{}
\functionlistentry{int}{Classifier::Write}{const string \&fn}{962}{classification}{}
\functionlistentry{}{ClassifierB2::ClassifierB2}{}{978}{classification}{}
\functionlistentry{}{ClassifierB2::ClassifierB2}{int classes,int dimension, double p0,double p1,double c01,double c10}{979}{classification}{}
\functionlistentry{}{ClassifierB2::ClassifierB2}{const \hyperlink{ClassifierB2}{ClassifierB2} \&c}{980}{classification}{}
\functionlistentry{int}{ClassifierB2::Init}{int classes,int dimension,double p0,double p0,double c01, double c10}{981}{classification}{}
\functionlistentry{}{ClassifierBayes::ClassifierBayes}{}{982}{classification}{}
\functionlistentry{}{ClassifierBayes::ClassifierBayes}{int classes,int dimension, bool rejection=false, int apm=APM\_EQUAL}{983}{classification}{}
\functionlistentry{}{ClassifierBayes::ClassifierBayes}{int classes, const vector\textless {}double\textgreater  \& app, bool rejection}{984}{classification}{}
\functionlistentry{}{ClassifierBayes::ClassifierBayes}{const \hyperlink{ClassifierBayes}{ClassifierBayes} \&c}{985}{classification}{}
\functionlistentry{int}{ClassifierBayes::Init}{int classes,int dimension}{986}{classification}{}
\functionlistentry{int}{ClassifierBayes::SoftClassify}{const \hyperlink{Vector}{Vector} \&feat, \hyperlink{Vector}{Vector} \&softclasses, int measure=1}{987}{classification}{}
\functionlistentry{}{ClassifierKNN::ClassifierKNN}{}{975}{classification}{}
\functionlistentry{}{ClassifierKNN::ClassifierKNN}{int classes,int dimension, int neighbours=3, bool norm=false, int voteMode=1}{976}{classification}{}
\functionlistentry{void}{ClassifierKNN::Init}{int classes,int dimension,bool norm = false,int voteMode=1}{977}{classification}{}
\functionlistentry{}{ClassifierMD::ClassifierMD}{}{968}{classification}{}
\functionlistentry{}{ClassifierMD::ClassifierMD}{int classes,int dimension}{969}{classification}{}
\functionlistentry{}{ClassifierMD::ClassifierMD}{const \hyperlink{ClassifierMD}{ClassifierMD} \&c}{970}{classification}{}
\functionlistentry{}{ClassifierNN::ClassifierNN}{}{971}{classification}{}
\functionlistentry{}{ClassifierNN::ClassifierNN}{int classes,int dimension,bool norm=false}{972}{classification}{}
\functionlistentry{}{ClassifierNN::ClassifierNN}{const \hyperlink{ClassifierNN}{ClassifierNN} \&c}{973}{classification}{}
\functionlistentry{void}{ClassifierNN::Init}{int classes,int dimension,bool norm = false}{974}{classification}{}
\functionlistentry{}{ClassifierNormal::ClassifierNormal}{}{964}{classification}{}
\functionlistentry{}{ClassifierNormal::ClassifierNormal}{int classes,int dimension}{965}{classification}{}
\functionlistentry{void}{ClassifierNormal::doNormalization}{int mode = normalizeCenter $|$ normalizeScaling $|$ normalizeIsotropic}{966}{classification}{}
\functionlistentry{void}{ClassifierNormal::normalize}{vector\textless {}double\textgreater  \&feat}{967}{classification}{}
\functionlistentry{}{ClassSample::ClassSample}{}{938}{classification}{}
\functionlistentry{}{ClassSample::ClassSample}{int c, const vector\textless {}double\textgreater  \& f}{939}{classification}{}
\functionlistentry{double \&}{ClassSample::operator[]}{int i}{940}{classification}{}
\functionlistentry{int}{ClassSample::size}{}{941}{classification}{}

\subtitle{\hyperlink{SECTION:functions}{Funktionen}}\\
\functionlistentry{}{Constant2d::Constant2d}{void}{1032}{functions}{}
\functionlistentry{}{Constant2d::Constant2d}{double a}{1033}{functions}{}
\functionlistentry{}{Constant2d::Constant2d}{const vector\textless {}double\textgreater  \&v}{1034}{functions}{}
\functionlistentry{}{Constant2d::Constant2d}{const \hyperlink{Constant2d}{Constant2d} \&f}{1035}{functions}{}
\functionlistentry{void}{Constant2d::getCoefficient}{double \&a}{1037}{functions}{}
\functionlistentry{void}{Constant2d::setCoefficient}{double a}{1036}{functions}{}
\functionlistentry{}{Constant::Constant}{void}{997}{functions}{}
\functionlistentry{}{Constant::Constant}{double a}{998}{functions}{}
\functionlistentry{}{Constant::Constant}{const vector\textless {}double\textgreater  \&v}{999}{functions}{}
\functionlistentry{}{Constant::Constant}{const \hyperlink{Constant}{Constant} \&f}{1000}{functions}{}
\functionlistentry{int}{Constant::getCoefficient}{double \&pa}{1002}{functions}{}
\functionlistentry{int}{Constant::setCoefficient}{double pa}{1001}{functions}{}
\functionlistentry{double}{Func2d::operator()}{double x, double y}{1030}{functions}{}
\functionlistentry{double}{Func2d::operator()}{\hyperlink{Point}{Point} p}{1031}{functions}{}
\functionlistentry{void}{Function2d::getCoefficient}{vector\textless {}double\textgreater  \&c}{1021}{functions}{}
\functionlistentry{double}{Function2d::operator()}{double x,doubel y}{1019}{functions}{}
\functionlistentry{double}{Function2d::operator()}{\hyperlink{Point}{Point} p}{1020}{functions}{}
\functionlistentry{int}{Function2d::setCoefficient}{const vector\textless {}double\textgreater  \&para,int idx=0}{1022}{functions}{}
\functionlistentry{}{Function2dDistortion::Function2dDistortion}{Function2d \&funcp, Distortion \&tr}{1059}{functions}{}
\functionlistentry{}{Function2dModifier::Function2dModifier}{Function2d \&funcp}{1054}{functions}{}
\functionlistentry{}{Function2dParameterShift::Function2dParameterShift}{Function2d \&funcp, double sx, double sy}{1055}{functions}{}
\functionlistentry{}{Function2dParameterTransform::Function2dParameterTransform}{Function2d \&funcp, const \hyperlink{Trafo}{Trafo} \&tr}{1056}{functions}{}
\functionlistentry{\hyperlink{Trafo}{Trafo} \&}{Function2dParameterTransform::Tr}{}{1057}{functions}{}
\functionlistentry{const \hyperlink{Trafo}{Trafo} \&}{Function2dParameterTransform::Tr}{}{1058}{functions}{}
\functionlistentry{}{Function2dValueTransform::Function2dValueTransform}{Function2d \&funcp, double a1, double a0}{1060}{functions}{}
\functionlistentry{int}{Function2dWithFitting::Fit}{const \hyperlink{Matrix}{Matrix} \&m}{1027}{functions}{}
\functionlistentry{int}{Function2dWithFitting::Fit}{\hyperlink{Image}{Image} img}{1028}{functions}{}
\functionlistentry{int}{Function2dWithFitting::Fit}{ImageD img}{1029}{functions}{}
\functionlistentry{int}{Function2dWithFitting::FitFinish}{}{1026}{functions}{}
\functionlistentry{int}{Function2dWithFitting::FitInit}{}{1023}{functions}{}
\functionlistentry{int}{Function2dWithFitting::FitVal}{double x, double y, double g, double w=1.0}{1024}{functions}{}
\functionlistentry{int}{Function2dWithFitting::FitVal}{const \hyperlink{Point}{Point} \&p, double g, double w=1.0}{1025}{functions}{}
\functionlistentry{void}{Function::getCoefficient}{vector\textless {}double\textgreater  \&c}{990}{functions}{}
\functionlistentry{double}{Function::operator()}{double x}{989}{functions}{}
\functionlistentry{int}{Function::setCoefficient}{const vector\textless {}double\textgreater  \&para,int idx=0}{991}{functions}{}
\functionlistentry{int}{FunctionWithFitting::Fit}{const \hyperlink{Matrix}{Matrix} \&m}{995}{functions}{}
\functionlistentry{int}{FunctionWithFitting::FitFinish}{}{994}{functions}{}
\functionlistentry{void}{FunctionWithFitting::FitInit}{void}{992}{functions}{}
\functionlistentry{void}{FunctionWithFitting::FitValue}{double x, double g, double w=1.0}{993}{functions}{}
\functionlistentry{double}{FunctionWithFitting::operator()}{double x}{996}{functions}{}
\functionlistentry{}{ImageDFunction::ImageDFunction}{const ImageD \&imgp, int mode = INTERPOL}{1062}{functions}{}
\functionlistentry{}{ImageFunction::ImageFunction}{const \hyperlink{Image}{Image} \&imgp, int mode = INTERPOL}{1061}{functions}{}
\functionlistentry{int}{Polynom1o::getCoefficient}{double \&a0, double \&a1}{1008}{functions}{}
\functionlistentry{}{Polynom1o::Polynom1o}{void}{1003}{functions}{}
\functionlistentry{}{Polynom1o::Polynom1o}{double a0, double a1}{1004}{functions}{}
\functionlistentry{}{Polynom1o::Polynom1o}{const vector\textless {}double\textgreater  \&v}{1005}{functions}{}
\functionlistentry{}{Polynom1o::Polynom1o}{const \hyperlink{Polynom1o}{Polynom1o} \&f}{1006}{functions}{}
\functionlistentry{int}{Polynom1o::setCoefficient}{double a0, double a1}{1007}{functions}{}
\functionlistentry{void}{Polynom2d1o::getCoefficient}{double \&a00, double \&a10, double \&a01}{1043}{functions}{}
\functionlistentry{}{Polynom2d1o::Polynom2d1o}{void}{1038}{functions}{}
\functionlistentry{}{Polynom2d1o::Polynom2d1o}{double a00, double a10, double a01}{1039}{functions}{}
\functionlistentry{}{Polynom2d1o::Polynom2d1o}{const vector\textless {}double\textgreater  \&v}{1040}{functions}{}
\functionlistentry{}{Polynom2d1o::Polynom2d1o}{const \hyperlink{Polynom2d1o}{Polynom2d1o} \&f}{1041}{functions}{}
\functionlistentry{void}{Polynom2d1o::setCoefficient}{double a00, double a10, double a01}{1042}{functions}{}
\functionlistentry{void}{Polynom2d2o::getCoefficient}{double \&a00, double \&a10, double \&a01, double \&a20, double \&a11, double \&a02}{1049}{functions}{}
\functionlistentry{}{Polynom2d2o::Polynom2d2o}{void}{1044}{functions}{}
\functionlistentry{}{Polynom2d2o::Polynom2d2o}{double a00, double a10, double a01, double a20, double a11, double a02}{1045}{functions}{}
\functionlistentry{}{Polynom2d2o::Polynom2d2o}{const vector\textless {}double\textgreater  \&v}{1046}{functions}{}
\functionlistentry{}{Polynom2d2o::Polynom2d2o}{const \hyperlink{Polynom2d2o}{Polynom2d2o} \&f}{1047}{functions}{}
\functionlistentry{void}{Polynom2d2o::setCoefficient}{double a00, double a10, double a01, double a20, double a11, double a02}{1048}{functions}{}
\functionlistentry{}{Polynom2d::Polynom2d}{void}{1050}{functions}{}
\functionlistentry{}{Polynom2d::Polynom2d}{int ord}{1051}{functions}{}
\functionlistentry{}{Polynom2d::Polynom2d}{const vector\textless {}double\textgreater  \&v}{1052}{functions}{}
\functionlistentry{}{Polynom2d::Polynom2d}{const \hyperlink{Polynom2d}{Polynom2d} \&f}{1053}{functions}{}
\functionlistentry{int}{Polynom2o::getCoefficient}{double \&a0, double \&a1, double \&a2}{1014}{functions}{}
\functionlistentry{}{Polynom2o::Polynom2o}{void}{1009}{functions}{}
\functionlistentry{}{Polynom2o::Polynom2o}{double a0, double a1, double a2}{1010}{functions}{}
\functionlistentry{}{Polynom2o::Polynom2o}{const \hyperlink{Vector}{Vector} \&v}{1011}{functions}{}
\functionlistentry{}{Polynom2o::Polynom2o}{const \hyperlink{Polynom2o}{Polynom2o} \&f}{1012}{functions}{}
\functionlistentry{int}{Polynom2o::setCoefficient}{double a0, double a1, double a2}{1013}{functions}{}
\functionlistentry{}{Polynom::Polynom}{void}{1015}{functions}{}
\functionlistentry{}{Polynom::Polynom}{int ord}{1016}{functions}{}
\functionlistentry{}{Polynom::Polynom}{const vector\textless {}double\textgreater  \&v}{1017}{functions}{}
\functionlistentry{}{Polynom::Polynom}{const \hyperlink{Polynom}{Polynom} \&f}{1018}{functions}{}

\subtitle{\hyperlink{SECTION:processing}{Bildbearbeitung}}\\
\functionlistentry{int}{AddImg}{const \hyperlink{Image}{Image} \&img1,const \hyperlink{Image}{Image} \&img2, const \hyperlink{Image}{Image} \&dest,int mode=MD\_NORMALIZE}{1087}{processing}{}
\functionlistentry{int}{AddImgD}{ImageD img1,ImageD img2,ImageD dest}{1098}{processing}{}
\functionlistentry{int}{BinImg}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&dest,int thr=1,int val=-1}{1064}{processing}{}
\functionlistentry{int}{BinImg}{\hyperlink{Image}{Image} \&src,int thr=1}{1065}{processing}{}
\functionlistentry{int}{ClearImg}{const \hyperlink{Image}{Image} \&img}{1083}{processing}{}
\functionlistentry{int}{ClearImgD}{ImageD img}{1095}{processing}{}
\functionlistentry{int}{ColorImageToHsi}{const \hyperlink{ColorImage}{ColorImage} \&src, const \hyperlink{Image}{Image} \&hue, const \hyperlink{Image}{Image} \&saturation, const \hyperlink{Image}{Image} \&intensity}{1107}{processing}{}
\functionlistentry{int}{ColorImageToLab}{const \hyperlink{ColorImage}{ColorImage} \&src, const \hyperlink{Image}{Image} \&lImg, const \hyperlink{Image}{Image} \&aImg, const \hyperlink{Image}{Image} \&bImg}{1109}{processing}{}
\functionlistentry{int}{ColorImageToYuv}{const \hyperlink{ColorImage}{ColorImage} \&src, const \hyperlink{Image}{Image} \&y, const \hyperlink{Image}{Image} \&u, const \hyperlink{Image}{Image} \&v}{1111}{processing}{}
\functionlistentry{int}{CopyImg}{const \hyperlink{Image}{Image} \&src,const \hyperlink{Image}{Image} \&dest}{1086}{processing}{}
\functionlistentry{int}{correctShading}{const \hyperlink{Image}{Image} \&img1,const \hyperlink{Image}{Image} \&img2, int ord=2}{1081}{processing}{}
\functionlistentry{int}{correctShading}{const \hyperlink{Image}{Image} \&img1,const \hyperlink{Image}{Image} \&img2, Function2dWithFitting \&fn}{1082}{processing}{}
\functionlistentry{int}{FindMax}{const \hyperlink{Image}{Image} \&img, int \&x, int \&y}{1069}{processing}{}
\functionlistentry{int}{FindMax}{const \hyperlink{Image}{Image} \&img, IPoint \&p}{1070}{processing}{}
\functionlistentry{int}{FindMax}{const \hyperlink{Image}{Image} \&img}{1071}{processing}{}
\functionlistentry{int}{FindMin}{const \hyperlink{Image}{Image} \&img, int \&x, int \&y}{1066}{processing}{}
\functionlistentry{int}{FindMin}{const \hyperlink{Image}{Image} \&img, IPoint \&p}{1067}{processing}{}
\functionlistentry{int}{FindMin}{const \hyperlink{Image}{Image} \&img}{1068}{processing}{}
\functionlistentry{int}{GetGrayLimits}{const \hyperlink{Image}{Image} \&img,int \&min,int \&max, int mode=GV\_QUANTILE, bool cutMargExtr = false, double minq = 0.1, double maxq = 0.1}{1072}{processing}{}
\functionlistentry{int}{GetGrayLimits}{const \hyperlink{Hist}{Hist} \& h, int\& min, int\& max, int mode=GV\_QUANTILE, bool cutMargExtr = false, double minq = 0.1, double maxq = 0.1 }{1073}{processing}{}
\functionlistentry{int}{GrayNormalize}{const \hyperlink{Image}{Image} \&src,const \hyperlink{Image}{Image} \& dest, int mode=GV\_QUANTILE, bool cutMargExtr = false, double minq = 0.1, double maxq = 0.1}{1078}{processing}{}
\functionlistentry{int}{GrayNormalize}{const \hyperlink{Image}{Image} \&src, int mode=GV\_QUANTILE, bool cutMargExtr = false, double minq = 0.1, double maxq = 0.1}{1079}{processing}{}
\functionlistentry{int}{GrayTransform}{const \hyperlink{Image}{Image} \&src, const \hyperlink{Image}{Image} \&dest, double a1, double a0}{1074}{processing}{}
\functionlistentry{int}{GrayTransform}{const \hyperlink{Image}{Image} \&src, double a1, double a0}{1075}{processing}{}
\functionlistentry{int}{GrayTransformLimits}{const \hyperlink{Image}{Image} \&src, const \hyperlink{Image}{Image} \& dest, int min, int max}{1076}{processing}{}
\functionlistentry{int}{GrayTransformLimits}{const \hyperlink{Image}{Image} \&src, int min, int max}{1077}{processing}{}
\functionlistentry{int}{HistogramEqual}{const \hyperlink{Image}{Image} \&img1,const \hyperlink{Image}{Image} \&img2}{1080}{processing}{}
\functionlistentry{int}{HsiToColorImage}{const \hyperlink{Image}{Image} \&hue, const \hyperlink{Image}{Image} \&saturation, const \hyperlink{Image}{Image} \&intensity, const \hyperlink{ColorImage}{ColorImage} \&dst}{1108}{processing}{}
\functionlistentry{int}{InvertImg}{const \hyperlink{Image}{Image} \&img, const \hyperlink{Image}{Image} \&dest}{1092}{processing}{}
\functionlistentry{int}{InvertImg}{const \hyperlink{Image}{Image} \&img}{1093}{processing}{}
\functionlistentry{int}{LabToColorImage}{const \hyperlink{Image}{Image} \&lImg, const \hyperlink{Image}{Image} \&aImg, const \hyperlink{Image}{Image} \&bImg, const \hyperlink{ColorImage}{ColorImage} \&src}{1110}{processing}{}
\functionlistentry{int}{LogImgD}{ImageD src,ImageD dest}{1100}{processing}{}
\functionlistentry{int}{LogPolarC}{ImageD src,ImageD dest,double x,double y,double \&r,double \&phi,double r1=1,double r2=0,int sym=2}{1106}{processing}{}
\functionlistentry{int}{LogPolarImg}{const \hyperlink{Image}{Image} \&src, const \hyperlink{Image}{Image} \&dest,double r1=1,double r2=0,int sym=2}{1105}{processing}{}
\functionlistentry{int}{LogPolarImgD}{ImageD src,ImageD dest,double r1=1,double r2=0,int sym=2}{1104}{processing}{}
\functionlistentry{int}{MaxImg}{const \hyperlink{Image}{Image} \&img1,const \hyperlink{Image}{Image} \&img2,const \hyperlink{Image}{Image} \&dest,int mode=MD\_NORMALIZE}{1090}{processing}{}
\functionlistentry{int}{MinImg}{const \hyperlink{Image}{Image} \&img1,const \hyperlink{Image}{Image} \&img2,const \hyperlink{Image}{Image} \&dest,int mode=MD\_NORMALIZE}{1091}{processing}{}
\functionlistentry{int}{MoveImgD}{ImageD src,ImageD dest}{1097}{processing}{}
\functionlistentry{int}{MulImgD}{ImageD img1,ImageD img2,ImageD dest}{1099}{processing}{}
\functionlistentry{int}{PolarC}{ImageD src,ImageD dest,double x,double y,double \&r,double \&phi,double r1=1,double r2=0,int sm=2}{1103}{processing}{}
\functionlistentry{int}{PolarImg}{const \hyperlink{Image}{Image} \&src,const \hyperlink{Image}{Image} \&dest,double r1=1,double r2=0,int sym=2}{1102}{processing}{}
\functionlistentry{int}{PolarImgD}{ImageD src,ImageD dest,double r1=1,double r2=0,int sym=2}{1101}{processing}{}
\functionlistentry{int}{RenormImg}{const \hyperlink{Image}{Image} \&img,const \hyperlink{Image}{Image} \&dest}{1094}{processing}{}
\functionlistentry{int}{setImg}{const \hyperlink{Image}{Image} \&img,int val}{1084}{processing}{}
\functionlistentry{int}{setImg}{const \hyperlink{Image}{Image} \&img,const Function2d \& fn}{1085}{processing}{}
\functionlistentry{int}{SetImgD}{ImageD img,double val}{1096}{processing}{}
\functionlistentry{int}{SubImg}{const \hyperlink{Image}{Image} \&img1,const \hyperlink{Image}{Image} \&img2,int smode,const \hyperlink{Image}{Image} \&dest,int mode=MD\_NORMALIZE}{1088}{processing}{}
\functionlistentry{int}{SubImg}{const \hyperlink{Image}{Image} \&img1,const \hyperlink{Image}{Image} \&img2,const \hyperlink{Image}{Image} \&dest,int smode=SMD\_ABSOLUTE,int mode=MD\_NORMALIZE}{1089}{processing}{}
\functionlistentry{int}{YuvToColorImage}{const \hyperlink{Image}{Image} \&y, const \hyperlink{Image}{Image} \&u, const \hyperlink{Image}{Image} \&v, const \hyperlink{ColorImage}{ColorImage} \&dst}{1112}{processing}{}

\subtitle{\hyperlink{SECTION:matrixAlgebra}{Matrix-Algebra}}\\
\functionlistentry{\hyperlink{Matrix}{Matrix}}{CholeskyDecomposition}{const \hyperlink{Matrix}{Matrix} \&m}{1116}{matrixAlgebra}{}
\functionlistentry{double}{CholeskyDeterminant}{const \hyperlink{Matrix}{Matrix} \&m}{1119}{matrixAlgebra}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{CholeskyInverse}{const \hyperlink{Matrix}{Matrix} \&m}{1115}{matrixAlgebra}{}
\functionlistentry{double}{Determinant}{const \hyperlink{Matrix}{Matrix} \&m}{1118}{matrixAlgebra}{}
\functionlistentry{int}{Eigenvalue}{const \hyperlink{Matrix}{Matrix} \&a,\hyperlink{Vector}{Vector} \&eval,\hyperlink{Matrix}{Matrix} \&evect}{1128}{matrixAlgebra}{}
\functionlistentry{int}{Eigenvalue}{const \hyperlink{Matrix}{Matrix} \&a,\hyperlink{Matrix}{Matrix} \&eval,\hyperlink{Matrix}{Matrix} \&evect}{1129}{matrixAlgebra}{}
\functionlistentry{int}{Eigenvalue}{double a,double b,double c, double \&lambda1,double \&lambda2,\hyperlink{Point}{Point} \&eigen1,\hyperlink{Point}{Point} \&eigen2}{1130}{matrixAlgebra}{}
\functionlistentry{int}{EquationSys}{MatrixStruct A,double *b,double *x}{1125}{matrixAlgebra}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{Inverse}{const \hyperlink{Matrix}{Matrix} \&m}{1114}{matrixAlgebra}{}
\functionlistentry{bool}{IsPositivDefinit}{const \hyperlink{Matrix}{Matrix} \&m}{1117}{matrixAlgebra}{}
\functionlistentry{int}{LinearOptimization}{int rows,int columns,double **matrix,double *rside,double *costfunction,double *solution,double \&costs}{1136}{matrixAlgebra}{}
\functionlistentry{int}{LMDif}{\hyperlink{Vector}{Vector} \&variable,int optnumber,LMFunc *func,int funcdim,int \&inumber,int maxiter=MAX\_INT}{1137}{matrixAlgebra}{}
\functionlistentry{int}{LMDif}{\hyperlink{Vector}{Vector} \&variable,int optnumber,LMFunc *func,int funcdim}{1138}{matrixAlgebra}{}
\functionlistentry{int}{LMDif}{\hyperlink{Vector}{Vector} \&variable,IVector optvar, LMFunc *func,int funcdim,int \&inumber,int maxiter=MAX\_INT}{1139}{matrixAlgebra}{}
\functionlistentry{int}{LMDif}{\hyperlink{Vector}{Vector} \&variable,IVector optvar,LMFunc *func,int funcdim}{1140}{matrixAlgebra}{}
\functionlistentry{int}{LMDif}{const vector\textless {}double*\textgreater  \&ov,const LMFunctor \&fn, int maxiter=MAX\_INT}{1141}{matrixAlgebra}{}
\functionlistentry{int}{LUDecomposition}{const \hyperlink{Matrix}{Matrix} \&a,\hyperlink{Matrix}{Matrix} \&L,\hyperlink{Matrix}{Matrix} \&U}{1121}{matrixAlgebra}{}
\functionlistentry{int}{LUDecompositionPacked}{const \hyperlink{Matrix}{Matrix} \&a,\hyperlink{Matrix}{Matrix} \&LU,IVector \&indx,bool pivot=true}{1122}{matrixAlgebra}{}
\functionlistentry{\hyperlink{Vector}{Vector}}{LUSolve}{const \hyperlink{Matrix}{Matrix} \&LU,const IVector \&indx,const \hyperlink{Vector}{Vector} \&i}{1123}{matrixAlgebra}{}
\functionlistentry{MatrixStruct}{Mateigen}{MatrixStruct A,double *eval,MatrixStruct evect}{1134}{matrixAlgebra}{}
\functionlistentry{int}{NonLinEquSys}{FuncD *func,int dim,int *step,double *mse,double *x}{1127}{matrixAlgebra}{}
\functionlistentry{int}{NormalEquationSys}{MatrixStruct A,double *b,double *x}{1126}{matrixAlgebra}{}
\functionlistentry{int}{QRDecomposition}{const \hyperlink{Matrix}{Matrix} \&A,\hyperlink{Matrix}{Matrix} \&Q,\hyperlink{Matrix}{Matrix} \&R}{1133}{matrixAlgebra}{}
\functionlistentry{int}{SingularValueDcmp}{const \hyperlink{Matrix}{Matrix} \&A,\hyperlink{Matrix}{Matrix} \&U,\hyperlink{Matrix}{Matrix} \&S,\hyperlink{Matrix}{Matrix} \&V}{1131}{matrixAlgebra}{}
\functionlistentry{int}{SingularValueDcmp}{const \hyperlink{Matrix}{Matrix} \&A,\hyperlink{Matrix}{Matrix} \&U,\hyperlink{Vector}{Vector} \&S,\hyperlink{Matrix}{Matrix} \&V}{1132}{matrixAlgebra}{}
\functionlistentry{int}{SingularValueDcmp}{MatrixStruct A,MatrixStruct *U,MatrixStruct *S,MatrixStruct *V}{1135}{matrixAlgebra}{}
\functionlistentry{bool}{Solve2}{double a1,double b1,double i1,double a2,double b2,double i2,double \&x1,double \&x2}{1124}{matrixAlgebra}{}
\functionlistentry{\hyperlink{Vector}{Vector}}{SolveLinEqu}{const \hyperlink{Matrix}{Matrix} \&M,const \hyperlink{Vector}{Vector} \&i}{1120}{matrixAlgebra}{}

\subtitle{\hyperlink{SECTION:segmentation}{Segmentierung}}\\
\functionlistentry{void}{GraphIter}{\hyperlink{Image}{Image} Original, \hyperlink{Image}{Image} WSImg, \hyperlink{Image}{Image} \&GrwImg, int Threshold}{1144}{segmentation}{}
\functionlistentry{\hyperlink{Region}{Region}}{RegionGrow}{int x,int y,const \hyperlink{Image}{Image} \&orig,int maxsize=INT\_MAX,int refvalue=-1}{1145}{segmentation}{}
\functionlistentry{int}{RegionGrow}{int x,int y,const \hyperlink{Image}{Image} \&orig,\hyperlink{Image}{Image} \&mark,int val=1,int maxsize=INT\_MAX,int refvalue=-1}{1146}{segmentation}{}
\functionlistentry{\hyperlink{Region}{Region}}{RegionGrowGrw}{int x,int y,const \hyperlink{Image}{Image} \&orig,double stdmax=3.0,int maxSize=INT\_MAX}{1147}{segmentation}{}
\functionlistentry{int}{RegionGrowGrw}{int x,int y,const \hyperlink{Image}{Image} \&orig,\hyperlink{Image}{Image} \&mark,int val=1,double stdmax=3.0,int maxSize=INT\_MAX}{1148}{segmentation}{}
\functionlistentry{int}{WST}{\hyperlink{Image}{Image} in, \hyperlink{Image}{Image} WSImg, int mode=1}{1143}{segmentation}{}

\subtitle{\hyperlink{SECTION:fitting}{Fitting}}\\
\functionlistentry{Segment}{DetermineSegment}{PointList pl, int pa, int pe, int type, Segment sl, int* ma, double* md}{1188}{fitting}{}
\functionlistentry{\hyperlink{Circle}{Circle}}{FitCircle}{const vector\textless {}\hyperlink{Point}{Point}\textgreater  \&pl}{1168}{fitting}{}
\functionlistentry{\hyperlink{Circle}{Circle}}{FitCircle}{const vector\textless {}\hyperlink{Point}{Point}\textgreater  \&pl,const vector\textless {}double\textgreater  \&weight}{1169}{fitting}{}
\functionlistentry{\hyperlink{Circle}{Circle}}{FitCircle}{const vector\textless {}\hyperlink{Point}{Point}\textgreater  \&pl,int step}{1170}{fitting}{}
\functionlistentry{\hyperlink{Circle}{Circle}}{FitCircle}{const vector\textless {}\hyperlink{Point}{Point}\textgreater  \&pl,vector\textless {}double\textgreater  \&weight,int step}{1171}{fitting}{}
\functionlistentry{\hyperlink{Circle}{Circle}}{FitCircle}{const \hyperlink{Matrix}{Matrix} \&pl,int step=0}{1172}{fitting}{}
\functionlistentry{int}{FitCircle}{const \hyperlink{Matrix}{Matrix} \&pl,double \&xm,double \&ym,double \&rad,int step=0}{1173}{fitting}{}
\functionlistentry{int}{FitCircle}{const \hyperlink{Matrix}{Matrix} \&pl,double par[3],int step=0}{1174}{fitting}{}
\functionlistentry{int}{FitCircle}{PointList pl,int a1,int a2,int step,double par[3],double *mdist,int *madr}{1175}{fitting}{}
\functionlistentry{int}{FitCircleLinOpt}{PointList pl,int a1,int a2,int step,double par[3],double limit=1000000}{1176}{fitting}{}
\functionlistentry{Segment}{FitCircleSegment}{PointList pl,int a1,int a2,int step,double *mdist,int *madr}{1182}{fitting}{}
\functionlistentry{\hyperlink{Ellipse}{Ellipse}}{FitEllipse}{const \hyperlink{Matrix}{Matrix} \&pl,int step=0,int mode=1}{1177}{fitting}{}
\functionlistentry{int}{FitEllipse}{const \hyperlink{Matrix}{Matrix} \&pl,double par[5],int step=0,int mode=1}{1178}{fitting}{}
\functionlistentry{int}{FitEllipse}{PointList pl,int a1,int a2,int step,double par[5],double *mdist,int *madr,int mode=1}{1179}{fitting}{}
\functionlistentry{int}{FitEllipseLinOpt}{PointList pl,int a1,int a2,int step,double par[5],double limit}{1180}{fitting}{}
\functionlistentry{Segment}{FitEllipseSegment}{PointList pl,int a1,int a2,int step,double *mdist,int *madr}{1183}{fitting}{}
\functionlistentry{double}{FitGradLine}{\hyperlink{Image}{Image} img, double lp[2][2],int dist, double *p, double *phi}{1192}{fitting}{}
\functionlistentry{double}{FitGrayLine}{\hyperlink{Image}{Image} img, double lp[2][2],int dist, double *p, double *phi}{1191}{fitting}{}
\functionlistentry{\hyperlink{LineSeg}{LineSeg}}{FitLine}{const vector\textless {}\hyperlink{Point}{Point}\textgreater  \&pl}{1159}{fitting}{}
\functionlistentry{\hyperlink{LineSeg}{LineSeg}}{FitLine}{const vector\textless {}\hyperlink{Point}{Point}\textgreater  \&pl,int step}{1160}{fitting}{}
\functionlistentry{\hyperlink{LineSeg}{LineSeg}}{FitLine}{const vector\textless {}\hyperlink{Point}{Point}\textgreater  \&pl,const vector\textless {}double\textgreater  \&weight}{1161}{fitting}{}
\functionlistentry{\hyperlink{LineSeg}{LineSeg}}{FitLine}{const vector\textless {}\hyperlink{Point}{Point}\textgreater  \&pl,vector\textless {}double\textgreater  \&weight,int step}{1162}{fitting}{}
\functionlistentry{\hyperlink{LineSeg}{LineSeg}}{FitLine}{const \hyperlink{Matrix}{Matrix} \&pl,int step=0}{1163}{fitting}{}
\functionlistentry{int}{FitLine}{const \hyperlink{Matrix}{Matrix} \&pl,double \&r,double \&phi,int step=0}{1164}{fitting}{}
\functionlistentry{int}{FitLine}{const \hyperlink{Matrix}{Matrix} \&m,double par[2],int step=0}{1165}{fitting}{}
\functionlistentry{int}{FitLine}{PointList pl,int a1,int a2,int step,double par[2],double *mdist,int *madr}{1166}{fitting}{}
\functionlistentry{int}{FitLineLinOpt}{PointList pl,int a1,int a2,int step,double par[2],double limit=1000000}{1167}{fitting}{}
\functionlistentry{Segment}{FitLineSegment}{PointList pl,int a1,int a2,int step,double *mdist,int *madr}{1181}{fitting}{}
\functionlistentry{PointList}{FitPolygonContur}{\hyperlink{Contur}{Contur} c,int mlng,double mdist}{1185}{fitting}{}
\functionlistentry{PointList}{FitPolygonPointList}{PointList pl,int closed,int mlng,double mdist}{1190}{fitting}{}
\functionlistentry{void}{Gaussfit::Finish}{}{1154}{fitting}{}
\functionlistentry{void}{GaussFit::Fit}{const \hyperlink{Matrix}{Matrix} \&xn,const \hyperlink{Vector}{Vector} \&yn}{1155}{fitting}{}
\functionlistentry{}{GaussFit::GaussFit}{int n=0}{1150}{fitting}{}
\functionlistentry{void}{GaussFit::getResult}{\hyperlink{Vector}{Vector} \&v}{1156}{fitting}{}
\functionlistentry{void}{GaussFit::getResult}{vector\textless {}double\textgreater  \&v}{1157}{fitting}{}
\functionlistentry{void}{GaussFit::Init}{int n=0}{1151}{fitting}{}
\functionlistentry{void}{GaussFit::Value}{const \hyperlink{Vector}{Vector} \&x,double y,double w=1.0}{1152}{fitting}{}
\functionlistentry{void}{GaussFit::Value}{vector\textless {}double\textgreater  \&x,double y,double w=1.0}{1153}{fitting}{}
\functionlistentry{double}{GaussFit::Variance}{}{1158}{fitting}{}
\functionlistentry{Segment}{LineSegContur}{\hyperlink{Contur}{Contur} c,int mlng,double mdist}{1184}{fitting}{}
\functionlistentry{Segment}{LineSegPointList}{PointList pl,int closed,int mlng,double mdist}{1189}{fitting}{}
\functionlistentry{Segment}{SegmentPointList}{PointList pl, int mode}{1186}{fitting}{}
\functionlistentry{Segment}{SegmentPointList}{PointList pl, int mode, [double maxdev]}{1187}{fitting}{}

\subtitle{\hyperlink{SECTION:signalTrafo}{Signal-Transformationen}}\\
\functionlistentry{int}{CepstrumImgD}{ImageD imgs,ImageD imgd}{1210}{signalTrafo}{}
\functionlistentry{int}{Convolution}{const \hyperlink{Vector}{Vector} \&src1,const \hyperlink{Vector}{Vector} \&src2,\hyperlink{Vector}{Vector} \&dst}{1211}{signalTrafo}{}
\functionlistentry{int}{ConvolutionFImgD}{ImageD re1,ImageD im1, ImageD re2,ImageD im2,ImageD re3,ImageD im3}{1213}{signalTrafo}{}
\functionlistentry{int}{ConvolutionHImgD}{ImageD im1,ImageD im2,ImageD im3}{1214}{signalTrafo}{}
\functionlistentry{int}{ConvolutionImg}{const \hyperlink{Image}{Image} \&im1,const \hyperlink{Image}{Image} \&im2, \hyperlink{Image}{Image} \&dst,double factor=0.0,int mode=MD\_USE\_BIAS}{1215}{signalTrafo}{}
\functionlistentry{int}{ConvolutionImg}{const \hyperlink{Image}{Image} \&im1,const \hyperlink{Image}{Image} \&im2, ImageD dst, int mode=MD\_USE\_BIAS}{1216}{signalTrafo}{}
\functionlistentry{int}{ConvolutionImgD}{ImageD im1,ImageD im2,ImageD dst,int mode=MD\_USE\_BIAS}{1212}{signalTrafo}{}
\functionlistentry{int}{CrossCorrelationFImgD}{ImageD re1,ImageD im1, ImageD re2,ImageD im2,ImageD re3,ImageD im3}{1224}{signalTrafo}{}
\functionlistentry{int}{CrossCorrelationHImgD}{ImageD im1,ImageD im2,ImageD im3}{1225}{signalTrafo}{}
\functionlistentry{int}{CrossCorrelationImgD}{ImageD im1,ImageD im2,ImageD dst}{1223}{signalTrafo}{}
\functionlistentry{int}{Fourier}{const \hyperlink{Vector}{Vector} \&re1,const \hyperlink{Vector}{Vector} \&im1,int mode, \hyperlink{Vector}{Vector} \&re2,\hyperlink{Vector}{Vector} \&im2}{1194}{signalTrafo}{}
\functionlistentry{int}{Fourier}{\hyperlink{Vector}{Vector} \&re,\hyperlink{Vector}{Vector} \&im,int mode=NORMAL}{1195}{signalTrafo}{}
\functionlistentry{int}{Fourier}{const \hyperlink{Matrix}{Matrix} \&src,int mode,\hyperlink{Matrix}{Matrix} \&dst}{1196}{signalTrafo}{}
\functionlistentry{int}{Fourier}{\hyperlink{Matrix}{Matrix} \&m,int mode=NORMAL}{1197}{signalTrafo}{}
\functionlistentry{void}{FourierImgD}{ImageD re1,ImageD im1,int mode,ImageD re2,ImageD im2,int dir=XY}{1200}{signalTrafo}{}
\functionlistentry{int}{FourierMPImgD}{ImageD mag,ImageD phase,ImageD re,ImageD im}{1208}{signalTrafo}{}
\functionlistentry{int}{HaarImg}{\hyperlink{Image}{Image} imgs,int depth,int mode,\hyperlink{Image}{Image} imgs}{1229}{signalTrafo}{}
\functionlistentry{int}{Hartley}{const \hyperlink{Vector}{Vector} \&src,const \hyperlink{Vector}{Vector} \&dst}{1198}{signalTrafo}{}
\functionlistentry{int}{Hartley}{\hyperlink{Vector}{Vector} \&src}{1199}{signalTrafo}{}
\functionlistentry{int}{HartleyImgD}{ImageD src,ImageD dest,int dir=XY}{1201}{signalTrafo}{}
\functionlistentry{int}{HartleyMPImgD}{ImageD mag,ImageD phase,ImageD dst}{1209}{signalTrafo}{}
\functionlistentry{int}{InvConvolution}{const \hyperlink{Vector}{Vector} \&src1,const \hyperlink{Vector}{Vector} \&src2,double beta,\hyperlink{Vector}{Vector} \&dst}{1217}{signalTrafo}{}
\functionlistentry{int}{InvConvolutionFImgD}{ImageD re1,ImageD im1, ImageD re2,ImageD im2,ImageD re3,ImageD im3,double beta}{1219}{signalTrafo}{}
\functionlistentry{int}{InvConvolutionHImgD}{ImageD im1,ImageD im2,ImageD im3}{1220}{signalTrafo}{}
\functionlistentry{int}{InvConvolutionImg}{const \hyperlink{Image}{Image} \&im1,const \hyperlink{Image}{Image} \&im2, \hyperlink{Image}{Image} \&dst, double factor=0.0,double beta=0.000001,int mode=MD\_USE\_BIAS}{1221}{signalTrafo}{}
\functionlistentry{int}{InvConvolutionImg}{const \hyperlink{Image}{Image} \&im1,const \hyperlink{Image}{Image} \&im2, ImageD dst, double beta=0.000001,int mode=MD\_USE\_BIAS}{1222}{signalTrafo}{}
\functionlistentry{int}{InvConvolutionImgD}{ImageD im1,ImageD im2,ImageD dst,double beta=0.000001,int mode=MD\_USE\_BIAS}{1218}{signalTrafo}{}
\functionlistentry{int}{InvRadonImg}{const \hyperlink{Image}{Image} \&radon,\hyperlink{Image}{Image} \&res,int fmax=-1}{1232}{signalTrafo}{}
\functionlistentry{ImageD}{MomentImg}{\hyperlink{Image}{Image} imgs,int p,int q,int n,ImageD imgd}{1230}{signalTrafo}{}
\functionlistentry{int}{MPSpectrumFImgD}{ImageD re,ImageD im,ImageD mag,ImageD phase}{1205}{signalTrafo}{}
\functionlistentry{int}{MPSpectrumHImgD}{ImageD sp,ImageD mag,ImageD phase}{1206}{signalTrafo}{}
\functionlistentry{int}{MPSpectrumImgD}{ImageD im,ImageD mag,ImageD phase}{1207}{signalTrafo}{}
\functionlistentry{int}{PowerSpectrumFImgD}{ImageD re,ImageD im,ImageD imgd,int mode=MD\_POWER}{1202}{signalTrafo}{}
\functionlistentry{int}{PowerSpectrumHImgD}{ImageD src,ImageD imgd,int mode=MD\_POWER}{1203}{signalTrafo}{}
\functionlistentry{int}{PowerSpectrumImgD}{ImageD imgs,ImageD imgd,int mode=MD\_POWER}{1204}{signalTrafo}{}
\functionlistentry{int}{RadonImg}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&radon}{1231}{signalTrafo}{}
\functionlistentry{int}{WhiteningFImgD}{ImageD re1,ImageD im1,ImageD re2,ImageD im2,double beta=0}{1227}{signalTrafo}{}
\functionlistentry{int}{WhiteningHImgD}{ImageD imgs,ImageD imgd,double beta=0}{1228}{signalTrafo}{}
\functionlistentry{int}{WhiteningImgD}{ImageD img1,ImageD img2,double beta=0}{1226}{signalTrafo}{}

\subtitle{\hyperlink{SECTION:features}{Merkmale, \"Ahnlichkeiten und Abstandsma\IeC {\ss }e}}\\
\functionlistentry{\hyperlink{Matrix}{Matrix}}{DistanceMatrix}{const \hyperlink{Matrix}{Matrix} \&feat1, const \hyperlink{Matrix}{Matrix} \&feat2, int mode=D\_EUKLID}{1239}{features}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{DistanceMatrix}{const \hyperlink{Matrix}{Matrix} \&feat1, int mode=D\_EUKLID}{1240}{features}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{DistanceMatrix}{const \hyperlink{Matrix}{Matrix} \&feat1, const \hyperlink{Matrix}{Matrix} \& feat2, const VectorDistance \&dist}{1241}{features}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{DistanceMatrix}{const \hyperlink{Matrix}{Matrix} \&feat1, const VectorDistance \&dist}{1242}{features}{}
\functionlistentry{}{QuadraticFormVectorDistance::QuadraticFormVectorDistance}{const \hyperlink{Matrix}{Matrix} \&a}{1238}{features}{}
\functionlistentry{double}{VectorDistance::Distance}{const vector$<$double$>$ \&x,const vector$<$double$>$ \&x}{1234}{features}{}
\functionlistentry{double}{VectorDistance::Distance}{const \hyperlink{Vector}{Vector} \&x,const \hyperlink{Vector}{Vector} \&y}{1235}{features}{}
\functionlistentry{double}{VectorDistance::operator()}{const vector$<$double$>$ \&x,const vector$<$double$>$ \&y}{1236}{features}{}
\functionlistentry{double}{VectorDistance::operator()}{const \hyperlink{Vector}{Vector} \&x,const \hyperlink{Vector}{Vector} \&y}{1237}{features}{}

\subtitle{\hyperlink{SECTION:registration}{Registrierung, Matching}}\\
\functionlistentry{int}{AssignFunction}{const \hyperlink{Matrix}{Matrix} \&cost,IMatrix \&pairs,int mode}{1261}{registration}{}
\functionlistentry{int}{DetectShift}{\hyperlink{Image}{Image} img1,\hyperlink{Image}{Image} img2, double \&dx,double \&dy,double \&val,double beta=0.1}{1252}{registration}{}
\functionlistentry{int}{DetectTrafo}{\hyperlink{Image}{Image} img1,\hyperlink{Image}{Image} img2,\hyperlink{Trafo}{Trafo} \&tr, double beta=0.1,int ct=3,int mode=DT\_NEARLY\_SHIFT}{1253}{registration}{}
\functionlistentry{}{FreePeakList}{PeakList pl}{1260}{registration}{}
\functionlistentry{int}{Hungarian}{const \hyperlink{Matrix}{Matrix} \&cost,IMatrix \&reference\_pairs, double \&min\_cost}{1263}{registration}{}
\functionlistentry{int}{Hungarian}{const \hyperlink{Matrix}{Matrix} \&cost,IMatrix \&reference\_pairs, int mode=0}{1264}{registration}{}
\functionlistentry{PeakList}{ImgPeakList}{\hyperlink{Image}{Image} img,\hyperlink{Image}{Image} mark,int panz=0,int mingrw=0, int zykl=FALSE, int noise=0,int feat=IPL\_NOFEAT,int gnull=0}{1258}{registration}{}
\functionlistentry{\hyperlink{Trafo}{Trafo}}{MatchObject}{(const \hyperlink{Contur}{Contur} \&cont1,const \hyperlink{Contur}{Contur} \&cont2,int tmode,double \&eval,int mmode=MM\_SQUARE,int anz=0)}{1266}{registration}{}
\functionlistentry{\hyperlink{Trafo}{Trafo}}{MatchObject}{(const \hyperlink{Contur}{Contur} \&cont1,const \hyperlink{Contur}{Contur} \&cont2,int tmode=TRM\_AFFINE)}{1267}{registration}{}
\functionlistentry{\hyperlink{Trafo}{Trafo}}{MatchObject}{(const \hyperlink{Contur}{Contur} \&cont1,const \hyperlink{Matrix}{Matrix} \&pl2,int tmode,double \&eval,int mmode=MM\_SQUARE,int anz=0)}{1268}{registration}{}
\functionlistentry{\hyperlink{Trafo}{Trafo}}{MatchObject}{(const \hyperlink{Contur}{Contur} \&cont1,const \hyperlink{Matrix}{Matrix} \&pl2,int tmode=TRM\_AFFINE)}{1269}{registration}{}
\functionlistentry{\hyperlink{Trafo}{Trafo}}{MatchObject}{(const \hyperlink{Matrix}{Matrix} \&pl1,const \hyperlink{Matrix}{Matrix} \&pl2,int tmode,double \&eval,int mmode=MM\_SQUARE,int anz=0)}{1270}{registration}{}
\functionlistentry{\hyperlink{Trafo}{Trafo}}{MatchObject}{(const \hyperlink{Matrix}{Matrix} \&pl1,const \hyperlink{Matrix}{Matrix} \&pl2,int tmode=TRM\_AFFINE)}{1271}{registration}{}
\functionlistentry{\hyperlink{Trafo}{Trafo}}{MatchObject}{(const \hyperlink{Matrix}{Matrix} \&pl1,const \hyperlink{Contur}{Contur} \&cont2,int tmode,double \&eval,int mmode=MM\_SQUARE,int anz=0)}{1272}{registration}{}
\functionlistentry{\hyperlink{Trafo}{Trafo}}{MatchObject}{(const \hyperlink{Matrix}{Matrix} \&pl1,const \hyperlink{Contur}{Contur} \&cont2,int tmode=TRM\_AFFINE)}{1273}{registration}{}
\functionlistentry{\hyperlink{Trafo}{Trafo}}{MatchPointlists}{const \hyperlink{Matrix}{Matrix} \&p1,const \hyperlink{Matrix}{Matrix} \&p2,int mode=TRM\_PROJECTIVE}{1244}{registration}{}
\functionlistentry{\hyperlink{Trafo}{Trafo}}{MatchPointlists}{const \hyperlink{Matrix}{Matrix} \&p1,const \hyperlink{Matrix}{Matrix} \&p2, int mode,const \hyperlink{Vector}{Vector} \&w}{1245}{registration}{}
\functionlistentry{\hyperlink{Trafo}{Trafo}}{MatchPointlists}{const vector\textless {}\hyperlink{Point}{Point}\textgreater  \&pl1, const vector\textless {}\hyperlink{Point}{Point}\textgreater  \&pl2, int mode = TRM\_PROJECTIVE}{1246}{registration}{}
\functionlistentry{\hyperlink{Trafo}{Trafo}}{MatchPointlists}{const vector\textless {}\hyperlink{Point}{Point}\textgreater  \&pl1, const vector\textless {}\hyperlink{Point}{Point}\textgreater  \&pl2, int mode = TRM\_PROJECTIVE, const vector\textless {}double\textgreater  \&weight}{1247}{registration}{}
\functionlistentry{\hyperlink{Trafo}{Trafo}}{MatchPointlists}{PointList pl1,PointList pl2,int mode}{1248}{registration}{}
\functionlistentry{\hyperlink{Trafo}{Trafo}}{MatchPointlistsLinOpt}{const \hyperlink{Matrix}{Matrix} \&p1,const \hyperlink{Matrix}{Matrix} \&p2,int mode=TRM\_AFFINE}{1249}{registration}{}
\functionlistentry{\hyperlink{Trafo}{Trafo}}{MatchPointlistsLinOpt}{const \hyperlink{Matrix}{Matrix} \&p1,const \hyperlink{Matrix}{Matrix} \&p2,int mode,const \hyperlink{Vector}{Vector} \&w,double limit=1000000.0}{1250}{registration}{}
\functionlistentry{int}{MatchPointlistsLinOpt}{PointList pl1,PointList pl2,double tr[][3],int mode=TRM\_AFFINE,double limit=1000000.0}{1251}{registration}{}
\functionlistentry{PeakList}{NewPeakList}{}{1259}{registration}{}
\functionlistentry{int}{OrientationMoments}{double moment[15],double \&angle}{1274}{registration}{}
\functionlistentry{int*}{Peak1D}{double* values,int anz,int\& panz,int zykl,int noise}{1256}{registration}{}
\functionlistentry{IVector}{Peak1D}{const \hyperlink{Vector}{Vector}\& vec,int panz,int zykl,int noise}{1257}{registration}{}
\functionlistentry{double}{PeakValuation}{\hyperlink{Image}{Image} img,\hyperlink{Image}{Image} mark,double\& x0,double\& y0, int mode=PN\_CONVOLUTION,int gnull=0,int zykl=TRUE}{1255}{registration}{}
\functionlistentry{int}{PreprocessImg}{(\hyperlink{Image}{Image} imgs,\hyperlink{Image}{Image} imgd)}{1254}{registration}{}
\functionlistentry{double}{ReferenceCosts}{const \hyperlink{Matrix}{Matrix} \&costs,const IMatrix \&pairs}{1262}{registration}{}
\functionlistentry{int}{TimeWarp}{const \hyperlink{Matrix}{Matrix} \&cost,IMatrix \&reference\_pairs, int mode=TW\_NORMAL}{1265}{registration}{}

\subtitle{\hyperlink{SECTION:graph}{Graphen}}\\
\functionlistentry{double}{computeMinTree}{const vector$<$\hyperlink{Point}{Point}$>$ \&pointlist,\hyperlink{Forest}{Forest} \& tree,double maxlen=0.0}{1295}{graph}{}
\functionlistentry{double}{computeMinTree}{const \hyperlink{Matrix}{Matrix} \&pointlist,\hyperlink{Forest}{Forest} \& tree,double maxlen=0.0}{1296}{graph}{}
\functionlistentry{int}{cutShortBranches}{\hyperlink{Forest}{Forest} \&f,const vector$<$\hyperlink{Point}{Point}$>$ \&pointlist,double minlen}{1298}{graph}{}
\functionlistentry{int}{cutShortBranches}{\hyperlink{Forest}{Forest} \&f,const \hyperlink{Matrix}{Matrix} \&pointlist,double minlen}{1299}{graph}{}
\functionlistentry{}{Delaunay::Delaunay}{vector\textless {}\hyperlink{Point}{Point}\textgreater  \&nodesp}{1302}{graph}{}
\functionlistentry{}{Delaunay::Delaunay}{const \hyperlink{PolygonalCurve}{PolygonalCurve} \&curv}{1303}{graph}{}
\functionlistentry{void}{Delaunay::draw}{const \hyperlink{Image}{Image} \&img, int edgeValue = 1, int fillValue = -1, double limit = -1}{1309}{graph}{}
\functionlistentry{void}{Delaunay::getEdges}{vector\textless {}\hyperlink{LineSeg}{LineSeg}\textgreater  \&output, double limit = -1}{1306}{graph}{}
\functionlistentry{void}{Delaunay::getEdgesI}{vector\textless {}vector\textless {}int\textgreater \textgreater  \&output, double limit = -1}{1307}{graph}{}
\functionlistentry{void}{Delaunay::getRegion}{\hyperlink{Region}{Region} \&region, double limit = -1}{1308}{graph}{}
\functionlistentry{void}{Delaunay::getTriangles}{vector\textless {}\hyperlink{Triangle}{Triangle}\textgreater  \&output, double limit = -1}{1304}{graph}{}
\functionlistentry{void}{Delaunay::getTrianglesI}{vector\textless {}vector\textless {}int\textgreater \textgreater  \&output, double limit = -1}{1305}{graph}{}
\functionlistentry{\hyperlink{Contur}{Contur}}{Dijkstra}{const \hyperlink{Image}{Image} \&img,IPoint s,IPoint e}{1300}{graph}{}
\functionlistentry{\hyperlink{Contur}{Contur}}{Dijkstra}{const \hyperlink{Image}{Image} \&img,IPoint s,\hyperlink{Image}{Image} \&e}{1301}{graph}{}
\functionlistentry{int}{Forest::Depth}{int x}{1288}{graph}{}
\functionlistentry{int}{Forest::Father}{int x}{1286}{graph}{}
\functionlistentry{}{Forest::Forest}{int n=0}{1276}{graph}{}
\functionlistentry{int}{Forest::getNeighborCount}{int x}{1281}{graph}{}
\functionlistentry{int}{Forest::getRefCount}{int x}{1280}{graph}{}
\functionlistentry{bool}{Forest::isLeaf}{int x}{1284}{graph}{}
\functionlistentry{bool}{Forest::isRoot}{int x}{1283}{graph}{}
\functionlistentry{void}{Forest::makeRoot}{int x}{1285}{graph}{}
\functionlistentry{int}{Forest::nTree}{bool ignoreZeroLengthTrees=false}{1279}{graph}{}
\functionlistentry{int}{Forest::Reset}{int n}{1277}{graph}{}
\functionlistentry{int}{Forest::Root}{int x}{1287}{graph}{}
\functionlistentry{void}{Forest::setFather}{int x,int f=\hyperlink{Forest}{Forest}::rootval}{1282}{graph}{}
\functionlistentry{int}{Forest::Size}{}{1278}{graph}{}
\functionlistentry{double}{MinTree::getCluster}{\hyperlink{Forest}{Forest} \&f, int nCluster}{1294}{graph}{}
\functionlistentry{double}{MinTree::getForest}{\hyperlink{Forest}{Forest} \&f, double maxlen}{1293}{graph}{}
\functionlistentry{double}{MinTree::getTree}{\hyperlink{Forest}{Forest} \&f}{1292}{graph}{}
\functionlistentry{}{MinTree::MinTree}{const vector\textless {}\hyperlink{Point}{Point}\textgreater  \&pointlist}{1289}{graph}{}
\functionlistentry{}{MinTree::MinTree}{const vector\textless {}vector\textless {}double\textgreater  \textgreater  \&nodelist, const VectorDistance \&vd = EuclideanVectorDistance()}{1290}{graph}{}
\functionlistentry{}{MinTree::MinTree}{const \hyperlink{Matrix}{Matrix} \&distances}{1291}{graph}{}
\functionlistentry{vector$<$vector$<$int$>$ $>$}{SplitToBranches}{\hyperlink{Forest}{Forest} f}{1297}{graph}{}

\subtitle{\hyperlink{SECTION:graphics}{Grafik}}\\
\functionlistentry{\hyperlink{Contur}{Contur}}{CircleContur}{double par[3]}{1332}{graphics}{}
\functionlistentry{\hyperlink{Contur}{Contur}}{CircleSegmentContur}{double par[5]}{1334}{graphics}{}
\functionlistentry{int}{DrawCircle}{double par[3],int val1,int val2,int mode,\hyperlink{Image}{Image} img}{1325}{graphics}{}
\functionlistentry{int}{DrawCircleSegment}{double par[5],int val1,int val2,int mode,\hyperlink{Image}{Image} img}{1328}{graphics}{}
\functionlistentry{int}{DrawEllipse}{double par[5],int val1,int val2,int mode,\hyperlink{Image}{Image} img}{1326}{graphics}{}
\functionlistentry{int}{DrawEllipseSegment}{double *par[7],int val1,int val2,int mode,\hyperlink{Image}{Image} img}{1329}{graphics}{}
\functionlistentry{void}{DrawPolygon}{PointList pl,int val,\hyperlink{Image}{Image} img}{1330}{graphics}{}
\functionlistentry{void}{DrawSuperEllipse}{double c, double tr[3][3], int val,\hyperlink{Image}{Image} img}{1327}{graphics}{}
\functionlistentry{\hyperlink{Contur}{Contur}}{EllipseContur}{double par[5]}{1333}{graphics}{}
\functionlistentry{\hyperlink{Contur}{Contur}}{EllipseSegmentContur}{double par[7]}{1335}{graphics}{}
\functionlistentry{int}{FillRegion}{\hyperlink{Contur}{Contur} c,int val,\hyperlink{Image}{Image} img}{1337}{graphics}{}
\functionlistentry{int}{HesseLine}{double p,double phi,int val,\hyperlink{Image}{Image} img}{1323}{graphics}{}
\functionlistentry{int}{HesseLine}{const \hyperlink{Vector}{Vector} \&p,int val,\hyperlink{Image}{Image} img}{1324}{graphics}{}
\functionlistentry{int}{Line}{int x1,int y1,int x2,int y2,int val,int mode,\hyperlink{Image}{Image} img}{1317}{graphics}{}
\functionlistentry{int}{Line}{int x1,int y1,int x2,int y2,int val,\hyperlink{Image}{Image} img}{1318}{graphics}{}
\functionlistentry{int}{Line}{const IVector \&p1,const IVector \&p2,int val,int mode,\hyperlink{Image}{Image} img}{1319}{graphics}{}
\functionlistentry{int}{Line}{const IVector \&p1,const IVector \&p2,int val,\hyperlink{Image}{Image} img}{1320}{graphics}{}
\functionlistentry{int}{Line}{const \hyperlink{Point}{Point} \&p1,const \hyperlink{Point}{Point} \&p2,int val,int mode,\hyperlink{Image}{Image} img}{1321}{graphics}{}
\functionlistentry{int}{Line}{const \hyperlink{Point}{Point} \&p1,const \hyperlink{Point}{Point} \&p2,int val,\hyperlink{Image}{Image} img}{1322}{graphics}{}
\functionlistentry{\hyperlink{Contur}{Contur}}{LineContur}{\hyperlink{Contur}{Contur} c,int p1[2][,int p2[2]]}{1331}{graphics}{}
\functionlistentry{int}{MarkContur}{\hyperlink{Contur}{Contur} c,int val,\hyperlink{Image}{Image} img}{1336}{graphics}{}
\functionlistentry{int}{Marker}{int mode, int x,int y,int val,int size,\hyperlink{Image}{Image} img}{1311}{graphics}{}
\functionlistentry{int}{Marker}{int mode, const IVector \&p,int val,int size,\hyperlink{Image}{Image} img}{1312}{graphics}{}
\functionlistentry{int}{Marker}{int mode, const \hyperlink{Point}{Point} \&p,int val,int size,\hyperlink{Image}{Image} img}{1313}{graphics}{}
\functionlistentry{\hyperlink{Contur}{Contur}}{SelContur}{\hyperlink{Image}{Image} img,int force\_close=FALSE}{1341}{graphics}{}
\functionlistentry{\hyperlink{LineSeg}{LineSeg}}{SelLine}{\hyperlink{Image}{Image} img}{1338}{graphics}{}
\functionlistentry{int}{SelLine}{\hyperlink{Image}{Image} img,IPoint \&p1,IPoint p2}{1339}{graphics}{}
\functionlistentry{int}{SelLine}{\hyperlink{Image}{Image} img,int p0[2],int p[2]}{1340}{graphics}{}
\functionlistentry{int}{Text}{const string \&s,IPoint p,int val,int exp,\hyperlink{Image}{Image} \& img}{1314}{graphics}{}
\functionlistentry{int}{Text}{const string \&s,int x,int y,int val,int exp,\hyperlink{Image}{Image} \& img}{1315}{graphics}{}
\functionlistentry{int}{Text}{const char *s,int x,int y,int val,int exp,\hyperlink{Image}{Image} \& img}{1316}{graphics}{}

\subtitle{\hyperlink{SECTION:numeric}{Numerik}}\\
\functionlistentry{double}{Arcus}{double degree}{1348}{numeric}{}
\functionlistentry{double}{AreaPolygon}{PointList pl}{1379}{numeric}{}
\functionlistentry{double}{AreaPolygon}{const \hyperlink{Matrix}{Matrix} \&pl}{1380}{numeric}{}
\functionlistentry{int}{Bairstow}{const \hyperlink{Vector}{Vector} \&para,\hyperlink{Matrix}{Matrix}\& result,int inumber = 1000}{1399}{numeric}{}
\functionlistentry{double}{ClosestPointLineSeg}{double p[2],double ls0[2],double ls1[2],double pf[2]}{1374}{numeric}{}
\functionlistentry{void}{ConvCartesPolar}{double x,double y,double \&rad,double \&arc}{1366}{numeric}{}
\functionlistentry{void}{ConvCartesPolar}{double p[2],double *rad,double *arc}{1367}{numeric}{}
\functionlistentry{int}{ConvPointHesse}{double p1[2],double p2[2],double *p,double *phi}{1370}{numeric}{}
\functionlistentry{\hyperlink{Vector}{Vector}}{ConvPointHesse}{const \hyperlink{Vector}{Vector} \&p1,const \hyperlink{Vector}{Vector} \&p2}{1371}{numeric}{}
\functionlistentry{void}{ConvPolarCartes}{double rad,double arc,double \&x,double \&y}{1368}{numeric}{}
\functionlistentry{void}{ConvPolarCartes}{double rad,double arc,double p[2]}{1369}{numeric}{}
\functionlistentry{int}{ConvR3PointHesse}{double p1[3],double p2[3],double p3[3],double *p,double n[3]}{1393}{numeric}{}
\functionlistentry{double}{Cub}{double val}{1346}{numeric}{}
\functionlistentry{double}{CubRoot}{double val}{1347}{numeric}{}
\functionlistentry{double}{Degree}{double arc}{1349}{numeric}{}
\functionlistentry{int}{Derive2Func}{FuncD func, int dim,int i,double *x,double h,int mode,double *val}{1401}{numeric}{}
\functionlistentry{int}{DeriveFunc}{FuncD func,int dim,int i,double *x,double h,int mode,double *val}{1400}{numeric}{}
\functionlistentry{double}{Distance}{double x1,double y1,double x2,double y2}{1363}{numeric}{}
\functionlistentry{double}{Distance}{IPoint p1,IPoint p2}{1364}{numeric}{}
\functionlistentry{double}{Distance}{\hyperlink{Point}{Point} p1,\hyperlink{Point}{Point} p2}{1365}{numeric}{}
\functionlistentry{double}{Distance}{const Point3d \&p1,const Point3d \&p2}{1384}{numeric}{}
\functionlistentry{double}{Distance}{const Point3d \&p,const \hyperlink{Line3d}{Line3d} \&l}{1385}{numeric}{}
\functionlistentry{double}{Distance}{const \hyperlink{Line3d}{Line3d} \&l,const Point3d \&p}{1386}{numeric}{}
\functionlistentry{double}{Distance}{const \hyperlink{Line3d}{Line3d} \&l1,const \hyperlink{Line3d}{Line3d} \&l2}{1387}{numeric}{}
\functionlistentry{double}{DistPointCircle}{double p[2],double par[3]}{1375}{numeric}{}
\functionlistentry{double}{DistPointEllipse}{double p[2],double par[5],double koord[2]}{1376}{numeric}{}
\functionlistentry{double}{DistPointLine}{double r[2],double p,double phi}{1373}{numeric}{}
\functionlistentry{double}{DistR3PointLine}{double p[3],double p0[3],double dir[3]}{1394}{numeric}{}
\functionlistentry{double}{DistR3PointPlane}{double p[3],double r,double n[3]}{1395}{numeric}{}
\functionlistentry{int}{FeatureQuadrFunc}{double koeff[6],double par[5],int *type}{1381}{numeric}{}
\functionlistentry{double}{FMod}{double val,double mod}{1358}{numeric}{}
\functionlistentry{double}{GammaFunction}{double x}{1362}{numeric}{}
\functionlistentry{int}{IntegrateFunc}{FuncD func,double s1,double s2,double *prec,double *val}{1402}{numeric}{}
\functionlistentry{int}{IntersecLine}{double p1,double phi1,double p2,double phi2,double p[2]}{1377}{numeric}{}
\functionlistentry{int}{Intersection}{const \hyperlink{Line3d}{Line3d} \&l1,const \hyperlink{Line3d}{Line3d} \&l2,Point3d \&p,double \&dist,\hyperlink{Vector}{Vector} \&res}{1388}{numeric}{}
\functionlistentry{int}{Intersection}{const \hyperlink{Line3d}{Line3d} \&l1,const \hyperlink{Line3d}{Line3d} \&l2,Point3d \&p,double \&dist}{1389}{numeric}{}
\functionlistentry{int}{Intersection}{const \hyperlink{Line3d}{Line3d} \&l1,const \hyperlink{Line3d}{Line3d} \&l2,Point3d \&p}{1390}{numeric}{}
\functionlistentry{int}{Intersection}{const \hyperlink{Line3d}{Line3d} \&l,const \hyperlink{Sphere}{Sphere} \&s,Point3d \&p1,Point3d \&p2}{1391}{numeric}{}
\functionlistentry{int}{InvarFivePoint2d}{double p[5][2],double *i1,double *i2}{1383}{numeric}{}
\functionlistentry{int}{InvarFivePoint3d}{double p[5][3],double *i1,double *i2}{1392}{numeric}{}
\functionlistentry{int}{limited}{int val,int min,int max}{1343}{numeric}{}
\functionlistentry{int}{limited}{int val,\hyperlink{Image}{Image} img}{1344}{numeric}{}
\functionlistentry{int}{Max}{int val1,int val2}{1352}{numeric}{}
\functionlistentry{double}{MaxD}{double val1,double val2}{1354}{numeric}{}
\functionlistentry{int}{Min}{int val1,int val2}{1353}{numeric}{}
\functionlistentry{double}{MinD}{double val1,double val2}{1355}{numeric}{}
\functionlistentry{int}{Mod}{int val,int mod}{1357}{numeric}{}
\functionlistentry{int}{MulDiv}{int val1,int val2,int val3}{1356}{numeric}{}
\functionlistentry{int}{ParamQuadrFunc}{double par[5],int type,double koeff[6]}{1382}{numeric}{}
\functionlistentry{int}{Root2}{double p1,p0,Complex *cptr1,*cptr2}{1396}{numeric}{}
\functionlistentry{int}{Root3}{double p2,p1,p0,Complex c[3]}{1397}{numeric}{}
\functionlistentry{int}{Root4}{double p3,p2,p1,p0,Complex c[4]}{1398}{numeric}{}
\functionlistentry{void}{RotTransPoint}{double p1[2],double centre[2],double arc,double p2[2]}{1372}{numeric}{}
\functionlistentry{double}{Round}{double val}{1359}{numeric}{}
\functionlistentry{int}{RoundInt}{double val}{1360}{numeric}{}
\functionlistentry{void}{RoundInt}{double val,int \&i}{1361}{numeric}{}
\functionlistentry{int}{Sign}{int val}{1350}{numeric}{}
\functionlistentry{double}{SignD}{double val}{1351}{numeric}{}
\functionlistentry{double}{Sqr}{double val}{1345}{numeric}{}
\functionlistentry{int}{TangentCircle}{double p[2],double par[3],double p1[2],double p2[2]}{1378}{numeric}{}

\subtitle{\hyperlink{SECTION:genericTools}{Allgemeine Werkzeuge}}\\
\functionlistentry{void}{Alpha}{int mode}{1418}{genericTools}{}
\functionlistentry{int}{AlphaSizeX}{void}{1425}{genericTools}{}
\functionlistentry{int}{AlphaSizeY}{void}{1426}{genericTools}{}
\functionlistentry{void}{Bell}{void}{1424}{genericTools}{}
\functionlistentry{void}{ClearAlpha}{void}{1421}{genericTools}{}
\functionlistentry{void}{CloseAlpha}{void}{1417}{genericTools}{}
\functionlistentry{void}{Delay}{double time}{1445}{genericTools}{}
\functionlistentry{void}{Directory}{vector$<$string$>$ \&t,const string \&mask,int mode=DIR\_FILE $|$ DIR\_DIR}{1446}{genericTools}{}
\functionlistentry{double}{Double}{const string \&s}{1410}{genericTools}{}
\functionlistentry{void}{GetAlphaCursor}{int *x,int *y}{1423}{genericTools}{}
\functionlistentry{int}{GetChar}{void}{1429}{genericTools}{}
\functionlistentry{int}{GetKey}{void}{1430}{genericTools}{}
\functionlistentry{int}{Input}{const char *prompt}{1433}{genericTools}{}
\functionlistentry{int}{Input}{const char *prompt,int defvalue}{1434}{genericTools}{}
\functionlistentry{int}{Input}{const string \&prompt}{1435}{genericTools}{}
\functionlistentry{int}{Input}{const string \&prompt,int defvalue}{1436}{genericTools}{}
\functionlistentry{double}{InputD}{const char *prompt}{1437}{genericTools}{}
\functionlistentry{double}{InputD}{const char *prompt,double defvalue}{1438}{genericTools}{}
\functionlistentry{double}{InputD}{const string \&prompt}{1439}{genericTools}{}
\functionlistentry{double}{InputD}{const string \&prompt,double defvalue}{1440}{genericTools}{}
\functionlistentry{void}{InputS}{const char *p,char *s}{1441}{genericTools}{}
\functionlistentry{string}{InputS}{const string \&p}{1442}{genericTools}{}
\functionlistentry{int}{InputString}{char *Str,int Control,int *Ptr,int *scroll}{1443}{genericTools}{}
\functionlistentry{int}{Integer}{const string\& s}{1409}{genericTools}{}
\functionlistentry{string}{lowercase}{const string \&s}{1411}{genericTools}{}
\functionlistentry{int}{Menu}{const vector$<$string$>$ \&t,int x1=-1,int y1=-1,int x2=-1,int y2=-1, bool restore=false,const string \&title=''''}{1447}{genericTools}{}
\functionlistentry{int}{Menu}{const vector$<$string$>$ \&t,const vector$<$int$>$ \&menuId, int x1=2,int y1=2,int x2=30,int y2=22, bool restore=false,const string \&title=''''}{1448}{genericTools}{}
\functionlistentry{string}{NumberString}{int i,unsigned int width=0}{1404}{genericTools}{}
\functionlistentry{string}{NumberString}{unsigned int i,unsigned int width=0}{1405}{genericTools}{}
\functionlistentry{string}{NumberString}{long int i,unsigned int width=0}{1406}{genericTools}{}
\functionlistentry{string}{NumberString}{long long int i,unsigned int width=0}{1407}{genericTools}{}
\functionlistentry{string}{NumberString}{double f,unsigned int width=0,unsigned int prec=0}{1408}{genericTools}{}
\functionlistentry{void}{OpenAlpha}{unsigned char *windowname}{1416}{genericTools}{}
\functionlistentry{void}{PopAlpha}{void}{1420}{genericTools}{}
\functionlistentry{int}{Print}{const string \&s}{1432}{genericTools}{}
\functionlistentry{int}{Printf}{const char *format,...}{1431}{genericTools}{}
\functionlistentry{void}{PushAlpha}{void}{1419}{genericTools}{}
\functionlistentry{int}{PutChar}{int c}{1428}{genericTools}{}
\functionlistentry{bool}{SelFile}{const string \&mask,string \&filename,string \&dirname,int mode=DIR\_FILE,const string \&title='''', int x1=-1,int y1=-1,int x2=-1,int y2=-1}{1449}{genericTools}{}
\functionlistentry{bool}{SelFile}{const string \&mask, string \&filename}{1450}{genericTools}{}
\functionlistentry{void}{SetAlphaCursor}{int x,int y}{1422}{genericTools}{}
\functionlistentry{void}{SetAttribute}{int fg,int bg,int inv,int high}{1427}{genericTools}{}
\functionlistentry{string}{Split}{string \&text,const string \&del,int erase=true, int need\_del=false}{1413}{genericTools}{}
\functionlistentry{string}{SplitFilename}{const string \&fullname,string \&path,string \&basename,string \&ext}{1414}{genericTools}{}
\functionlistentry{string}{SplitFilename}{const string \&fullname,string \&path,string \&filename}{1415}{genericTools}{}
\functionlistentry{double}{TimeD}{int mode=TM\_WORLD}{1444}{genericTools}{}
\functionlistentry{string}{uppercase}{const string \&s}{1412}{genericTools}{}

\subtitle{\hyperlink{SECTION:quaternions}{Quaternionen}}\\
\functionlistentry{\hyperlink{RotQuaternion}{RotQuaternion}}{convertToRotQuaternion}{\hyperlink{Quaternion}{Quaternion}\& in}{1502}{quaternions}{}
\functionlistentry{\hyperlink{RotQuaternion}{RotQuaternion}}{convertToRotQuaternion}{\hyperlink{Matrix}{Matrix}\& in}{1503}{quaternions}{}
\functionlistentry{\hyperlink{TrafoDualQuaternion}{TrafoDualQuaternion}}{convertToTrafoDualQuaternion}{const \hyperlink{Matrix}{Matrix}\& in}{1538}{quaternions}{}
\functionlistentry{}{DualQuaternion::DualQuaternion}{}{1513}{quaternions}{}
\functionlistentry{}{DualQuaternion::DualQuaternion}{\hyperlink{Quaternion}{Quaternion}\& real, \hyperlink{Quaternion}{Quaternion}\& dual}{1514}{quaternions}{}
\functionlistentry{}{DualQuaternion::DualQuaternion}{const \hyperlink{DualQuaternion}{DualQuaternion}\& b}{1515}{quaternions}{}
\functionlistentry{\hyperlink{DualQuaternion}{DualQuaternion}}{DualQuaternion::getConjugate}{}{1521}{quaternions}{}
\functionlistentry{\hyperlink{Quaternion}{Quaternion}}{DualQuaternion::getDual}{}{1517}{quaternions}{}
\functionlistentry{\hyperlink{DualQuaternion}{DualQuaternion}}{DualQuaternion::getInverse}{}{1523}{quaternions}{}
\functionlistentry{\hyperlink{DualQuaternion}{DualQuaternion}}{DualQuaternion::getNegate}{}{1520}{quaternions}{}
\functionlistentry{\hyperlink{DualQuaternion}{DualQuaternion}}{DualQuaternion::getQuasiNorm}{}{1524}{quaternions}{}
\functionlistentry{\hyperlink{Quaternion}{Quaternion}}{DualQuaternion::getReal}{}{1516}{quaternions}{}
\functionlistentry{\hyperlink{DualQuaternion}{DualQuaternion}}{DualQuaternion::getTilde}{}{1522}{quaternions}{}
\functionlistentry{bool}{DualQuaternion::isUnitDualQuaternion}{}{1525}{quaternions}{}
\functionlistentry{void}{DualQuaternion::setDual}{\hyperlink{Quaternion}{Quaternion}\& dual}{1519}{quaternions}{}
\functionlistentry{void}{DualQuaternion::setReal}{\hyperlink{Quaternion}{Quaternion}\& real}{1518}{quaternions}{}
\functionlistentry{int}{EigenachsenSpektrumQFT}{\hyperlink{QuatMatrix}{QuatMatrix}\& input, \hyperlink{Image}{Image}\& r, \hyperlink{Image}{Image}\& g, \hyperlink{Image}{Image}\& b, int mode=CENTER}{1543}{quaternions}{}
\functionlistentry{int}{EigenwinkelSpektrumQFT}{\hyperlink{QuatMatrix}{QuatMatrix}\& input, \hyperlink{Image}{Image}\& r, \hyperlink{Image}{Image}\& g, \hyperlink{Image}{Image}\& b, int mode=CENTER}{1542}{quaternions}{}
\functionlistentry{\hyperlink{TrafoDualQuaternion}{TrafoDualQuaternion}}{estimateTransformation}{const \hyperlink{Matrix}{Matrix}\& orig,const \hyperlink{Matrix}{Matrix}\& trans}{1539}{quaternions}{}
\functionlistentry{int}{PhasenSpektrumQFT}{\hyperlink{QuatMatrix}{QuatMatrix}\& input, \hyperlink{Image}{Image}\& alpha, \hyperlink{Image}{Image}\& beta, \hyperlink{Image}{Image}\& delta, int mode=CENTER}{1544}{quaternions}{}
\functionlistentry{int}{PowerSpektrumQFT}{\hyperlink{QuatMatrix}{QuatMatrix}\& input, \hyperlink{Image}{Image}\& output,int type=POWER, int mode=CENTER}{1541}{quaternions}{}
\functionlistentry{\hyperlink{Quaternion}{Quaternion}}{qexp}{\hyperlink{Quaternion}{Quaternion}\& x}{1477}{quaternions}{}
\functionlistentry{\hyperlink{Quaternion}{Quaternion}}{qexp}{\hyperlink{RotQuaternion}{RotQuaternion}\& x}{1501}{quaternions}{}
\functionlistentry{int}{QFourier}{\hyperlink{QuatMatrix}{QuatMatrix}\& input, \hyperlink{QuatMatrix}{QuatMatrix}\& output,int option=NORMAL}{1540}{quaternions}{}
\functionlistentry{\hyperlink{Quaternion}{Quaternion}}{Quaternion::getConjugate}{}{1467}{quaternions}{}
\functionlistentry{\hyperlink{Quaternion}{Quaternion}}{Quaternion::getEigenachse}{}{1474}{quaternions}{}
\functionlistentry{double}{Quaternion::getEigenwinkel}{}{1473}{quaternions}{}
\functionlistentry{double}{Quaternion::getI}{}{1457}{quaternions}{}
\functionlistentry{vector3d}{Quaternion::getImaginary}{}{1460}{quaternions}{}
\functionlistentry{\hyperlink{Quaternion}{Quaternion}}{Quaternion::getInverse}{}{1468}{quaternions}{}
\functionlistentry{double}{Quaternion::getJ}{}{1458}{quaternions}{}
\functionlistentry{double}{Quaternion::getK}{}{1459}{quaternions}{}
\functionlistentry{\hyperlink{Quaternion}{Quaternion}}{Quaternion::getNegate}{}{1466}{quaternions}{}
\functionlistentry{double}{Quaternion::getNorm}{}{1471}{quaternions}{}
\functionlistentry{\hyperlink{Quaternion}{Quaternion}}{Quaternion::getNormalize}{}{1469}{quaternions}{}
\functionlistentry{vector3d}{Quaternion::getPhases}{}{1475}{quaternions}{}
\functionlistentry{double}{Quaternion::getReal}{}{1456}{quaternions}{}
\functionlistentry{\hyperlink{Quaternion}{Quaternion}}{Quaternion::getSquare}{}{1470}{quaternions}{}
\functionlistentry{double}{Quaternion::getSquareNorm}{}{1472}{quaternions}{}
\functionlistentry{bool}{Quaternion::isUnitQuaternion}{}{1476}{quaternions}{}
\functionlistentry{}{Quaternion::Quaternion}{}{1452}{quaternions}{}
\functionlistentry{}{Quaternion::Quaternion}{double real, double i, double j, double k}{1453}{quaternions}{}
\functionlistentry{}{Quaternion::Quaternion}{double real, \hyperlink{Vector3d}{Vector3d}\& imaginary}{1454}{quaternions}{}
\functionlistentry{}{Quaternion::Quaternion}{const \hyperlink{Quaternion}{Quaternion}\& b}{1455}{quaternions}{}
\functionlistentry{void}{Quaternion::setI}{double i}{1462}{quaternions}{}
\functionlistentry{void}{Quaternion::setImaginary}{vector3d\& imaginary}{1465}{quaternions}{}
\functionlistentry{void}{Quaternion::setJ}{double j}{1463}{quaternions}{}
\functionlistentry{void}{Quaternion::setK}{double k}{1464}{quaternions}{}
\functionlistentry{void}{Quaternion::setReal}{double real}{1461}{quaternions}{}
\functionlistentry{unsigned int}{QuatMatrix::getColumns}{}{1508}{quaternions}{}
\functionlistentry{unsigned int}{QuatMatrix::getRows}{}{1507}{quaternions}{}
\functionlistentry{}{QuatMatrix::QuatMatrix}{}{1504}{quaternions}{}
\functionlistentry{}{QuatMatrix::QuatMatrix}{unsigned int rows, unsigned int columns}{1505}{quaternions}{}
\functionlistentry{}{QuatMatrix::QuatMatrix}{const \hyperlink{QuatMatrix}{QuatMatrix}\& qm}{1506}{quaternions}{}
\functionlistentry{unsigned int}{QuatVector::getDimension}{}{1512}{quaternions}{}
\functionlistentry{}{QuatVector::QuatVector}{}{1509}{quaternions}{}
\functionlistentry{}{QuatVector::QuatVector}{unsigned int dimension}{1510}{quaternions}{}
\functionlistentry{}{QuatVector::QuatVector}{const \hyperlink{QuatVector}{QuatVector}\& qv}{1511}{quaternions}{}
\functionlistentry{\hyperlink{RotQuaternion}{RotQuaternion}}{RotQuaternion::getConjugate}{}{1492}{quaternions}{}
\functionlistentry{\hyperlink{RotQuaternion}{RotQuaternion}}{RotQuaternion::getEigenachse}{}{1498}{quaternions}{}
\functionlistentry{double}{RotQuaternion::getEigenwinkel}{}{1497}{quaternions}{}
\functionlistentry{double}{RotQuaternion::getI}{}{1483}{quaternions}{}
\functionlistentry{vector3d}{RotQuaternion::getImaginary}{}{1486}{quaternions}{}
\functionlistentry{\hyperlink{RotQuaternion}{RotQuaternion}}{RotQuaternion::getInverse}{}{1493}{quaternions}{}
\functionlistentry{double}{RotQuaternion::getJ}{}{1484}{quaternions}{}
\functionlistentry{double}{RotQuaternion::getK}{}{1485}{quaternions}{}
\functionlistentry{\hyperlink{RotQuaternion}{RotQuaternion}}{RotQuaternion::getNegate}{}{1491}{quaternions}{}
\functionlistentry{double}{RotQuaternion::getNorm}{}{1495}{quaternions}{}
\functionlistentry{vector3d}{RotQuaternion::getPhases}{}{1499}{quaternions}{}
\functionlistentry{double}{RotQuaternion::getReal}{}{1482}{quaternions}{}
\functionlistentry{double}{RotQuaternion::getRotationAngle}{}{1487}{quaternions}{}
\functionlistentry{vector3d}{RotQuaternion::getRotationAxis}{}{1488}{quaternions}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{RotQuaternion::getRotationMatrix}{}{1500}{quaternions}{}
\functionlistentry{\hyperlink{RotQuaternion}{RotQuaternion}}{RotQuaternion::getSquare}{}{1494}{quaternions}{}
\functionlistentry{double}{RotQuaternion::getSquareNorm}{}{1496}{quaternions}{}
\functionlistentry{}{RotQuaternion::RotQuaternion}{}{1478}{quaternions}{}
\functionlistentry{}{RotQuaternion::RotQuaternion}{double angle, double x, double y, double z}{1479}{quaternions}{}
\functionlistentry{}{RotQuaternion::RotQuaternion}{double angle, vector3d\& axis}{1480}{quaternions}{}
\functionlistentry{}{RotQuaternion::RotQuaternion}{const \hyperlink{RotQuaternion}{RotQuaternion}\& b) { Es wird eine Kopie der Rotationsquaternion b erzeugt. (Kopier-Konstruktor} }{1481}{quaternions}{}
\functionlistentry{void}{RotQuaternion::setRotationAngle}{double angle}{1489}{quaternions}{}
\functionlistentry{void}{RotQuaternion::setRotationAxis}{vector3d\& axis}{1490}{quaternions}{}
\functionlistentry{\hyperlink{TrafoDualQuaternion}{TrafoDualQuaternion}}{TrafoDualQuaternion::getConjugate}{}{1534}{quaternions}{}
\functionlistentry{\hyperlink{Quaternion}{Quaternion}}{TrafoDualQuaternion::getDual}{}{1530}{quaternions}{}
\functionlistentry{\hyperlink{TrafoDualQuaternion}{TrafoDualQuaternion}}{TrafoDualQuaternion::getInverse}{}{1536}{quaternions}{}
\functionlistentry{\hyperlink{TrafoDualQuaternion}{TrafoDualQuaternion}}{TrafoDualQuaternion::getNegate}{}{1533}{quaternions}{}
\functionlistentry{\hyperlink{Quaternion}{Quaternion}}{TrafoDualQuaternion::getReal}{}{1529}{quaternions}{}
\functionlistentry{\hyperlink{TrafoDualQuaternion}{TrafoDualQuaternion}}{TrafoDualQuaternion::getTilde}{}{1535}{quaternions}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{TrafoDualQuaternion::getTransformationMatrix}{}{1537}{quaternions}{}
\functionlistentry{void}{TrafoDualQuaternion::setDual}{vector3d\& trans}{1532}{quaternions}{}
\functionlistentry{void}{TrafoDualQuaternion::setRotation}{\hyperlink{RotQuaternion}{RotQuaternion}\& rot}{1531}{quaternions}{}
\functionlistentry{}{TrafoDualQuaternion::TrafoDualQuaternion}{}{1526}{quaternions}{}
\functionlistentry{}{TrafoDualQuaternion::TrafoDualQuaternion}{\hyperlink{RotQuaternion}{RotQuaternion}\& rot, vector3d\& trans}{1527}{quaternions}{}
\functionlistentry{}{TrafoDualQuaternion::TrafoDualQuaternion}{const \hyperlink{TrafoDualQuaternion}{TrafoDualQuaternion}\& b}{1528}{quaternions}{}

\subtitle{\hyperlink{SECTION:errorHandling}{Fehlerbehandlung}}\\
\functionlistentry{int}{GetError}{void}{1550}{errorHandling}{}
\functionlistentry{}{IfFailed}{function}{1553}{errorHandling}{}
\functionlistentry{void}{Message}{char *name, char *msg, int code}{1546}{errorHandling}{}
\functionlistentry{void}{OffMessage}{void}{1547}{errorHandling}{}
\functionlistentry{void}{OnMessage}{void}{1548}{errorHandling}{}
\functionlistentry{}{ReturnErrorIfFailed}{function}{1552}{errorHandling}{}
\functionlistentry{}{ReturnNullIfFailed}{function}{1551}{errorHandling}{}
\functionlistentry{void}{SetOk}{void}{1549}{errorHandling}{}

\subtitle{\hyperlink{SECTION:obsolet}{Veraltete Datenstrukturen und Funktionen}}\\
\functionlistentry{double*}{AddVec}{double v1[3],double v2[3],double v3[3]}{1558}{obsolet}{}
\functionlistentry{double*}{AddVecRn}{double *v1,double *v2,int dim,double *v3}{1568}{obsolet}{}
\functionlistentry{int}{AffinAlgebraicInvar}{double m[15],double flu[4]}{1615}{obsolet}{}
\functionlistentry{double}{AffinFitMoments}{double m1[15],double m2[15],double tr[3][3]}{1620}{obsolet}{}
\functionlistentry{double}{AffinFitPolygons}{PointList pl1,PointList pl2,double tr[3][3]}{1621}{obsolet}{}
\functionlistentry{int}{AffinHuInvar}{double m[15],double hu[7]}{1616}{obsolet}{}
\functionlistentry{int}{AffinIterateMoments}{double m[21],double maf[21],double atr[3][3]}{1619}{obsolet}{}
\functionlistentry{int}{AffinNormMoments}{double m[21],double maf[21],double atr[3][3]}{1617}{obsolet}{}
\functionlistentry{int}{AffinTransMoments}{const double m1[15],double tr[3][3],double m2[15]}{1608}{obsolet}{}
\functionlistentry{double}{AngleVec}{double v1[3],double v2[3]}{1565}{obsolet}{}
\functionlistentry{double}{AngleVecRn}{double *v1,double *v2,int dim}{1573}{obsolet}{}
\functionlistentry{int}{CalcCentralMoments}{const double m[15],double mc[15]}{1613}{obsolet}{}
\functionlistentry{double*}{CrossProdVec}{double v1[3],double v2[3],double v3[3]}{1563}{obsolet}{}
\functionlistentry{int}{FitAffineTrans}{PointList pl1,PointList pl2,double tr[3][3]}{1589}{obsolet}{}
\functionlistentry{int}{FitCircleMoments}{double moment[15],double \&x0,double \&y0,double \&radius}{1627}{obsolet}{}
\functionlistentry{int}{FitCircularSegmentMoments}{double moment[15],double circle\_par[3],double line\_start[2],double line\_end[2]}{1628}{obsolet}{}
\functionlistentry{int}{FitEllipseMoments}{double moment[15],double ell\_par[5]}{1629}{obsolet}{}
\functionlistentry{int}{FitEllipticalSegmentMoments}{double moment[15],double ell\_par[5],double line\_start[2],double line\_end[2]}{1630}{obsolet}{}
\functionlistentry{int}{FitParallelogramMoments}{double moment[15],double corner[4][2]}{1624}{obsolet}{}
\functionlistentry{int}{FitParallelogramMoments}{double moment[15],double corner[4][2], double \& guetemass}{1625}{obsolet}{}
\functionlistentry{int}{FitProjectiveTrans}{PointList pl1,PointList pl2,double tr[3][3]}{1590}{obsolet}{}
\functionlistentry{int}{FitQuadrangleMoments}{double moment[15],double corner[4][2]}{1626}{obsolet}{}
\functionlistentry{int}{FitRectangleMoments}{double moment[15],double corner[4][2]}{1623}{obsolet}{}
\functionlistentry{int}{FitSuperEllipseMoments}{double moment[15],double \&c1,double \&f1,double tr1[3][3],double \&c2,double \&f2,double tr2[3][3]}{1631}{obsolet}{}
\functionlistentry{int}{FitTriangleMoments}{double moment[15],double corner[3][2]}{1622}{obsolet}{}
\functionlistentry{int}{FreeMatrix}{MatrixStruct mat}{1576}{obsolet}{}
\functionlistentry{MatrixStruct}{GetStatisticCor}{Statistic st,MatrixStruct cor}{1600}{obsolet}{}
\functionlistentry{MatrixStruct}{GetStatisticCov}{Statistic st,MatrixStruct cov}{1599}{obsolet}{}
\functionlistentry{int}{GetStatisticDim}{Statistic st,int *dim}{1596}{obsolet}{}
\functionlistentry{int}{GetStatisticMean}{Statistic st,double *mean}{1598}{obsolet}{}
\functionlistentry{int}{GetStatisticWeight}{Statistic st,double *sweight}{1597}{obsolet}{}
\functionlistentry{Statistic}{InitStatistic}{int dim}{1594}{obsolet}{}
\functionlistentry{int}{InitTrans}{double tr[3][3]}{1584}{obsolet}{}
\functionlistentry{MatrixStruct}{InvertMat}{MatrixStruct A,MatrixStruct B}{1582}{obsolet}{}
\functionlistentry{int}{InvertTrans}{double tr[3][3]}{1588}{obsolet}{}
\functionlistentry{int}{IsMatrix}{MatrixStruct mat}{1577}{obsolet}{}
\functionlistentry{double}{LengthVec}{double v[3]}{1557}{obsolet}{}
\functionlistentry{double}{LengthVecRn}{double *v,int dim}{1567}{obsolet}{}
\functionlistentry{int}{MomentPolygon}{PointList p,double m[15],double s[2]}{1603}{obsolet}{}
\functionlistentry{int}{MomentPolygon}{const \hyperlink{Matrix}{Matrix} \&p,double m[15],double s[2]}{1604}{obsolet}{}
\functionlistentry{int}{MomentRegion}{\hyperlink{Contur}{Contur} c, double m[15], double s[2]}{1606}{obsolet}{}
\functionlistentry{MatrixStruct}{MoveMat}{MatrixStruct m1,MatrixStruct m2}{1578}{obsolet}{}
\functionlistentry{double*}{MoveVec}{double v1[3],double v2[3]}{1556}{obsolet}{}
\functionlistentry{double*}{MoveVecRn}{double *v1,int dim,double *v2}{1566}{obsolet}{}
\functionlistentry{MatrixStruct}{MulMat}{MatrixStruct m1,MatrixStruct m2,MatrixStruct m3}{1580}{obsolet}{}
\functionlistentry{int}{MulMatVec}{MatrixStruct A,double *b,double *x}{1581}{obsolet}{}
\functionlistentry{MatrixStruct}{NewMatrix}{int typ,int rows,int columns}{1575}{obsolet}{}
\functionlistentry{int}{NormalizeMoments}{const double m1[15],double m2[15]}{1614}{obsolet}{}
\functionlistentry{double*}{NormVec}{double v1[3],double v2[3]}{1560}{obsolet}{}
\functionlistentry{double*}{NormVecRn}{double *v1,int dim,double *v2}{1570}{obsolet}{}
\functionlistentry{int}{PointListMoment}{PointList pl,int a1,int a2,double m[15],double s[2]}{1605}{obsolet}{}
\functionlistentry{int}{PolyNormMoments}{double m[21],double maf[21],double atr[3][3]}{1618}{obsolet}{}
\functionlistentry{void}{PrintVecRn}{char *str,double *v,int dim}{1574}{obsolet}{}
\functionlistentry{int}{PutStatistic}{Statistic st,double v[dim],double weight}{1595}{obsolet}{}
\functionlistentry{Statistic}{ReadStatistic}{char *file}{1602}{obsolet}{}
\functionlistentry{int}{RotateMoments}{const double m1[15],double c,double s, double m2[15]}{1612}{obsolet}{}
\functionlistentry{int}{RotTrans}{double x0, double y0, double phi, double tr[3][3]}{1586}{obsolet}{}
\functionlistentry{int}{ScaleMoments}{const double m1[15],double a,double b, double m2[15]}{1611}{obsolet}{}
\functionlistentry{int}{ScaleTrans}{double x0, double y0, double a, double b, double tr[3][3]}{1587}{obsolet}{}
\functionlistentry{double*}{ScaleVec}{double v1[3],double fac,double v2[3]}{1561}{obsolet}{}
\functionlistentry{double*}{ScaleVecRn}{double *v1,int dim,double fac,double *v2}{1571}{obsolet}{}
\functionlistentry{double}{ScalProdVec}{double v1[3],double v2[3]}{1562}{obsolet}{}
\functionlistentry{double}{ScalProdVecRn}{double *v1,double *v2,int dim}{1572}{obsolet}{}
\functionlistentry{int}{ShiftTrans}{double x0, double y0, double tr[3][3]}{1585}{obsolet}{}
\functionlistentry{MatrixStruct}{SortMatrix}{MatrixStruct A,int col,int mode}{1583}{obsolet}{}
\functionlistentry{double}{SpatProdVec}{double v1[3],double v2[3],double v3[3]}{1564}{obsolet}{}
\functionlistentry{double*}{SubVec}{double v1[3],double v2[3],double v3[3]}{1559}{obsolet}{}
\functionlistentry{double*}{SubVecRn}{double *v1,double *v2,int dim,double *v3}{1569}{obsolet}{}
\functionlistentry{\hyperlink{Contur}{Contur}}{TransContur}{\hyperlink{Contur}{Contur} c,double tr[3][3]}{1593}{obsolet}{}
\functionlistentry{int}{TransImg}{\hyperlink{Image}{Image} imgs,double tr[3][3],int mode,\hyperlink{Image}{Image} imgd}{1592}{obsolet}{}
\functionlistentry{int}{TranslateMoments}{const double m1[15],double x,double y,double m2[15]}{1607}{obsolet}{}
\functionlistentry{MatrixStruct}{TranspMat}{MatrixStruct m1,MatrixStruct m2}{1579}{obsolet}{}
\functionlistentry{double*}{TransPoint}{double p1[2],double tr[3][3],double p2[2]}{1591}{obsolet}{}
\functionlistentry{int}{WriteStatistic}{Statistic st,char *file}{1601}{obsolet}{}
\functionlistentry{int}{XShearMoments}{const double m[15],double a,double ms[15]}{1609}{obsolet}{}
\functionlistentry{int}{YShearMoments}{const double m1[15],double b,double m2[15]}{1610}{obsolet}{}

 
\newpage
\subsection{Alphabetisch sortierte Funktionsliste}
\makeatletter{}\label{FunktionsListe}

\letterlabel{Ac}
\letterlabel{A}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ac}
\letterref{Ad}
\letterref{Af}
\letterref{Al}
\letterref{An}
\letterref{Ap}
\letterref{Ar}
\letterref{As}
\letterlabelend{Ac}
\functionlistentry{}{accu1::accu1}{}{917}{statistics}{}
\functionlistentry{}{accu1::accu1}{int n,double min=0.0,double max=1.0,bool mod=false}{919}{statistics}{}
\functionlistentry{void}{accu1::Add}{double val}{923}{statistics}{}
\functionlistentry{void}{accu1::getMax}{double \&val}{927}{statistics}{}
\functionlistentry{void}{accu1::getMax}{double \&val,double \&ct}{928}{statistics}{}
\functionlistentry{void}{accu1::setDim}{int n,double min=0.0,double max=1.0,bool mod=false}{921}{statistics}{}
\functionlistentry{}{accu2::accu2}{}{918}{statistics}{}
\functionlistentry{}{accu2::accu2}{int n1,double min1,double max1,bool mod1, int n1,double min2, double max2,bool mod2,int smear=1}{920}{statistics}{}
\functionlistentry{void}{accu2::Add}{double val1,double val2}{924}{statistics}{}
\functionlistentry{void}{accu2::Add}{const \hyperlink{Vector}{Vector} \&v}{925}{statistics}{}
\functionlistentry{void}{accu2::Add}{\hyperlink{Point}{Point} v}{926}{statistics}{}
\functionlistentry{void}{accu2::getMax}{double \&val1,double \&val2}{929}{statistics}{}
\functionlistentry{void}{accu2::getMax}{double \&val1,double \&val2,double \&ct}{930}{statistics}{}
\functionlistentry{\hyperlink{Point}{Point}}{accu2::getMax}{}{931}{statistics}{}
\functionlistentry{\hyperlink{Point}{Point}}{accu2::getMax}{double \&ct}{932}{statistics}{}
\functionlistentry{void}{accu2::setDim}{int dim,int n,double min=0.0,double max=1.0,bool mod=false}{922}{statistics}{}

\letterlabel{Ad}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ac}
\letterref{Ad}
\letterref{Af}
\letterref{Al}
\letterref{An}
\letterref{Ap}
\letterref{Ar}
\letterref{As}
\letterlabelend{Ad}
\functionlistentry{int}{AddImg}{const \hyperlink{Image}{Image} \&img1,const \hyperlink{Image}{Image} \&img2, const \hyperlink{Image}{Image} \&dest,int mode=MD\_NORMALIZE}{1087}{processing}{}
\functionlistentry{int}{AddImgD}{ImageD img1,ImageD img2,ImageD dest}{1098}{processing}{}
\functionlistentry{double*}{AddVec}{double v1[3],double v2[3],double v3[3]}{1558}{obsolet}{}
\functionlistentry{double*}{AddVecRn}{double *v1,double *v2,int dim,double *v3}{1568}{obsolet}{}

\letterlabel{Af}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ac}
\letterref{Ad}
\letterref{Af}
\letterref{Al}
\letterref{An}
\letterref{Ap}
\letterref{Ar}
\letterref{As}
\letterlabelend{Af}
\functionlistentry{int}{AffinAlgebraicInvar}{double m[15],double flu[4]}{1615}{obsolet}{}
\functionlistentry{\hyperlink{Trafo}{Trafo}}{AffineFit}{const \hyperlink{Moments}{Moments} \&m1,const \hyperlink{Moments}{Moments} \&m2}{839}{moments}{}
\functionlistentry{double}{AffinFitMoments}{double m1[15],double m2[15],double tr[3][3]}{1620}{obsolet}{}
\functionlistentry{double}{AffinFitPolygons}{PointList pl1,PointList pl2,double tr[3][3]}{1621}{obsolet}{}
\functionlistentry{int}{AffinHuInvar}{double m[15],double hu[7]}{1616}{obsolet}{}
\functionlistentry{int}{AffinIterateMoments}{double m[21],double maf[21],double atr[3][3]}{1619}{obsolet}{}
\functionlistentry{int}{AffinNormMoments}{double m[21],double maf[21],double atr[3][3]}{1617}{obsolet}{}
\functionlistentry{int}{AffinTransMoments}{const double m1[15],double tr[3][3],double m2[15]}{1608}{obsolet}{}

\letterlabel{Al}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ac}
\letterref{Ad}
\letterref{Af}
\letterref{Al}
\letterref{An}
\letterref{Ap}
\letterref{Ar}
\letterref{As}
\letterlabelend{Al}
\functionlistentry{void}{Alpha}{int mode}{1418}{genericTools}{}
\functionlistentry{int}{AlphaSizeX}{void}{1425}{genericTools}{}
\functionlistentry{int}{AlphaSizeY}{void}{1426}{genericTools}{}

\letterlabel{An}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ac}
\letterref{Ad}
\letterref{Af}
\letterref{Al}
\letterref{An}
\letterref{Ap}
\letterref{Ar}
\letterref{As}
\letterlabelend{An}
\functionlistentry{double}{AngleVec}{double v1[3],double v2[3]}{1565}{obsolet}{}
\functionlistentry{double}{AngleVecRn}{double *v1,double *v2,int dim}{1573}{obsolet}{}

\letterlabel{Ap}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ac}
\letterref{Ad}
\letterref{Af}
\letterref{Al}
\letterref{An}
\letterref{Ap}
\letterref{Ar}
\letterref{As}
\letterlabelend{Ap}
\functionlistentry{int}{Append}{const \hyperlink{Vector}{Vector} \&v}{266}{datastructures}{}

\letterlabel{Ar}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ac}
\letterref{Ad}
\letterref{Af}
\letterref{Al}
\letterref{An}
\letterref{Ap}
\letterref{Ar}
\letterref{As}
\letterlabelend{Ar}
\functionlistentry{double}{Arcus}{double degree}{1348}{numeric}{}
\functionlistentry{double}{AreaPolygon}{PointList pl}{1379}{numeric}{}
\functionlistentry{double}{AreaPolygon}{const \hyperlink{Matrix}{Matrix} \&pl}{1380}{numeric}{}

\letterlabel{As}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ac}
\letterref{Ad}
\letterref{Af}
\letterref{Al}
\letterref{An}
\letterref{Ap}
\letterref{Ar}
\letterref{As}
\letterlabelend{As}
\functionlistentry{int}{AssignCalibPattern}{\hyperlink{Image}{Image} \&image, \hyperlink{Matrix}{Matrix} \&imagepoints, \hyperlink{Matrix}{Matrix} \&worldpoints, \hyperlink{Image}{Image} debug\_image = \hyperlink{Image}{Image}(), \hyperlink{Image}{Image} debug\_mark = \hyperlink{Image}{Image}()}{794}{cameraModel}{}
\functionlistentry{int}{AssignCalibPattern}{\hyperlink{Image}{Image} \&image, \hyperlink{Matrix}{Matrix} \&imagepoints, \hyperlink{Matrix}{Matrix} \&worldpoints, \hyperlink{Camera}{Camera} \&c, \hyperlink{Image}{Image} debug\_image = \hyperlink{Image}{Image}(), \hyperlink{Image}{Image} debug\_mark = \hyperlink{Image}{Image}()}{795}{cameraModel}{}
\functionlistentry{int}{AssignFunction}{const \hyperlink{Matrix}{Matrix} \&cost,IMatrix \&pairs,int mode}{1261}{registration}{}

\letterlabel{Ba}
\letterlabel{B}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ba}
\letterref{Be}
\letterref{Bi}
\letterref{Bo}
\letterlabelend{Ba}
\functionlistentry{int}{Bairstow}{const \hyperlink{Vector}{Vector} \&para,\hyperlink{Matrix}{Matrix}\& result,int inumber = 1000}{1399}{numeric}{}

\letterlabel{Be}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ba}
\letterref{Be}
\letterref{Bi}
\letterref{Bo}
\letterlabelend{Be}
\functionlistentry{void}{Bell}{void}{1424}{genericTools}{}

\letterlabel{Bi}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ba}
\letterref{Be}
\letterref{Bi}
\letterref{Bo}
\letterlabelend{Bi}
\functionlistentry{int}{BinImg}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&dest,int thr=1,int val=-1}{1064}{processing}{}
\functionlistentry{int}{BinImg}{\hyperlink{Image}{Image} \&src,int thr=1}{1065}{processing}{}

\letterlabel{Bo}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ba}
\letterref{Be}
\letterref{Bi}
\letterref{Bo}
\letterlabelend{Bo}
\functionlistentry{int}{BoxImg}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&dest,int n=3}{343}{filter}{}
\functionlistentry{int}{BoxImg}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&dest,int nx,int ny}{344}{filter}{}

\letterlabel{Ca}
\letterlabel{C}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ca}
\letterref{Ce}
\letterref{Ch}
\letterref{Ci}
\letterref{Cl}
\letterref{Co}
\letterref{Cr}
\letterref{Cu}
\letterlabelend{Ca}
\functionlistentry{int}{CalcCentralMoments}{const double m[15],double mc[15]}{1613}{obsolet}{}
\functionlistentry{\hyperlink{Contur}{Contur}}{CalcContur}{\hyperlink{Image}{Image} iv,\hyperlink{Image}{Image} io,object\_rc (*cls)(),int thr,int ps[2],int lng=0,object\_rc marked=isunderground,object\_rc outside=isunderground}{440}{conturs}{}
\functionlistentry{\hyperlink{Contur}{Contur}}{CalcContur}{\hyperlink{Image}{Image} iv,\hyperlink{Image}{Image} io,object\_rc (*cls)(),int thr,const IPoint \&ps,int lng=0,object\_rc marked=isunderground,object\_rc outside=isunderground}{441}{conturs}{}
\functionlistentry{int}{CalcDirectionImg}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&dir,int dsize=11}{360}{filter}{}
\functionlistentry{int}{CalcDirectionImg}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&dir,int dsize=11,ImageD eval}{361}{filter}{}
\functionlistentry{int}{CalcDirectionStructImg}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&dir,int dsize=11}{362}{filter}{}
\functionlistentry{int}{CalcDirectionStructImg}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&dir,int dsize=11,ImageD lambda1,ImageD lambda2}{363}{filter}{}
\functionlistentry{\hyperlink{Contur}{Contur}}{CalcGradContur}{\hyperlink{Image}{Image} iv,\hyperlink{Image}{Image} io,int thr,int maxg,int ps[2],int lng}{449}{conturs}{}
\functionlistentry{\hyperlink{Contur}{Contur}}{CalcRidgeContur}{\hyperlink{Image}{Image} imgv,\hyperlink{Image}{Image} imgo,int thr,int ps[2],int lng}{452}{conturs}{}
\functionlistentry{double}{CalcThreshold}{const \hyperlink{Hist}{Hist} \&h}{432}{conturs}{}
\functionlistentry{double}{CalcThreshold}{const \hyperlink{Hist}{Hist} \&h,double \&discmax}{433}{conturs}{}
\functionlistentry{int}{CalcThreshold}{const \hyperlink{Histogram}{Histogram} \&h}{434}{conturs}{}
\functionlistentry{int}{CalcThreshold}{const \hyperlink{Histogram}{Histogram} \&h,double \&discmax}{435}{conturs}{}
\functionlistentry{int}{CalcThreshold}{\hyperlink{Image}{Image} img}{436}{conturs}{}
\functionlistentry{int}{CalcThreshold}{\hyperlink{Image}{Image} img,double \&discmax,int diff=1}{437}{conturs}{}
\functionlistentry{int}{Calibrate}{vector$<$\hyperlink{Image}{Image}$>$ \&images, \hyperlink{Camera}{Camera} \&c, bool dist=true, \hyperlink{Image}{Image} debug\_image = \hyperlink{Image}{Image}(), \hyperlink{Image}{Image} debug\_mark = \hyperlink{Image}{Image}()}{792}{cameraModel}{}
\functionlistentry{int}{Calibrate}{vector$<$\hyperlink{Image}{Image}$>$ \&images, vector$<$\hyperlink{Camera}{Camera}$>$ \&cv, bool dist=true, \hyperlink{Image}{Image} debug\_image = \hyperlink{Image}{Image}(), \hyperlink{Image}{Image} debug\_mark = \hyperlink{Image}{Image}()}{793}{cameraModel}{}
\functionlistentry{int}{CalibrateWithHomographies}{vector$<$\hyperlink{Trafo}{Trafo}$>$ \&H, \hyperlink{Camera}{Camera} \&c}{799}{cameraModel}{}
\functionlistentry{int}{CalibrateWithHomographies}{vector$<$\hyperlink{Trafo}{Trafo}$>$ \&H, vector$<$\hyperlink{Camera}{Camera}$>$ \&cv}{800}{cameraModel}{}
\functionlistentry{int}{CalibrateWithPattern}{vector$<$\hyperlink{Matrix}{Matrix}$>$ \&imagepoints, vector$<$\hyperlink{Matrix}{Matrix}$>$ \&worldpoints, \hyperlink{Camera}{Camera} \&c}{797}{cameraModel}{}
\functionlistentry{int}{CalibrateWithPattern}{vector$<$\hyperlink{Matrix}{Matrix}$>$ \&imagepoints, vector$<$\hyperlink{Matrix}{Matrix}$>$ \&worldpoints, vector$<$\hyperlink{Camera}{Camera}$>$ \&cv}{798}{cameraModel}{}
\functionlistentry{}{Camera::Camera}{int dtyp=1}{770}{cameraModel}{}
\functionlistentry{}{Camera::Camera}{const \hyperlink{Vector}{Vector} \&v,int dtyp=1}{771}{cameraModel}{}
\functionlistentry{}{Camera::Camera}{const \hyperlink{Camera}{Camera} \&c}{772}{cameraModel}{}
\functionlistentry{const Distortion}{Camera::Dist}{}{779}{cameraModel}{}
\functionlistentry{int}{Camera::DistType}{}{780}{cameraModel}{}
\functionlistentry{void}{Camera::Get}{double \&fp,double \&ap,double \&sp,double \&u0p,double \&v0p}{777}{cameraModel}{}
\functionlistentry{void}{Camera::GetExt}{double \&dxp,double \&dyp,double \&dzp, double \&ap,double \&bp,double \&cp}{778}{cameraModel}{}
\functionlistentry{\hyperlink{Vector}{Vector}}{Camera::MakeVector}{int what=\hyperlink{Camera}{Camera}::all}{782}{cameraModel}{}
\functionlistentry{void}{Camera::Set}{double fp,double ap,double sp, double u0p,double v0p,const Distortion \&d}{774}{cameraModel}{}
\functionlistentry{void}{Camera::Set}{double fp,double ap,double sp,double u0p,double v0p}{775}{cameraModel}{}
\functionlistentry{void}{Camera::Set}{const \hyperlink{Vector}{Vector} \&v,int what=\hyperlink{Camera}{Camera}::all}{783}{cameraModel}{}
\functionlistentry{void}{Camera::SetDist}{const Distortion \&d}{781}{cameraModel}{}
\functionlistentry{void}{Camera::SetExt}{double dxp,double dyp,double dzp,double ap,double bp,double cp}{776}{cameraModel}{}
\functionlistentry{string}{Camera::toString}{const string \&del}{791}{cameraModel}{}
\functionlistentry{\hyperlink{Vector}{Vector}}{Camera::Transform}{const \hyperlink{Vector}{Vector} \&v}{784}{cameraModel}{}
\functionlistentry{\hyperlink{Point}{Point}}{Camera::Transform}{const \hyperlink{Vector3d}{Vector3d} \&v}{785}{cameraModel}{}
\functionlistentry{\hyperlink{Point}{Point}}{Camera::Transform}{const Point3d \&v}{786}{cameraModel}{}
\functionlistentry{void}{Camera::Transform}{double x,double y,double z,double \&u,double \&v}{787}{cameraModel}{}

\letterlabel{Ce}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ca}
\letterref{Ce}
\letterref{Ch}
\letterref{Ci}
\letterref{Cl}
\letterref{Co}
\letterref{Cr}
\letterref{Cu}
\letterlabelend{Ce}
\functionlistentry{int}{CepstrumImgD}{ImageD imgs,ImageD imgd}{1210}{signalTrafo}{}

\letterlabel{Ch}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ca}
\letterref{Ce}
\letterref{Ch}
\letterref{Ci}
\letterref{Cl}
\letterref{Co}
\letterref{Cr}
\letterref{Cu}
\letterlabelend{Ch}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{CholeskyDecomposition}{const \hyperlink{Matrix}{Matrix} \&m}{1116}{matrixAlgebra}{}
\functionlistentry{double}{CholeskyDeterminant}{const \hyperlink{Matrix}{Matrix} \&m}{1119}{matrixAlgebra}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{CholeskyInverse}{const \hyperlink{Matrix}{Matrix} \&m}{1115}{matrixAlgebra}{}

\letterlabel{Ci}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ca}
\letterref{Ce}
\letterref{Ch}
\letterref{Ci}
\letterref{Cl}
\letterref{Co}
\letterref{Cr}
\letterref{Cu}
\letterlabelend{Ci}
\functionlistentry{}{Circle::Circle}{}{514}{geoObject}{}
\functionlistentry{}{Circle::Circle}{const \hyperlink{Circle}{Circle} \&c}{515}{geoObject}{}
\functionlistentry{}{Circle::Circle}{double xm,double ym,double r}{516}{geoObject}{}
\functionlistentry{}{Circle::Circle}{\hyperlink{Point}{Point} m,double r}{517}{geoObject}{}
\functionlistentry{explicit}{Circle::Circle}{const \hyperlink{Vector}{Vector} \&c}{518}{geoObject}{}
\functionlistentry{explicit}{Circle::Circle}{const double d[]}{519}{geoObject}{}
\functionlistentry{double}{Circle::getR}{}{520}{geoObject}{}
\functionlistentry{void}{Circle::setR}{double val}{521}{geoObject}{}
\functionlistentry{\hyperlink{Contur}{Contur}}{CircleContur}{double par[3]}{1332}{graphics}{}
\functionlistentry{}{CircleSeg::CircleSeg}{}{522}{geoObject}{}
\functionlistentry{}{CircleSeg::CircleSeg}{const \hyperlink{CircleSeg}{CircleSeg} \&c}{523}{geoObject}{}
\functionlistentry{}{CircleSeg::CircleSeg}{double xm,double ym,double r, double phi1,double phi2}{524}{geoObject}{}
\functionlistentry{}{CircleSeg::CircleSeg}{\hyperlink{Point}{Point} p,double r,double phi1,double phi2}{525}{geoObject}{}
\functionlistentry{explicit}{CircleSeg::CircleSeg}{const \hyperlink{Vector}{Vector} \&c}{526}{geoObject}{}
\functionlistentry{explicit}{CircleSeg::CircleSeg}{const double d[]}{527}{geoObject}{}
\functionlistentry{double }{CircleSeg::getPhi1}{}{528}{geoObject}{}
\functionlistentry{double}{CircleSeg::getPhi2}{}{530}{geoObject}{}
\functionlistentry{void}{CircleSeg::setPhi1}{double val}{529}{geoObject}{}
\functionlistentry{void}{CircleSeg::setPhi2}{double val}{531}{geoObject}{}
\functionlistentry{\hyperlink{Contur}{Contur}}{CircleSegmentContur}{double par[5]}{1334}{graphics}{}

\letterlabel{Cl}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ca}
\letterref{Ce}
\letterref{Ch}
\letterref{Ci}
\letterref{Cl}
\letterref{Co}
\letterref{Cr}
\letterref{Cu}
\letterlabelend{Cl}
\functionlistentry{}{Classifier::Classifier}{}{942}{classification}{}
\functionlistentry{}{Classifier::Classifier}{int classes,int dimension}{943}{classification}{}
\functionlistentry{}{Classifier::Classifier}{const \hyperlink{Classifier}{Classifier} \&c}{944}{classification}{}
\functionlistentry{int}{Classifier::Classify}{const vector\textless {}double\textgreater  \&feat}{958}{classification}{}
\functionlistentry{int}{Classifier::Classify}{const \hyperlink{Vector}{Vector} \&feat}{959}{classification}{}
\functionlistentry{int}{Classifier::Classify}{\hyperlink{Matrix}{Matrix} \&m}{960}{classification}{}
\functionlistentry{int}{Classifier::Classify}{const \hyperlink{Matrix}{Matrix} \&m,IVector \&cl}{961}{classification}{}
\functionlistentry{int}{Classifier::Finish}{}{953}{classification}{}
\functionlistentry{int}{Classifier::Init}{}{945}{classification}{}
\functionlistentry{int}{Classifier::Init}{int classes,int dimension}{946}{classification}{}
\functionlistentry{int}{Classifier::Read}{const string \&fn}{963}{classification}{}
\functionlistentry{double}{Classifier::Test}{const vector\textless {}\hyperlink{ClassSample}{ClassSample}\textgreater  \&samples}{954}{classification}{}
\functionlistentry{double}{Classifier::Test}{const \hyperlink{Matrix}{Matrix} \&m}{955}{classification}{}
\functionlistentry{double}{Classifier::Test}{const \hyperlink{Matrix}{Matrix} \&features,const IVector \&classnr}{956}{classification}{}
\functionlistentry{double}{Classifier::Test}{const \hyperlink{Matrix}{Matrix} \&m,\hyperlink{Matrix}{Matrix} \&f}{957}{classification}{}
\functionlistentry{int}{Classifier::Train}{const \hyperlink{ClassSample}{ClassSample} \&sample}{947}{classification}{}
\functionlistentry{int}{Classifier::Train}{int cl,const vector\textless {}double\textgreater  \&feat}{948}{classification}{}
\functionlistentry{int}{Classifier::Train}{int cl,const \hyperlink{Vector}{Vector} \&feat}{949}{classification}{}
\functionlistentry{int}{Classifier::Train}{const vector\textless {}ClassSamples\textgreater  \&samples}{950}{classification}{}
\functionlistentry{int}{Classifier::Train}{const \hyperlink{Matrix}{Matrix} \&m}{951}{classification}{}
\functionlistentry{int}{Classifier::Train}{const \hyperlink{Matrix}{Matrix} \&features,const IVector \&classnr}{952}{classification}{}
\functionlistentry{int}{Classifier::Write}{const string \&fn}{962}{classification}{}
\functionlistentry{}{ClassifierB2::ClassifierB2}{}{978}{classification}{}
\functionlistentry{}{ClassifierB2::ClassifierB2}{int classes,int dimension, double p0,double p1,double c01,double c10}{979}{classification}{}
\functionlistentry{}{ClassifierB2::ClassifierB2}{const \hyperlink{ClassifierB2}{ClassifierB2} \&c}{980}{classification}{}
\functionlistentry{int}{ClassifierB2::Init}{int classes,int dimension,double p0,double p0,double c01, double c10}{981}{classification}{}
\functionlistentry{}{ClassifierBayes::ClassifierBayes}{}{982}{classification}{}
\functionlistentry{}{ClassifierBayes::ClassifierBayes}{int classes,int dimension, bool rejection=false, int apm=APM\_EQUAL}{983}{classification}{}
\functionlistentry{}{ClassifierBayes::ClassifierBayes}{int classes, const vector\textless {}double\textgreater  \& app, bool rejection}{984}{classification}{}
\functionlistentry{}{ClassifierBayes::ClassifierBayes}{const \hyperlink{ClassifierBayes}{ClassifierBayes} \&c}{985}{classification}{}
\functionlistentry{int}{ClassifierBayes::Init}{int classes,int dimension}{986}{classification}{}
\functionlistentry{int}{ClassifierBayes::SoftClassify}{const \hyperlink{Vector}{Vector} \&feat, \hyperlink{Vector}{Vector} \&softclasses, int measure=1}{987}{classification}{}
\functionlistentry{}{ClassifierKNN::ClassifierKNN}{}{975}{classification}{}
\functionlistentry{}{ClassifierKNN::ClassifierKNN}{int classes,int dimension, int neighbours=3, bool norm=false, int voteMode=1}{976}{classification}{}
\functionlistentry{void}{ClassifierKNN::Init}{int classes,int dimension,bool norm = false,int voteMode=1}{977}{classification}{}
\functionlistentry{}{ClassifierMD::ClassifierMD}{}{968}{classification}{}
\functionlistentry{}{ClassifierMD::ClassifierMD}{int classes,int dimension}{969}{classification}{}
\functionlistentry{}{ClassifierMD::ClassifierMD}{const \hyperlink{ClassifierMD}{ClassifierMD} \&c}{970}{classification}{}
\functionlistentry{}{ClassifierNN::ClassifierNN}{}{971}{classification}{}
\functionlistentry{}{ClassifierNN::ClassifierNN}{int classes,int dimension,bool norm=false}{972}{classification}{}
\functionlistentry{}{ClassifierNN::ClassifierNN}{const \hyperlink{ClassifierNN}{ClassifierNN} \&c}{973}{classification}{}
\functionlistentry{void}{ClassifierNN::Init}{int classes,int dimension,bool norm = false}{974}{classification}{}
\functionlistentry{}{ClassifierNormal::ClassifierNormal}{}{964}{classification}{}
\functionlistentry{}{ClassifierNormal::ClassifierNormal}{int classes,int dimension}{965}{classification}{}
\functionlistentry{void}{ClassifierNormal::doNormalization}{int mode = normalizeCenter $|$ normalizeScaling $|$ normalizeIsotropic}{966}{classification}{}
\functionlistentry{void}{ClassifierNormal::normalize}{vector\textless {}double\textgreater  \&feat}{967}{classification}{}
\functionlistentry{}{ClassSample::ClassSample}{}{938}{classification}{}
\functionlistentry{}{ClassSample::ClassSample}{int c, const vector\textless {}double\textgreater  \& f}{939}{classification}{}
\functionlistentry{double \&}{ClassSample::operator[]}{int i}{940}{classification}{}
\functionlistentry{int}{ClassSample::size}{}{941}{classification}{}
\functionlistentry{void}{Clear}{}{237}{datastructures}{}
\functionlistentry{void}{ClearAlpha}{void}{1421}{genericTools}{}
\functionlistentry{int}{ClearImg}{const \hyperlink{Image}{Image} \&img}{1083}{processing}{}
\functionlistentry{int}{ClearImgD}{ImageD img}{1095}{processing}{}
\functionlistentry{void}{CloseAlpha}{void}{1417}{genericTools}{}
\functionlistentry{double}{ClosestPointLineSeg}{double p[2],double ls0[2],double ls1[2],double pf[2]}{1374}{numeric}{}
\functionlistentry{int}{ClosingImg}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&dest,int nx=3, int ny=-1}{381}{filter}{}
\functionlistentry{int}{ClosingImg}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&dest,const IMatrix \&mask}{382}{filter}{}

\letterlabel{Co}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ca}
\letterref{Ce}
\letterref{Ch}
\letterref{Ci}
\letterref{Cl}
\letterref{Co}
\letterref{Cr}
\letterref{Cu}
\letterlabelend{Co}
\functionlistentry{\hyperlink{Image}{Image}}{ColorImage::blueImage}{void}{29}{Images}{}
\functionlistentry{}{ColorImage::ColorImage}{}{15}{Images}{}
\functionlistentry{}{ColorImage::ColorImage}{const \hyperlink{ColorImage}{ColorImage} \&img}{16}{Images}{}
\functionlistentry{}{ColorImage::ColorImage}{const \hyperlink{ColorImage}{ColorImage} \&img,const \hyperlink{Window}{Window} \&w,const string \&title=''''}{32}{Images}{}
\functionlistentry{void}{ColorImage::copy}{const \hyperlink{ColorImage}{ColorImage} \&src}{19}{Images}{}
\functionlistentry{void}{ColorImage::create}{int xsize,int ysize,int maxval,const string \&title=''''}{17}{Images}{}
\functionlistentry{void}{ColorImage::create}{const \hyperlink{ColorImage}{ColorImage} \&img,const string \&title=''''}{18}{Images}{}
\functionlistentry{static \hyperlink{ColorImage}{ColorImage}}{ColorImage::createColorImage}{int sizeX, int sizeY, int maxValue, const std::string \&title = ''''}{20}{Images}{}
\functionlistentry{static \hyperlink{ColorImage}{ColorImage}}{ColorImage::createColorImage}{const \hyperlink{ColorImage}{ColorImage} \&src, bool copy, const std::string \&title = ''''}{21}{Images}{}
\functionlistentry{\hyperlink{ColorValue}{ColorValue}}{ColorImage::getPixel}{int x,int y}{36}{Images}{}
\functionlistentry{\hyperlink{ColorValue}{ColorValue}}{ColorImage::getPixel}{IPoint p}{37}{Images}{}
\functionlistentry{\hyperlink{ColorValue}{ColorValue}}{ColorImage::getPixelUnchecked}{int x,int y}{40}{Images}{}
\functionlistentry{\hyperlink{ColorValue}{ColorValue}}{ColorImage::getPixelUnchecked}{IPoint p}{41}{Images}{}
\functionlistentry{\hyperlink{Image}{Image}}{ColorImage::greenImage}{void}{28}{Images}{}
\functionlistentry{bool}{ColorImage::inside}{const IPoint p}{61}{Images}{}
\functionlistentry{bool}{ColorImage::inside}{int x,int y}{62}{Images}{}
\functionlistentry{bool}{ColorImage::inside}{const \hyperlink{Window}{Window} \&w}{63}{Images}{}
\functionlistentry{bool}{ColorImage::isValid}{}{25}{Images}{}
\functionlistentry{\hyperlink{ColorImage}{ColorImage}}{ColorImage::operator()}{const \hyperlink{Window}{Window} \&w}{33}{Images}{}
\functionlistentry{\hyperlink{Image}{Image}}{ColorImage::redImage}{void}{27}{Images}{}
\functionlistentry{void}{ColorImage::setPixel}{int x,int y,\hyperlink{ColorValue}{ColorValue} cv}{48}{Images}{}
\functionlistentry{void}{ColorImage::setPixel}{IPoint p,\hyperlink{ColorValue}{ColorValue} cv}{49}{Images}{}
\functionlistentry{void}{ColorImage::setPixelUnchecked}{int x,int y,\hyperlink{ColorValue}{ColorValue} cv}{52}{Images}{}
\functionlistentry{void}{ColorImage::setPixelUnchecked}{IPoint p,\hyperlink{ColorValue}{ColorValue} cv}{53}{Images}{}
\functionlistentry{int}{ColorImageToHsi}{const \hyperlink{ColorImage}{ColorImage} \&src, const \hyperlink{Image}{Image} \&hue, const \hyperlink{Image}{Image} \&saturation, const \hyperlink{Image}{Image} \&intensity}{1107}{processing}{}
\functionlistentry{int}{ColorImageToLab}{const \hyperlink{ColorImage}{ColorImage} \&src, const \hyperlink{Image}{Image} \&lImg, const \hyperlink{Image}{Image} \&aImg, const \hyperlink{Image}{Image} \&bImg}{1109}{processing}{}
\functionlistentry{int}{ColorImageToYuv}{const \hyperlink{ColorImage}{ColorImage} \&src, const \hyperlink{Image}{Image} \&y, const \hyperlink{Image}{Image} \&u, const \hyperlink{Image}{Image} \&v}{1111}{processing}{}
\functionlistentry{double}{ColorValue::abs}{}{290}{datastructures}{}
\functionlistentry{double}{ColorValue::abs2}{}{291}{datastructures}{}
\functionlistentry{int}{ColorValue::absL1}{}{292}{datastructures}{}
\functionlistentry{}{ColorValue::ColorValue}{}{287}{datastructures}{}
\functionlistentry{explicit}{ColorValue::ColorValue}{int val}{288}{datastructures}{}
\functionlistentry{}{ColorValue::ColorValue}{int redval,int greenval,int blueval}{289}{datastructures}{}
\functionlistentry{int}{ColorValue::getGray}{}{293}{datastructures}{}
\functionlistentry{\hyperlink{ColorValue}{ColorValue}}{ColorValue::Limited}{int maxValue}{294}{datastructures}{}
\functionlistentry{int}{ComputeHomography}{\hyperlink{Matrix}{Matrix} \&imagepoints, \hyperlink{Matrix}{Matrix} \&worldpoints, \hyperlink{Trafo}{Trafo} \&H}{796}{cameraModel}{}
\functionlistentry{double}{computeMinTree}{const vector$<$\hyperlink{Point}{Point}$>$ \&pointlist,\hyperlink{Forest}{Forest} \& tree,double maxlen=0.0}{1295}{graph}{}
\functionlistentry{double}{computeMinTree}{const \hyperlink{Matrix}{Matrix} \&pointlist,\hyperlink{Forest}{Forest} \& tree,double maxlen=0.0}{1296}{graph}{}
\functionlistentry{}{Constant2d::Constant2d}{void}{1032}{functions}{}
\functionlistentry{}{Constant2d::Constant2d}{double a}{1033}{functions}{}
\functionlistentry{}{Constant2d::Constant2d}{const vector\textless {}double\textgreater  \&v}{1034}{functions}{}
\functionlistentry{}{Constant2d::Constant2d}{const \hyperlink{Constant2d}{Constant2d} \&f}{1035}{functions}{}
\functionlistentry{void}{Constant2d::getCoefficient}{double \&a}{1037}{functions}{}
\functionlistentry{void}{Constant2d::setCoefficient}{double a}{1036}{functions}{}
\functionlistentry{}{Constant::Constant}{void}{997}{functions}{}
\functionlistentry{}{Constant::Constant}{double a}{998}{functions}{}
\functionlistentry{}{Constant::Constant}{const vector\textless {}double\textgreater  \&v}{999}{functions}{}
\functionlistentry{}{Constant::Constant}{const \hyperlink{Constant}{Constant} \&f}{1000}{functions}{}
\functionlistentry{int}{Constant::getCoefficient}{double \&pa}{1002}{functions}{}
\functionlistentry{int}{Constant::setCoefficient}{double pa}{1001}{functions}{}
\functionlistentry{int}{Contur::Add}{\hyperlink{Freeman}{Freeman} dir}{400}{conturs}{}
\functionlistentry{int}{Contur::Add}{IPoint p}{401}{conturs}{}
\functionlistentry{int}{Contur::Add}{int x,int y}{402}{conturs}{}
\functionlistentry{int}{Contur::Add}{const \hyperlink{Contur}{Contur} \&c}{403}{conturs}{}
\functionlistentry{void}{Contur::Close}{}{405}{conturs}{}
\functionlistentry{}{Contur::Contur}{}{391}{conturs}{}
\functionlistentry{}{Contur::Contur}{const \hyperlink{Contur}{Contur} \&c}{392}{conturs}{}
\functionlistentry{}{Contur::Contur}{IPoint p}{393}{conturs}{}
\functionlistentry{}{Contur::Contur}{int x,int y}{394}{conturs}{}
\functionlistentry{int}{Contur::DirCode}{int i}{425}{conturs}{}
\functionlistentry{IPoint}{Contur::End}{}{413}{conturs}{}
\functionlistentry{int}{Contur::EndX}{}{416}{conturs}{}
\functionlistentry{int}{Contur::EndY}{}{417}{conturs}{}
\functionlistentry{\hyperlink{Freeman}{Freeman}}{Contur::getDirection}{int i}{420}{conturs}{}
\functionlistentry{const std::vector\textless {}\hyperlink{Freeman}{Freeman}\textgreater {}\&}{Contur::getDirections}{}{421}{conturs}{}
\functionlistentry{int}{Contur::getDirections}{std::vector\textless {}\hyperlink{Freeman}{Freeman}\textgreater {}\& fc}{422}{conturs}{}
\functionlistentry{int}{Contur::getPairs}{std::vector\textless {}IPoint\textgreater {} \&opl,std::vector\textless {}IPoint\textgreater {} \&upl}{423}{conturs}{}
\functionlistentry{int}{Contur::getPairs}{std::vector\textless {}IPoint\textgreater {} \&pl,std::vector\textless {}\hyperlink{Freeman}{Freeman}\textgreater {} \&fc}{424}{conturs}{}
\functionlistentry{IPoint}{Contur::getPoint}{int nr}{426}{conturs}{}
\functionlistentry{int}{Contur::getPoint}{int nr,int \&x,int \&y}{427}{conturs}{}
\functionlistentry{void}{Contur::getPoints}{vector<IPoint> \&pl,bool close=false}{428}{conturs}{}
\functionlistentry{int}{Contur::getRect}{int \&xi,int \&yi,int \&xa,int \&ya}{419}{conturs}{}
\functionlistentry{int}{Contur::InvDir}{}{406}{conturs}{}
\functionlistentry{int}{Contur::isClosed}{}{411}{conturs}{}
\functionlistentry{int}{Contur::isHole}{}{418}{conturs}{}
\functionlistentry{int}{Contur::isValid}{}{408}{conturs}{}
\functionlistentry{double}{Contur::Length}{}{410}{conturs}{}
\functionlistentry{int}{Contur::Number}{}{409}{conturs}{}
\functionlistentry{\hyperlink{Contur}{Contur} \&}{Contur::operator =}{const \hyperlink{Trafo}{Trafo} \&}{407}{conturs}{}
\functionlistentry{int}{Contur::Reset}{}{395}{conturs}{}
\functionlistentry{int}{Contur::Reset}{IPoint p}{396}{conturs}{}
\functionlistentry{int}{Contur::Reset}{int x,int y}{397}{conturs}{}
\functionlistentry{int}{Contur::SetStart}{IPoint p}{398}{conturs}{}
\functionlistentry{int}{Contur::SetStart}{int x,int y}{399}{conturs}{}
\functionlistentry{IPoint}{Contur::Start}{}{412}{conturs}{}
\functionlistentry{int}{Contur::StartX}{}{414}{conturs}{}
\functionlistentry{int}{Contur::StartY}{}{415}{conturs}{}
\functionlistentry{}{conturFromPolygon}{const \hyperlink{Matrix}{Matrix} \&pl,\hyperlink{Contur}{Contur} \&c}{463}{conturs}{}
\functionlistentry{int}{ConturList::Add}{const \hyperlink{Contur}{Contur} \&c}{456}{conturs}{}
\functionlistentry{}{ConturList::ConturList}{}{453}{conturs}{}
\functionlistentry{}{ConturList::ConturList}{const \hyperlink{ConturList}{ConturList}\& cl}{454}{conturs}{}
\functionlistentry{int}{ConturList::Del}{int i}{457}{conturs}{}
\functionlistentry{\hyperlink{Contur}{Contur} *}{ConturList::GetContur}{int i}{458}{conturs}{}
\functionlistentry{\hyperlink{ConturList}{ConturList} \&}{ConturList::operator=}{const \hyperlink{ConturList}{ConturList}\& cl}{455}{conturs}{}
\functionlistentry{IMatrix}{ConturPointlist}{const \hyperlink{Contur}{Contur} \&c,int diff=1,bool close=true}{429}{conturs}{}
\functionlistentry{void}{ConvCartesPolar}{double x,double y,double \&rad,double \&arc}{1366}{numeric}{}
\functionlistentry{void}{ConvCartesPolar}{double p[2],double *rad,double *arc}{1367}{numeric}{}
\functionlistentry{\hyperlink{RotQuaternion}{RotQuaternion}}{convertToRotQuaternion}{\hyperlink{Quaternion}{Quaternion}\& in}{1502}{quaternions}{}
\functionlistentry{\hyperlink{RotQuaternion}{RotQuaternion}}{convertToRotQuaternion}{\hyperlink{Matrix}{Matrix}\& in}{1503}{quaternions}{}
\functionlistentry{\hyperlink{TrafoDualQuaternion}{TrafoDualQuaternion}}{convertToTrafoDualQuaternion}{const \hyperlink{Matrix}{Matrix}\& in}{1538}{quaternions}{}
\functionlistentry{vector$<$\hyperlink{Point}{Point}$>$}{ConvexHull}{const vector$<$\hyperlink{Point}{Point}$>$ \&pl}{284}{datastructures}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{ConvexHull}{const \hyperlink{Matrix}{Matrix} \&pl}{285}{datastructures}{}
\functionlistentry{\hyperlink{Contur}{Contur}}{ConvexHull}{const \hyperlink{Contur}{Contur} \&c}{286}{datastructures}{}
\functionlistentry{int}{ConvImgDImg}{ImageD imgs,\hyperlink{Image}{Image} imgd,int modus=ADAPTIVE,int sign=UNSIGNED}{85}{Images}{}
\functionlistentry{int}{ConvImgImgD}{const \hyperlink{Image}{Image} \&imgs,ImageD imgd,int modus=RAW,int sign=UNSIGNED}{86}{Images}{}
\functionlistentry{int}{Convolution}{const \hyperlink{Vector}{Vector} \&src1,const \hyperlink{Vector}{Vector} \&src2,\hyperlink{Vector}{Vector} \&dst}{1211}{signalTrafo}{}
\functionlistentry{int}{ConvolutionFImgD}{ImageD re1,ImageD im1, ImageD re2,ImageD im2,ImageD re3,ImageD im3}{1213}{signalTrafo}{}
\functionlistentry{int}{ConvolutionHImgD}{ImageD im1,ImageD im2,ImageD im3}{1214}{signalTrafo}{}
\functionlistentry{int}{ConvolutionImg}{const \hyperlink{Image}{Image} \&im1,const \hyperlink{Image}{Image} \&im2, \hyperlink{Image}{Image} \&dst,double factor=0.0,int mode=MD\_USE\_BIAS}{1215}{signalTrafo}{}
\functionlistentry{int}{ConvolutionImg}{const \hyperlink{Image}{Image} \&im1,const \hyperlink{Image}{Image} \&im2, ImageD dst, int mode=MD\_USE\_BIAS}{1216}{signalTrafo}{}
\functionlistentry{int}{ConvolutionImgD}{ImageD im1,ImageD im2,ImageD dst,int mode=MD\_USE\_BIAS}{1212}{signalTrafo}{}
\functionlistentry{int}{ConvPointHesse}{double p1[2],double p2[2],double *p,double *phi}{1370}{numeric}{}
\functionlistentry{\hyperlink{Vector}{Vector}}{ConvPointHesse}{const \hyperlink{Vector}{Vector} \&p1,const \hyperlink{Vector}{Vector} \&p2}{1371}{numeric}{}
\functionlistentry{void}{ConvPolarCartes}{double rad,double arc,double \&x,double \&y}{1368}{numeric}{}
\functionlistentry{void}{ConvPolarCartes}{double rad,double arc,double p[2]}{1369}{numeric}{}
\functionlistentry{int}{ConvR3PointHesse}{double p1[3],double p2[3],double p3[3],double *p,double n[3]}{1393}{numeric}{}
\functionlistentry{int}{CopyImg}{const \hyperlink{Image}{Image} \&src,const \hyperlink{Image}{Image} \&dest}{1086}{processing}{}
\functionlistentry{int}{correctShading}{const \hyperlink{Image}{Image} \&img1,const \hyperlink{Image}{Image} \&img2, int ord=2}{1081}{processing}{}
\functionlistentry{int}{correctShading}{const \hyperlink{Image}{Image} \&img1,const \hyperlink{Image}{Image} \&img2, Function2dWithFitting \&fn}{1082}{processing}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{Correlation}{const \hyperlink{Statistics}{Statistics} \&st}{871}{statistics}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{Covariance}{const \hyperlink{Statistics}{Statistics} \&st}{870}{statistics}{}

\letterlabel{Cr}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ca}
\letterref{Ce}
\letterref{Ch}
\letterref{Ci}
\letterref{Cl}
\letterref{Co}
\letterref{Cr}
\letterref{Cu}
\letterlabelend{Cr}
\functionlistentry{static \hyperlink{Image}{Image}}{createImage}{const \hyperlink{Image}{Image} \&src, bool copy, const std::string \&title = ''''}{9}{Images}{}
\functionlistentry{\hyperlink{Vector}{Vector}}{Cross}{const \hyperlink{Vector}{Vector} \&v1,const \hyperlink{Vector}{Vector} \&v2}{254}{datastructures}{}
\functionlistentry{int}{CrossCorrelationFImgD}{ImageD re1,ImageD im1, ImageD re2,ImageD im2,ImageD re3,ImageD im3}{1224}{signalTrafo}{}
\functionlistentry{int}{CrossCorrelationHImgD}{ImageD im1,ImageD im2,ImageD im3}{1225}{signalTrafo}{}
\functionlistentry{int}{CrossCorrelationImgD}{ImageD im1,ImageD im2,ImageD dst}{1223}{signalTrafo}{}
\functionlistentry{double*}{CrossProdVec}{double v1[3],double v2[3],double v3[3]}{1563}{obsolet}{}

\letterlabel{Cu}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ca}
\letterref{Ce}
\letterref{Ch}
\letterref{Ci}
\letterref{Cl}
\letterref{Co}
\letterref{Cr}
\letterref{Cu}
\letterlabelend{Cu}
\functionlistentry{double}{Cub}{double val}{1346}{numeric}{}
\functionlistentry{double}{CubRoot}{double val}{1347}{numeric}{}
\functionlistentry{int}{Cursor}{int mode,\hyperlink{Image}{Image} img,int x,int y}{95}{Visualisierung}{}
\functionlistentry{int}{cutShortBranches}{\hyperlink{Forest}{Forest} \&f,const vector$<$\hyperlink{Point}{Point}$>$ \&pointlist,double minlen}{1298}{graph}{}
\functionlistentry{int}{cutShortBranches}{\hyperlink{Forest}{Forest} \&f,const \hyperlink{Matrix}{Matrix} \&pointlist,double minlen}{1299}{graph}{}

\letterlabel{De}
\letterlabel{D}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{De}
\letterref{Di}
\letterref{Do}
\letterref{Dr}
\letterref{Du}
\letterlabelend{De}
\functionlistentry{double}{Degree}{double arc}{1349}{numeric}{}
\functionlistentry{}{Delaunay::Delaunay}{vector\textless {}\hyperlink{Point}{Point}\textgreater  \&nodesp}{1302}{graph}{}
\functionlistentry{}{Delaunay::Delaunay}{const \hyperlink{PolygonalCurve}{PolygonalCurve} \&curv}{1303}{graph}{}
\functionlistentry{void}{Delaunay::draw}{const \hyperlink{Image}{Image} \&img, int edgeValue = 1, int fillValue = -1, double limit = -1}{1309}{graph}{}
\functionlistentry{void}{Delaunay::getEdges}{vector\textless {}\hyperlink{LineSeg}{LineSeg}\textgreater  \&output, double limit = -1}{1306}{graph}{}
\functionlistentry{void}{Delaunay::getEdgesI}{vector\textless {}vector\textless {}int\textgreater \textgreater  \&output, double limit = -1}{1307}{graph}{}
\functionlistentry{void}{Delaunay::getRegion}{\hyperlink{Region}{Region} \&region, double limit = -1}{1308}{graph}{}
\functionlistentry{void}{Delaunay::getTriangles}{vector\textless {}\hyperlink{Triangle}{Triangle}\textgreater  \&output, double limit = -1}{1304}{graph}{}
\functionlistentry{void}{Delaunay::getTrianglesI}{vector\textless {}vector\textless {}int\textgreater \textgreater  \&output, double limit = -1}{1305}{graph}{}
\functionlistentry{void}{Delay}{double time}{1445}{genericTools}{}
\functionlistentry{int}{Derive2Func}{FuncD func, int dim,int i,double *x,double h,int mode,double *val}{1401}{numeric}{}
\functionlistentry{int}{DeriveFunc}{FuncD func,int dim,int i,double *x,double h,int mode,double *val}{1400}{numeric}{}
\functionlistentry{\hyperlink{LineSeg}{LineSeg}}{DetectLine}{const vector<\hyperlink{Point}{Point}> \&pointlist}{933}{statistics}{}
\functionlistentry{\hyperlink{LineSeg}{LineSeg}}{DetectLine}{const vector<\hyperlink{Point}{Point}> \&pointlist,int pairs}{934}{statistics}{}
\functionlistentry{\hyperlink{LineSeg}{LineSeg}}{DetectLine}{const \hyperlink{Matrix}{Matrix} \&pointlist}{935}{statistics}{}
\functionlistentry{\hyperlink{LineSeg}{LineSeg}}{DetectLine}{const \hyperlink{Matrix}{Matrix} \&pointlist,int pairs}{936}{statistics}{}
\functionlistentry{int}{DetectShift}{\hyperlink{Image}{Image} img1,\hyperlink{Image}{Image} img2, double \&dx,double \&dy,double \&val,double beta=0.1}{1252}{registration}{}
\functionlistentry{int}{DetectTrafo}{\hyperlink{Image}{Image} img1,\hyperlink{Image}{Image} img2,\hyperlink{Trafo}{Trafo} \&tr, double beta=0.1,int ct=3,int mode=DT\_NEARLY\_SHIFT}{1253}{registration}{}
\functionlistentry{double}{Determinant}{const \hyperlink{Matrix}{Matrix} \&m}{1118}{matrixAlgebra}{}
\functionlistentry{Segment}{DetermineSegment}{PointList pl, int pa, int pe, int type, Segment sl, int* ma, double* md}{1188}{fitting}{}

\letterlabel{Di}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{De}
\letterref{Di}
\letterref{Do}
\letterref{Dr}
\letterref{Du}
\letterlabelend{Di}
\functionlistentry{\hyperlink{Contur}{Contur}}{Dijkstra}{const \hyperlink{Image}{Image} \&img,IPoint s,IPoint e}{1300}{graph}{}
\functionlistentry{\hyperlink{Contur}{Contur}}{Dijkstra}{const \hyperlink{Image}{Image} \&img,IPoint s,\hyperlink{Image}{Image} \&e}{1301}{graph}{}
\functionlistentry{int}{DilateImg}{const \hyperlink{Image}{Image} \&src,int nx,int ny,\hyperlink{Image}{Image} \&dest}{373}{filter}{}
\functionlistentry{int}{DilateImg}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&dest,int nx=3, int ny=-1}{374}{filter}{}
\functionlistentry{int}{DilateImg}{const \hyperlink{Image}{Image} \&src,int neighb,int *mask,\hyperlink{Image}{Image} \&dest}{375}{filter}{}
\functionlistentry{int}{DilateImg}{const \hyperlink{Image}{Image} \&src,int nx,int ny,int *mask,\hyperlink{Image}{Image} \&dest}{376}{filter}{}
\functionlistentry{int}{DilateImg}{const \hyperlink{Image}{Image} \&src,const Imatrix \&mask,\hyperlink{Image}{Image} \&dest}{377}{filter}{}
\functionlistentry{int}{DilateImg}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&dest,const IMatrix \&mask}{378}{filter}{}
\functionlistentry{void}{Directory}{vector$<$string$>$ \&t,const string \&mask,int mode=DIR\_FILE $|$ DIR\_DIR}{1446}{genericTools}{}
\functionlistentry{double}{Distance}{const \hyperlink{Histogram}{Histogram} \&h1,const \hyperlink{Histogram}{Histogram} \&h2}{900}{statistics}{}
\functionlistentry{double}{Distance}{double x1,double y1,double x2,double y2}{1363}{numeric}{}
\functionlistentry{double}{Distance}{IPoint p1,IPoint p2}{1364}{numeric}{}
\functionlistentry{double}{Distance}{\hyperlink{Point}{Point} p1,\hyperlink{Point}{Point} p2}{1365}{numeric}{}
\functionlistentry{double}{Distance}{const Point3d \&p1,const Point3d \&p2}{1384}{numeric}{}
\functionlistentry{double}{Distance}{const Point3d \&p,const \hyperlink{Line3d}{Line3d} \&l}{1385}{numeric}{}
\functionlistentry{double}{Distance}{const \hyperlink{Line3d}{Line3d} \&l,const Point3d \&p}{1386}{numeric}{}
\functionlistentry{double}{Distance}{const \hyperlink{Line3d}{Line3d} \&l1,const \hyperlink{Line3d}{Line3d} \&l2}{1387}{numeric}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{DistanceMatrix}{const \hyperlink{Matrix}{Matrix} \&feat1, const \hyperlink{Matrix}{Matrix} \&feat2, int mode=D\_EUKLID}{1239}{features}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{DistanceMatrix}{const \hyperlink{Matrix}{Matrix} \&feat1, int mode=D\_EUKLID}{1240}{features}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{DistanceMatrix}{const \hyperlink{Matrix}{Matrix} \&feat1, const \hyperlink{Matrix}{Matrix} \& feat2, const VectorDistance \&dist}{1241}{features}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{DistanceMatrix}{const \hyperlink{Matrix}{Matrix} \&feat1, const VectorDistance \&dist}{1242}{features}{}
\functionlistentry{double}{Distortion0::D2}{void}{750}{geoTrafo}{}
\functionlistentry{}{Distortion0::Distortion0}{void}{728}{geoTrafo}{}
\functionlistentry{}{Distortion0::Distortion0}{double x0,double y0,double d2=0.0}{732}{geoTrafo}{}
\functionlistentry{}{Distortion0::Distortion0}{const \hyperlink{Matrix}{Matrix} \&mark,const \hyperlink{Matrix}{Matrix} \&orig,\hyperlink{Trafo}{Trafo} \&tr,const \hyperlink{Vector}{Vector} \&ImageCenter}{736}{geoTrafo}{}
\functionlistentry{}{Distortion0::Distortion0}{const \hyperlink{Matrix}{Matrix} \&mark,const \hyperlink{Matrix}{Matrix} \&orig,const \hyperlink{Vector}{Vector} \&ImageCenter}{737}{geoTrafo}{}
\functionlistentry{}{Distortion0::Distortion0}{const \hyperlink{Matrix}{Matrix} \&mark,const \hyperlink{Matrix}{Matrix} \&orig}{738}{geoTrafo}{}
\functionlistentry{double}{Distortion1::D2}{void}{751}{geoTrafo}{}
\functionlistentry{double}{Distortion1::D4}{void}{752}{geoTrafo}{}
\functionlistentry{}{Distortion1::Distortion1}{void}{729}{geoTrafo}{}
\functionlistentry{}{Distortion1::Distortion1}{double x0,double y0,double d2=0.0, double d4=0.0}{733}{geoTrafo}{}
\functionlistentry{}{Distortion1::Distortion1}{const \hyperlink{Matrix}{Matrix} \&mark,const \hyperlink{Matrix}{Matrix} \&orig,\hyperlink{Trafo}{Trafo} \&tr,const \hyperlink{Vector}{Vector} \&ImageCenter}{739}{geoTrafo}{}
\functionlistentry{}{Distortion1::Distortion1}{const \hyperlink{Matrix}{Matrix} \&mark,const \hyperlink{Matrix}{Matrix} \&orig,const \hyperlink{Vector}{Vector} \&ImageCenter}{740}{geoTrafo}{}
\functionlistentry{}{Distortion1::Distortion1}{const \hyperlink{Matrix}{Matrix} \&mark,const \hyperlink{Matrix}{Matrix} \&orig}{741}{geoTrafo}{}
\functionlistentry{double}{Distortion2::D2}{void}{753}{geoTrafo}{}
\functionlistentry{double}{Distortion2::D2}{void}{756}{geoTrafo}{}
\functionlistentry{double}{Distortion2::D3}{void}{754}{geoTrafo}{}
\functionlistentry{double}{Distortion2::D4}{void}{755}{geoTrafo}{}
\functionlistentry{double}{Distortion2::D4}{void}{757}{geoTrafo}{}
\functionlistentry{double}{Distortion2::D6}{void}{758}{geoTrafo}{}
\functionlistentry{}{Distortion2::Distortion2}{void}{730}{geoTrafo}{}
\functionlistentry{}{Distortion2::Distortion2}{double x0,double y0,double d2=0.0, double d3=0.0,double d4=0.0}{734}{geoTrafo}{}
\functionlistentry{}{Distortion2::Distortion2}{const \hyperlink{Matrix}{Matrix} \&mark,const \hyperlink{Matrix}{Matrix} \&orig,\hyperlink{Trafo}{Trafo} \&tr,const \hyperlink{Vector}{Vector} \&ImageCenter}{742}{geoTrafo}{}
\functionlistentry{}{Distortion2::Distortion2}{const \hyperlink{Matrix}{Matrix} \&mark,const \hyperlink{Matrix}{Matrix} \&orig,const \hyperlink{Vector}{Vector} \&ImageCenter}{743}{geoTrafo}{}
\functionlistentry{}{Distortion2::Distortion2}{const \hyperlink{Matrix}{Matrix} \&mark,const \hyperlink{Matrix}{Matrix} \&orig}{744}{geoTrafo}{}
\functionlistentry{}{Distortion3::Distortion3}{void}{731}{geoTrafo}{}
\functionlistentry{}{Distortion3::Distortion3}{double x0,double y0,double d2=0.0, double d4=0.0,double d6=0.0}{735}{geoTrafo}{}
\functionlistentry{}{Distortion3::Distortion3}{const \hyperlink{Matrix}{Matrix} \&mark,const \hyperlink{Matrix}{Matrix} \&orig,\hyperlink{Trafo}{Trafo} \&tr,const \hyperlink{Vector}{Vector} \&ImageCenter}{745}{geoTrafo}{}
\functionlistentry{}{Distortion3::Distortion3}{const \hyperlink{Matrix}{Matrix} \&mark,const \hyperlink{Matrix}{Matrix} \&orig,const \hyperlink{Vector}{Vector} \&ImageCenter}{746}{geoTrafo}{}
\functionlistentry{}{Distortion3::Distortion3}{const \hyperlink{Matrix}{Matrix} \&mark,const \hyperlink{Matrix}{Matrix} \&orig}{747}{geoTrafo}{}
\functionlistentry{int}{Distortion::Distort}{double \&x,double \&y}{759}{geoTrafo}{}
\functionlistentry{int}{Distortion::Distort}{double x,double y,double \&xd,double \&yd}{760}{geoTrafo}{}
\functionlistentry{\hyperlink{Vector}{Vector}}{Distortion::Distort}{const \hyperlink{Vector}{Vector} \&p}{761}{geoTrafo}{}
\functionlistentry{\hyperlink{Point}{Point}}{Distortion::Distort}{const \hyperlink{Point}{Point} \&p}{762}{geoTrafo}{}
\functionlistentry{int}{Distortion::Rect}{double \&x,double \&y}{763}{geoTrafo}{}
\functionlistentry{int}{Distortion::Rect}{double x,double y,double \&xr,double \&yr}{764}{geoTrafo}{}
\functionlistentry{\hyperlink{Vector}{Vector}}{Distortion::Rect}{const \hyperlink{Vector}{Vector} \&p}{765}{geoTrafo}{}
\functionlistentry{\hyperlink{Point}{Point}}{Distortion::Rect}{const \hyperlink{Point}{Point} \&p}{766}{geoTrafo}{}
\functionlistentry{\hyperlink{Image}{Image}}{Distortion::RectImg}{\hyperlink{Image}{Image} source,int mode=DEFAULT}{767}{geoTrafo}{}
\functionlistentry{\hyperlink{Image}{Image}}{Distortion::RectImg}{\hyperlink{Image}{Image} source,\hyperlink{Image}{Image} dest,int mode=DEFAULT}{768}{geoTrafo}{}
\functionlistentry{double}{Distortion::X0}{void}{748}{geoTrafo}{}
\functionlistentry{double}{Distortion::Y0}{void}{749}{geoTrafo}{}
\functionlistentry{double}{DistPointCircle}{double p[2],double par[3]}{1375}{numeric}{}
\functionlistentry{double}{DistPointEllipse}{double p[2],double par[5],double koord[2]}{1376}{numeric}{}
\functionlistentry{double}{DistPointLine}{double r[2],double p,double phi}{1373}{numeric}{}
\functionlistentry{double}{DistR3PointLine}{double p[3],double p0[3],double dir[3]}{1394}{numeric}{}
\functionlistentry{double}{DistR3PointPlane}{double p[3],double r,double n[3]}{1395}{numeric}{}

\letterlabel{Do}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{De}
\letterref{Di}
\letterref{Do}
\letterref{Dr}
\letterref{Du}
\letterlabelend{Do}
\functionlistentry{int}{DoBImg}{\hyperlink{Image}{Image} src,\hyperlink{Image}{Image} dest,int n1,int n2,int mode=SMD\_SHIFT}{345}{filter}{}
\functionlistentry{double}{Double}{const string \&s}{1410}{genericTools}{}

\letterlabel{Dr}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{De}
\letterref{Di}
\letterref{Do}
\letterref{Dr}
\letterref{Du}
\letterlabelend{Dr}
\functionlistentry{int}{Draw}{const \hyperlink{Circle}{Circle} \&c,\hyperlink{Image}{Image} \&img,int val,int fval=-1}{623}{geoObject}{}
\functionlistentry{int}{Draw}{const \hyperlink{CircleSeg}{CircleSeg} \&c,\hyperlink{Image}{Image} \&img,int val,int fval=-1}{624}{geoObject}{}
\functionlistentry{int}{Draw}{const \hyperlink{Ellipse}{Ellipse} \&c,\hyperlink{Image}{Image} \&img,int val,int fval=-1}{625}{geoObject}{}
\functionlistentry{int}{Draw}{const \hyperlink{EllipseSeg}{EllipseSeg} \&c,\hyperlink{Image}{Image} \&img,int val,int fval=-1}{626}{geoObject}{}
\functionlistentry{int}{Draw}{const \hyperlink{LineSeg}{LineSeg} \&c,\hyperlink{Image}{Image} \&img,int val}{627}{geoObject}{}
\functionlistentry{int}{Draw}{const \hyperlink{Polygon}{Polygon} \&c,\hyperlink{Image}{Image} \&img,int val,int fval=-1}{628}{geoObject}{}
\functionlistentry{int}{DrawCircle}{double par[3],int val1,int val2,int mode,\hyperlink{Image}{Image} img}{1325}{graphics}{}
\functionlistentry{int}{DrawCircleSegment}{double par[5],int val1,int val2,int mode,\hyperlink{Image}{Image} img}{1328}{graphics}{}
\functionlistentry{int}{DrawEllipse}{double par[5],int val1,int val2,int mode,\hyperlink{Image}{Image} img}{1326}{graphics}{}
\functionlistentry{int}{DrawEllipseSegment}{double *par[7],int val1,int val2,int mode,\hyperlink{Image}{Image} img}{1329}{graphics}{}
\functionlistentry{\hyperlink{Image}{Image}}{DrawPattern}{int dimx, int dimy}{801}{cameraModel}{}
\functionlistentry{void}{DrawPolygon}{PointList pl,int val,\hyperlink{Image}{Image} img}{1330}{graphics}{}
\functionlistentry{void}{DrawSuperEllipse}{double c, double tr[3][3], int val,\hyperlink{Image}{Image} img}{1327}{graphics}{}

\letterlabel{Du}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{De}
\letterref{Di}
\letterref{Do}
\letterref{Dr}
\letterref{Du}
\letterlabelend{Du}
\functionlistentry{}{DualQuaternion::DualQuaternion}{}{1513}{quaternions}{}
\functionlistentry{}{DualQuaternion::DualQuaternion}{\hyperlink{Quaternion}{Quaternion}\& real, \hyperlink{Quaternion}{Quaternion}\& dual}{1514}{quaternions}{}
\functionlistentry{}{DualQuaternion::DualQuaternion}{const \hyperlink{DualQuaternion}{DualQuaternion}\& b}{1515}{quaternions}{}
\functionlistentry{\hyperlink{DualQuaternion}{DualQuaternion}}{DualQuaternion::getConjugate}{}{1521}{quaternions}{}
\functionlistentry{\hyperlink{Quaternion}{Quaternion}}{DualQuaternion::getDual}{}{1517}{quaternions}{}
\functionlistentry{\hyperlink{DualQuaternion}{DualQuaternion}}{DualQuaternion::getInverse}{}{1523}{quaternions}{}
\functionlistentry{\hyperlink{DualQuaternion}{DualQuaternion}}{DualQuaternion::getNegate}{}{1520}{quaternions}{}
\functionlistentry{\hyperlink{DualQuaternion}{DualQuaternion}}{DualQuaternion::getQuasiNorm}{}{1524}{quaternions}{}
\functionlistentry{\hyperlink{Quaternion}{Quaternion}}{DualQuaternion::getReal}{}{1516}{quaternions}{}
\functionlistentry{\hyperlink{DualQuaternion}{DualQuaternion}}{DualQuaternion::getTilde}{}{1522}{quaternions}{}
\functionlistentry{bool}{DualQuaternion::isUnitDualQuaternion}{}{1525}{quaternions}{}
\functionlistentry{void}{DualQuaternion::setDual}{\hyperlink{Quaternion}{Quaternion}\& dual}{1519}{quaternions}{}
\functionlistentry{void}{DualQuaternion::setReal}{\hyperlink{Quaternion}{Quaternion}\& real}{1518}{quaternions}{}

\letterlabel{Ed}
\letterlabel{E}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ed}
\letterref{Ei}
\letterref{El}
\letterref{Eq}
\letterref{Er}
\letterref{Es}
\letterlabelend{Ed}
\functionlistentry{void}{edge}{int i,\hyperlink{LineSeg}{LineSeg} \&l}{601}{geoObject}{}
\functionlistentry{void}{edge}{int i,\hyperlink{LineSeg}{LineSeg} \&l}{620}{geoObject}{}

\letterlabel{Ei}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ed}
\letterref{Ei}
\letterref{El}
\letterref{Eq}
\letterref{Er}
\letterref{Es}
\letterlabelend{Ei}
\functionlistentry{int}{EigenachsenSpektrumQFT}{\hyperlink{QuatMatrix}{QuatMatrix}\& input, \hyperlink{Image}{Image}\& r, \hyperlink{Image}{Image}\& g, \hyperlink{Image}{Image}\& b, int mode=CENTER}{1543}{quaternions}{}
\functionlistentry{int}{Eigenvalue}{const \hyperlink{Matrix}{Matrix} \&a,\hyperlink{Vector}{Vector} \&eval,\hyperlink{Matrix}{Matrix} \&evect}{1128}{matrixAlgebra}{}
\functionlistentry{int}{Eigenvalue}{const \hyperlink{Matrix}{Matrix} \&a,\hyperlink{Matrix}{Matrix} \&eval,\hyperlink{Matrix}{Matrix} \&evect}{1129}{matrixAlgebra}{}
\functionlistentry{int}{Eigenvalue}{double a,double b,double c, double \&lambda1,double \&lambda2,\hyperlink{Point}{Point} \&eigen1,\hyperlink{Point}{Point} \&eigen2}{1130}{matrixAlgebra}{}
\functionlistentry{int}{EigenwinkelSpektrumQFT}{\hyperlink{QuatMatrix}{QuatMatrix}\& input, \hyperlink{Image}{Image}\& r, \hyperlink{Image}{Image}\& g, \hyperlink{Image}{Image}\& b, int mode=CENTER}{1542}{quaternions}{}

\letterlabel{El}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ed}
\letterref{Ei}
\letterref{El}
\letterref{Eq}
\letterref{Er}
\letterref{Es}
\letterlabelend{El}
\functionlistentry{}{Ellipse::Ellipse}{}{532}{geoObject}{}
\functionlistentry{}{Ellipse::Ellipse}{const \hyperlink{Ellipse}{Ellipse} \&c}{533}{geoObject}{}
\functionlistentry{}{Ellipse::Ellipse}{double xm,double ym,double r1,double r2,double phi}{534}{geoObject}{}
\functionlistentry{explicit}{Ellipse::Ellipse}{const \hyperlink{Vector}{Vector} \&c}{535}{geoObject}{}
\functionlistentry{explicit}{Ellipse::Ellipse}{const double d[]}{536}{geoObject}{}
\functionlistentry{double}{Ellipse::getR1}{}{537}{geoObject}{}
\functionlistentry{double}{Ellipse::getR2}{}{539}{geoObject}{}
\functionlistentry{void}{Ellipse::setR1}{double val}{538}{geoObject}{}
\functionlistentry{void}{Ellipse::setR2}{double val}{540}{geoObject}{}
\functionlistentry{\hyperlink{Contur}{Contur}}{EllipseContur}{double par[5]}{1333}{graphics}{}
\functionlistentry{}{EllipseSeg::EllipseSeg}{void}{541}{geoObject}{}
\functionlistentry{}{EllipseSeg::EllipseSeg}{const \hyperlink{EllipseSeg}{EllipseSeg} \&c}{542}{geoObject}{}
\functionlistentry{}{EllipseSeg::EllipseSeg}{double xm,double ym,double r1,double r2,double phi,double phi1,double phi2}{543}{geoObject}{}
\functionlistentry{explicit}{EllipseSeg::EllipseSeg}{const \hyperlink{Vector}{Vector} \&c}{544}{geoObject}{}
\functionlistentry{explicit}{EllipseSeg::EllipseSeg}{const double d[]}{545}{geoObject}{}
\functionlistentry{double}{EllipseSeg::Phi1}{void}{546}{geoObject}{}
\functionlistentry{double}{EllipseSeg::Phi2}{void}{548}{geoObject}{}
\functionlistentry{void}{EllipseSeg::setPhi1}{double val}{547}{geoObject}{}
\functionlistentry{void}{EllipseSeg::setPhi2}{double val}{549}{geoObject}{}
\functionlistentry{\hyperlink{Contur}{Contur}}{EllipseSegmentContur}{double par[7]}{1335}{graphics}{}

\letterlabel{Eq}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ed}
\letterref{Ei}
\letterref{El}
\letterref{Eq}
\letterref{Er}
\letterref{Es}
\letterlabelend{Eq}
\functionlistentry{int}{EquationSys}{MatrixStruct A,double *b,double *x}{1125}{matrixAlgebra}{}

\letterlabel{Er}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ed}
\letterref{Ei}
\letterref{El}
\letterref{Eq}
\letterref{Er}
\letterref{Es}
\letterlabelend{Er}
\functionlistentry{int}{ErodeImg}{const \hyperlink{Image}{Image} \&src,int nx,int ny,\hyperlink{Image}{Image} \&dest}{367}{filter}{}
\functionlistentry{int}{ErodeImg}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&dest,int nx=3, int ny=-1}{368}{filter}{}
\functionlistentry{int}{ErodeImg}{const \hyperlink{Image}{Image} \&src,int neighb,int *mask,\hyperlink{Image}{Image} \&dest}{369}{filter}{}
\functionlistentry{int}{ErodeImg}{const \hyperlink{Image}{Image} \&src,int nx,int ny,int *mask,\hyperlink{Image}{Image} \&dest}{370}{filter}{}
\functionlistentry{int}{ErodeImg}{const \hyperlink{Image}{Image} \&src,const Imatrix \&mask,\hyperlink{Image}{Image} \&dest}{371}{filter}{}
\functionlistentry{int}{ErodeImg}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&dest,const IMatrix \&mask}{372}{filter}{}

\letterlabel{Es}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ed}
\letterref{Ei}
\letterref{El}
\letterref{Eq}
\letterref{Er}
\letterref{Es}
\letterlabelend{Es}
\functionlistentry{\hyperlink{TrafoDualQuaternion}{TrafoDualQuaternion}}{estimateTransformation}{const \hyperlink{Matrix}{Matrix}\& orig,const \hyperlink{Matrix}{Matrix}\& trans}{1539}{quaternions}{}

\letterlabel{Fe}
\letterlabel{F}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Fe}
\letterref{Fi}
\letterref{Fm}
\letterref{Fo}
\letterref{Fr}
\letterref{Fu}
\letterlabelend{Fe}
\functionlistentry{int}{FeatureContur}{\hyperlink{Contur}{Contur} c,double \&length,double \&area,double \&form,double \&conv}{430}{conturs}{}
\functionlistentry{int}{FeatureQuadrFunc}{double koeff[6],double par[5],int *type}{1381}{numeric}{}

\letterlabel{Fi}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Fe}
\letterref{Fi}
\letterref{Fm}
\letterref{Fo}
\letterref{Fr}
\letterref{Fu}
\letterlabelend{Fi}
\functionlistentry{int}{FillRegion}{\hyperlink{Contur}{Contur} c,int val,\hyperlink{Image}{Image} img}{1337}{graphics}{}
\functionlistentry{int}{FindMax}{const \hyperlink{Image}{Image} \&img, int \&x, int \&y}{1069}{processing}{}
\functionlistentry{int}{FindMax}{const \hyperlink{Image}{Image} \&img, IPoint \&p}{1070}{processing}{}
\functionlistentry{int}{FindMax}{const \hyperlink{Image}{Image} \&img}{1071}{processing}{}
\functionlistentry{int}{FindMin}{const \hyperlink{Image}{Image} \&img, int \&x, int \&y}{1066}{processing}{}
\functionlistentry{int}{FindMin}{const \hyperlink{Image}{Image} \&img, IPoint \&p}{1067}{processing}{}
\functionlistentry{int}{FindMin}{const \hyperlink{Image}{Image} \&img}{1068}{processing}{}
\functionlistentry{int}{FitAffineTrans}{PointList pl1,PointList pl2,double tr[3][3]}{1589}{obsolet}{}
\functionlistentry{int}{FitCircle}{const \hyperlink{Moments}{Moments} \&m,double \&x0,double \&y0,double \&radius}{854}{moments}{}
\functionlistentry{\hyperlink{Circle}{Circle}}{FitCircle}{const \hyperlink{Moments}{Moments} \&m}{855}{moments}{}
\functionlistentry{\hyperlink{Circle}{Circle}}{FitCircle}{const vector\textless {}\hyperlink{Point}{Point}\textgreater  \&pl}{1168}{fitting}{}
\functionlistentry{\hyperlink{Circle}{Circle}}{FitCircle}{const vector\textless {}\hyperlink{Point}{Point}\textgreater  \&pl,const vector\textless {}double\textgreater  \&weight}{1169}{fitting}{}
\functionlistentry{\hyperlink{Circle}{Circle}}{FitCircle}{const vector\textless {}\hyperlink{Point}{Point}\textgreater  \&pl,int step}{1170}{fitting}{}
\functionlistentry{\hyperlink{Circle}{Circle}}{FitCircle}{const vector\textless {}\hyperlink{Point}{Point}\textgreater  \&pl,vector\textless {}double\textgreater  \&weight,int step}{1171}{fitting}{}
\functionlistentry{\hyperlink{Circle}{Circle}}{FitCircle}{const \hyperlink{Matrix}{Matrix} \&pl,int step=0}{1172}{fitting}{}
\functionlistentry{int}{FitCircle}{const \hyperlink{Matrix}{Matrix} \&pl,double \&xm,double \&ym,double \&rad,int step=0}{1173}{fitting}{}
\functionlistentry{int}{FitCircle}{const \hyperlink{Matrix}{Matrix} \&pl,double par[3],int step=0}{1174}{fitting}{}
\functionlistentry{int}{FitCircle}{PointList pl,int a1,int a2,int step,double par[3],double *mdist,int *madr}{1175}{fitting}{}
\functionlistentry{int}{FitCircleLinOpt}{PointList pl,int a1,int a2,int step,double par[3],double limit=1000000}{1176}{fitting}{}
\functionlistentry{int}{FitCircleMoments}{double moment[15],double \&x0,double \&y0,double \&radius}{1627}{obsolet}{}
\functionlistentry{Segment}{FitCircleSegment}{PointList pl,int a1,int a2,int step,double *mdist,int *madr}{1182}{fitting}{}
\functionlistentry{int}{FitCircularSegmentMoments}{double moment[15],double circle\_par[3],double line\_start[2],double line\_end[2]}{1628}{obsolet}{}
\functionlistentry{\hyperlink{Ellipse}{Ellipse}}{FitEllipse}{const \hyperlink{Moments}{Moments} \&m}{856}{moments}{}
\functionlistentry{\hyperlink{Ellipse}{Ellipse}}{FitEllipse}{const \hyperlink{Matrix}{Matrix} \&pl,int step=0,int mode=1}{1177}{fitting}{}
\functionlistentry{int}{FitEllipse}{const \hyperlink{Matrix}{Matrix} \&pl,double par[5],int step=0,int mode=1}{1178}{fitting}{}
\functionlistentry{int}{FitEllipse}{PointList pl,int a1,int a2,int step,double par[5],double *mdist,int *madr,int mode=1}{1179}{fitting}{}
\functionlistentry{int}{FitEllipseLinOpt}{PointList pl,int a1,int a2,int step,double par[5],double limit}{1180}{fitting}{}
\functionlistentry{int}{FitEllipseMoments}{double moment[15],double ell\_par[5]}{1629}{obsolet}{}
\functionlistentry{Segment}{FitEllipseSegment}{PointList pl,int a1,int a2,int step,double *mdist,int *madr}{1183}{fitting}{}
\functionlistentry{int}{FitEllipticalSegmentMoments}{double moment[15],double ell\_par[5],double line\_start[2],double line\_end[2]}{1630}{obsolet}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{FitEquilateralTriangle}{const \hyperlink{Moments}{Moments} \&m}{841}{moments}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{FitEquilateralTriangle}{const \hyperlink{Moments}{Moments} \&m,double \&guetemass}{842}{moments}{}
\functionlistentry{double}{FitGradLine}{\hyperlink{Image}{Image} img, double lp[2][2],int dist, double *p, double *phi}{1192}{fitting}{}
\functionlistentry{double}{FitGrayLine}{\hyperlink{Image}{Image} img, double lp[2][2],int dist, double *p, double *phi}{1191}{fitting}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{FitIsoscelesTriangle}{const \hyperlink{Moments}{Moments} \&m}{843}{moments}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{FitIsoscelesTriangle}{const \hyperlink{Moments}{Moments} \&m,double \&guetemass}{844}{moments}{}
\functionlistentry{\hyperlink{LineSeg}{LineSeg}}{FitLine}{const vector\textless {}\hyperlink{Point}{Point}\textgreater  \&pl}{1159}{fitting}{}
\functionlistentry{\hyperlink{LineSeg}{LineSeg}}{FitLine}{const vector\textless {}\hyperlink{Point}{Point}\textgreater  \&pl,int step}{1160}{fitting}{}
\functionlistentry{\hyperlink{LineSeg}{LineSeg}}{FitLine}{const vector\textless {}\hyperlink{Point}{Point}\textgreater  \&pl,const vector\textless {}double\textgreater  \&weight}{1161}{fitting}{}
\functionlistentry{\hyperlink{LineSeg}{LineSeg}}{FitLine}{const vector\textless {}\hyperlink{Point}{Point}\textgreater  \&pl,vector\textless {}double\textgreater  \&weight,int step}{1162}{fitting}{}
\functionlistentry{\hyperlink{LineSeg}{LineSeg}}{FitLine}{const \hyperlink{Matrix}{Matrix} \&pl,int step=0}{1163}{fitting}{}
\functionlistentry{int}{FitLine}{const \hyperlink{Matrix}{Matrix} \&pl,double \&r,double \&phi,int step=0}{1164}{fitting}{}
\functionlistentry{int}{FitLine}{const \hyperlink{Matrix}{Matrix} \&m,double par[2],int step=0}{1165}{fitting}{}
\functionlistentry{int}{FitLine}{PointList pl,int a1,int a2,int step,double par[2],double *mdist,int *madr}{1166}{fitting}{}
\functionlistentry{int}{FitLineLinOpt}{PointList pl,int a1,int a2,int step,double par[2],double limit=1000000}{1167}{fitting}{}
\functionlistentry{Segment}{FitLineSegment}{PointList pl,int a1,int a2,int step,double *mdist,int *madr}{1181}{fitting}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{FitParallelogram}{const \hyperlink{Moments}{Moments} \&m}{849}{moments}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{FitParallelogram}{const \hyperlink{Moments}{Moments} \&m,double \& guetemass}{850}{moments}{}
\functionlistentry{int}{FitParallelogramMoments}{double moment[15],double corner[4][2]}{1624}{obsolet}{}
\functionlistentry{int}{FitParallelogramMoments}{double moment[15],double corner[4][2], double \& guetemass}{1625}{obsolet}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{FitPolygon}{const \hyperlink{Moments}{Moments} \&m,const \hyperlink{Matrix}{Matrix} \&pl}{852}{moments}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{FitPolygon}{const \hyperlink{Moments}{Moments} \&m,const \hyperlink{Matrix}{Matrix} \&pl,double \&guetemass}{853}{moments}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{FitPolygonContur}{const \hyperlink{Matrix}{Matrix} \&pl, const \hyperlink{Contur}{Contur} \&c,int step=0}{283}{datastructures}{}
\functionlistentry{PointList}{FitPolygonContur}{\hyperlink{Contur}{Contur} c,int mlng,double mdist}{1185}{fitting}{}
\functionlistentry{PointList}{FitPolygonPointList}{PointList pl,int closed,int mlng,double mdist}{1190}{fitting}{}
\functionlistentry{int}{FitProjectiveTrans}{PointList pl1,PointList pl2,double tr[3][3]}{1590}{obsolet}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{FitQuadrangle}{const \hyperlink{Moments}{Moments} \&m}{851}{moments}{}
\functionlistentry{int}{FitQuadrangleMoments}{double moment[15],double corner[4][2]}{1626}{obsolet}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{FitRectangle}{const \hyperlink{Moments}{Moments} \&m}{847}{moments}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{FitRectangle}{const \hyperlink{Moments}{Moments} \&m,double \&guetemass}{848}{moments}{}
\functionlistentry{int}{FitRectangleMoments}{double moment[15],double corner[4][2]}{1623}{obsolet}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{FitSquare}{const \hyperlink{Moments}{Moments} \&m}{845}{moments}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{FitSquare}{const \hyperlink{Moments}{Moments} \&m,double \& guetemass}{846}{moments}{}
\functionlistentry{int}{FitSuperEllipseMoments}{double moment[15],double \&c1,double \&f1,double tr1[3][3],double \&c2,double \&f2,double tr2[3][3]}{1631}{obsolet}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{FitTriangle}{const \hyperlink{Moments}{Moments} \&m}{840}{moments}{}
\functionlistentry{int}{FitTriangleMoments}{double moment[15],double corner[3][2]}{1622}{obsolet}{}

\letterlabel{Fm}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Fe}
\letterref{Fi}
\letterref{Fm}
\letterref{Fo}
\letterref{Fr}
\letterref{Fu}
\letterlabelend{Fm}
\functionlistentry{double}{FMod}{double val,double mod}{1358}{numeric}{}

\letterlabel{Fo}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Fe}
\letterref{Fi}
\letterref{Fm}
\letterref{Fo}
\letterref{Fr}
\letterref{Fu}
\letterlabelend{Fo}
\functionlistentry{int}{Forest::Depth}{int x}{1288}{graph}{}
\functionlistentry{int}{Forest::Father}{int x}{1286}{graph}{}
\functionlistentry{}{Forest::Forest}{int n=0}{1276}{graph}{}
\functionlistentry{int}{Forest::getNeighborCount}{int x}{1281}{graph}{}
\functionlistentry{int}{Forest::getRefCount}{int x}{1280}{graph}{}
\functionlistentry{bool}{Forest::isLeaf}{int x}{1284}{graph}{}
\functionlistentry{bool}{Forest::isRoot}{int x}{1283}{graph}{}
\functionlistentry{void}{Forest::makeRoot}{int x}{1285}{graph}{}
\functionlistentry{int}{Forest::nTree}{bool ignoreZeroLengthTrees=false}{1279}{graph}{}
\functionlistentry{int}{Forest::Reset}{int n}{1277}{graph}{}
\functionlistentry{int}{Forest::Root}{int x}{1287}{graph}{}
\functionlistentry{void}{Forest::setFather}{int x,int f=\hyperlink{Forest}{Forest}::rootval}{1282}{graph}{}
\functionlistentry{int}{Forest::Size}{}{1278}{graph}{}
\functionlistentry{int}{Fourier}{const \hyperlink{Vector}{Vector} \&re1,const \hyperlink{Vector}{Vector} \&im1,int mode, \hyperlink{Vector}{Vector} \&re2,\hyperlink{Vector}{Vector} \&im2}{1194}{signalTrafo}{}
\functionlistentry{int}{Fourier}{\hyperlink{Vector}{Vector} \&re,\hyperlink{Vector}{Vector} \&im,int mode=NORMAL}{1195}{signalTrafo}{}
\functionlistentry{int}{Fourier}{const \hyperlink{Matrix}{Matrix} \&src,int mode,\hyperlink{Matrix}{Matrix} \&dst}{1196}{signalTrafo}{}
\functionlistentry{int}{Fourier}{\hyperlink{Matrix}{Matrix} \&m,int mode=NORMAL}{1197}{signalTrafo}{}
\functionlistentry{void}{FourierImgD}{ImageD re1,ImageD im1,int mode,ImageD re2,ImageD im2,int dir=XY}{1200}{signalTrafo}{}
\functionlistentry{int}{FourierMPImgD}{ImageD mag,ImageD phase,ImageD re,ImageD im}{1208}{signalTrafo}{}

\letterlabel{Fr}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Fe}
\letterref{Fi}
\letterref{Fm}
\letterref{Fo}
\letterref{Fr}
\letterref{Fu}
\letterlabelend{Fr}
\functionlistentry{int}{FreeImg}{\hyperlink{Image}{Image} \&img}{12}{Images}{}
\functionlistentry{int}{FreeImg}{\hyperlink{ColorImage}{ColorImage} \&img}{24}{Images}{}
\functionlistentry{int}{FreeImgD}{ImageD img}{87}{Images}{}
\functionlistentry{}{Freeman::Freeman}{}{464}{conturs}{}
\functionlistentry{}{Freeman::Freeman}{int dir}{465}{conturs}{}
\functionlistentry{}{Freeman::Freeman}{const \hyperlink{Freeman}{Freeman} \&sec}{466}{conturs}{}
\functionlistentry{int}{Freeman::Int}{}{467}{conturs}{}
\functionlistentry{void}{Freeman::move}{int x,int y,int \&xn,int \&yn}{468}{conturs}{}
\functionlistentry{void}{Freeman::move}{int \&x,int \&y}{469}{conturs}{}
\functionlistentry{void}{Freeman::move}{IPoint p1,IPoint \&p2}{470}{conturs}{}
\functionlistentry{void}{Freeman::move}{IPoint \&p}{471}{conturs}{}
\functionlistentry{IPoint}{Freeman::step}{IPoint \&p}{472}{conturs}{}
\functionlistentry{int}{FreeMatrix}{MatrixStruct mat}{1576}{obsolet}{}
\functionlistentry{}{FreePeakList}{PeakList pl}{1260}{registration}{}

\letterlabel{Fu}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Fe}
\letterref{Fi}
\letterref{Fm}
\letterref{Fo}
\letterref{Fr}
\letterref{Fu}
\letterlabelend{Fu}
\functionlistentry{double}{Func2d::operator()}{double x, double y}{1030}{functions}{}
\functionlistentry{double}{Func2d::operator()}{\hyperlink{Point}{Point} p}{1031}{functions}{}
\functionlistentry{void}{Function2d::getCoefficient}{vector\textless {}double\textgreater  \&c}{1021}{functions}{}
\functionlistentry{double}{Function2d::operator()}{double x,doubel y}{1019}{functions}{}
\functionlistentry{double}{Function2d::operator()}{\hyperlink{Point}{Point} p}{1020}{functions}{}
\functionlistentry{int}{Function2d::setCoefficient}{const vector\textless {}double\textgreater  \&para,int idx=0}{1022}{functions}{}
\functionlistentry{}{Function2dDistortion::Function2dDistortion}{Function2d \&funcp, Distortion \&tr}{1059}{functions}{}
\functionlistentry{}{Function2dModifier::Function2dModifier}{Function2d \&funcp}{1054}{functions}{}
\functionlistentry{}{Function2dParameterShift::Function2dParameterShift}{Function2d \&funcp, double sx, double sy}{1055}{functions}{}
\functionlistentry{}{Function2dParameterTransform::Function2dParameterTransform}{Function2d \&funcp, const \hyperlink{Trafo}{Trafo} \&tr}{1056}{functions}{}
\functionlistentry{\hyperlink{Trafo}{Trafo} \&}{Function2dParameterTransform::Tr}{}{1057}{functions}{}
\functionlistentry{const \hyperlink{Trafo}{Trafo} \&}{Function2dParameterTransform::Tr}{}{1058}{functions}{}
\functionlistentry{}{Function2dValueTransform::Function2dValueTransform}{Function2d \&funcp, double a1, double a0}{1060}{functions}{}
\functionlistentry{int}{Function2dWithFitting::Fit}{const \hyperlink{Matrix}{Matrix} \&m}{1027}{functions}{}
\functionlistentry{int}{Function2dWithFitting::Fit}{\hyperlink{Image}{Image} img}{1028}{functions}{}
\functionlistentry{int}{Function2dWithFitting::Fit}{ImageD img}{1029}{functions}{}
\functionlistentry{int}{Function2dWithFitting::FitFinish}{}{1026}{functions}{}
\functionlistentry{int}{Function2dWithFitting::FitInit}{}{1023}{functions}{}
\functionlistentry{int}{Function2dWithFitting::FitVal}{double x, double y, double g, double w=1.0}{1024}{functions}{}
\functionlistentry{int}{Function2dWithFitting::FitVal}{const \hyperlink{Point}{Point} \&p, double g, double w=1.0}{1025}{functions}{}
\functionlistentry{void}{Function::getCoefficient}{vector\textless {}double\textgreater  \&c}{990}{functions}{}
\functionlistentry{double}{Function::operator()}{double x}{989}{functions}{}
\functionlistentry{int}{Function::setCoefficient}{const vector\textless {}double\textgreater  \&para,int idx=0}{991}{functions}{}
\functionlistentry{int}{FunctionWithFitting::Fit}{const \hyperlink{Matrix}{Matrix} \&m}{995}{functions}{}
\functionlistentry{int}{FunctionWithFitting::FitFinish}{}{994}{functions}{}
\functionlistentry{void}{FunctionWithFitting::FitInit}{void}{992}{functions}{}
\functionlistentry{void}{FunctionWithFitting::FitValue}{double x, double g, double w=1.0}{993}{functions}{}
\functionlistentry{double}{FunctionWithFitting::operator()}{double x}{996}{functions}{}

\letterlabel{Ga}
\letterlabel{G}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ga}
\letterref{Ge}
\letterref{Gr}
\letterlabelend{Ga}
\functionlistentry{double}{GammaFunction}{double x}{1362}{numeric}{}
\functionlistentry{void}{Gaussfit::Finish}{}{1154}{fitting}{}
\functionlistentry{void}{GaussFit::Fit}{const \hyperlink{Matrix}{Matrix} \&xn,const \hyperlink{Vector}{Vector} \&yn}{1155}{fitting}{}
\functionlistentry{}{GaussFit::GaussFit}{int n=0}{1150}{fitting}{}
\functionlistentry{void}{GaussFit::getResult}{\hyperlink{Vector}{Vector} \&v}{1156}{fitting}{}
\functionlistentry{void}{GaussFit::getResult}{vector\textless {}double\textgreater  \&v}{1157}{fitting}{}
\functionlistentry{void}{GaussFit::Init}{int n=0}{1151}{fitting}{}
\functionlistentry{void}{GaussFit::Value}{const \hyperlink{Vector}{Vector} \&x,double y,double w=1.0}{1152}{fitting}{}
\functionlistentry{void}{GaussFit::Value}{vector\textless {}double\textgreater  \&x,double y,double w=1.0}{1153}{fitting}{}
\functionlistentry{double}{GaussFit::Variance}{}{1158}{fitting}{}
\functionlistentry{int}{GaussImg}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&dest,int neighb,double sigma}{352}{filter}{}
\functionlistentry{int}{GaussImg}{const \hyperlink{Image}{Image} \&src,ImageD dest,int neighb,double sigma}{353}{filter}{}
\functionlistentry{int}{GaussImg}{ImageD src,ImageD dest,int neighb,double sigma}{354}{filter}{}
\functionlistentry{double}{GaussRandom}{double sigma}{862}{statistics}{}

\letterlabel{Ge}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ga}
\letterref{Ge}
\letterref{Gr}
\letterlabelend{Ge}
\functionlistentry{double}{GeoObject3d::Distance}{double dx,double dy,double dz}{646}{geoObject3d}{}
\functionlistentry{double}{GeoObject3d::Distance}{const \hyperlink{Vector3d}{Vector3d} \&ob}{647}{geoObject3d}{}
\functionlistentry{}{GeoObject3d::GeoObject3d}{void}{630}{geoObject3d}{}
\functionlistentry{}{GeoObject3d::GeoObject3d}{const \hyperlink{GeoObject3d}{GeoObject3d} \&p}{631}{geoObject3d}{}
\functionlistentry{}{GeoObject3d::GeoObject3d}{const \hyperlink{Vector3d}{Vector3d} \&p}{632}{geoObject3d}{}
\functionlistentry{}{GeoObject3d::GeoObject3d}{double xp,double yp,double zp}{633}{geoObject3d}{}
\functionlistentry{explicit}{GeoObject3d::GeoObject3d}{const \hyperlink{Vector}{Vector} \&v}{634}{geoObject3d}{}
\functionlistentry{explicit}{GeoObject3d::GeoObject3d}{double p[]}{635}{geoObject3d}{}
\functionlistentry{\hyperlink{Vector3d}{Vector3d} \&}{GeoObject3d::Pos}{}{643}{geoObject3d}{}
\functionlistentry{void}{GeoObject3d::set}{const \hyperlink{Vector}{Vector} \&v}{642}{geoObject3d}{}
\functionlistentry{void}{GeoObject3d::setX}{double x}{639}{geoObject3d}{}
\functionlistentry{void}{GeoObject3d::setY}{double y}{640}{geoObject3d}{}
\functionlistentry{void}{GeoObject3d::setZ}{double z}{641}{geoObject3d}{}
\functionlistentry{void}{GeoObject3d::Shift}{double dx,double dy,double dz}{644}{geoObject3d}{}
\functionlistentry{void}{GeoObject3d::Shift}{const \hyperlink{Vector3d}{Vector3d} \&v}{645}{geoObject3d}{}
\functionlistentry{double}{GeoObject3d::Volume}{}{648}{geoObject3d}{}
\functionlistentry{double}{GeoObject3d::X}{void}{636}{geoObject3d}{}
\functionlistentry{double}{GeoObject3d::Y}{void}{637}{geoObject3d}{}
\functionlistentry{double}{GeoObject3d::Z}{void}{638}{geoObject3d}{}
\functionlistentry{double}{GeoObject::Distance}{double x,double y}{507}{geoObject}{}
\functionlistentry{double}{GeoObject::Distance}{IPoint p}{508}{geoObject}{}
\functionlistentry{double}{GeoObject::Distance}{\hyperlink{Point}{Point} p}{509}{geoObject}{}
\functionlistentry{double}{GeoObject::Distance}{const \hyperlink{GeoObject}{GeoObject} \&obj}{510}{geoObject}{}
\functionlistentry{}{GeoObject::GeoObject}{}{497}{geoObject}{}
\functionlistentry{}{GeoObject::GeoObject}{const \hyperlink{GeoObject}{GeoObject} \&c}{498}{geoObject}{}
\functionlistentry{}{GeoObject::GeoObject}{double xm,double ym}{499}{geoObject}{}
\functionlistentry{explicit}{GeoObject::GeoObject}{\hyperlink{Point}{Point} m}{500}{geoObject}{}
\functionlistentry{explicit}{GeoObject::GeoObject}{IPoint m}{501}{geoObject}{}
\functionlistentry{explicit}{GeoObject::GeoObject}{const \hyperlink{Vector}{Vector} \&v}{502}{geoObject}{}
\functionlistentry{\hyperlink{Point}{Point}}{GeoObject::getPos}{}{503}{geoObject}{}
\functionlistentry{bool}{GeoObject::Inside}{double xp,double yp}{511}{geoObject}{}
\functionlistentry{bool}{GeoObject::Inside}{IPoint p}{512}{geoObject}{}
\functionlistentry{bool}{GeoObject::Inside}{\hyperlink{Point}{Point} p}{513}{geoObject}{}
\functionlistentry{void}{GeoObject::setPos}{\hyperlink{Point}{Point} x}{504}{geoObject}{}
\functionlistentry{void}{GeoObject::Shift}{double dx,double dy}{505}{geoObject}{}
\functionlistentry{void}{GeoObject::Shift}{\hyperlink{Point}{Point} p}{506}{geoObject}{}
\functionlistentry{void}{GetAlphaCursor}{int *x,int *y}{1423}{genericTools}{}
\functionlistentry{int}{GetChar}{void}{1429}{genericTools}{}
\functionlistentry{int}{getClosestCorner}{\hyperlink{Point}{Point} p}{605}{geoObject}{}
\functionlistentry{int}{getClosestEdge}{\hyperlink{Point}{Point} p}{606}{geoObject}{}
\functionlistentry{\hyperlink{Contur}{Contur}}{GetContur}{int ps[2],int (*cls)(int,int,void*),void *par,int lng}{442}{conturs}{}
\functionlistentry{int}{GetError}{void}{1550}{errorHandling}{}
\functionlistentry{int}{GetGrayLimits}{const \hyperlink{Image}{Image} \&img,int \&min,int \&max, int mode=GV\_QUANTILE, bool cutMargExtr = false, double minq = 0.1, double maxq = 0.1}{1072}{processing}{}
\functionlistentry{int}{GetGrayLimits}{const \hyperlink{Hist}{Hist} \& h, int\& min, int\& max, int mode=GV\_QUANTILE, bool cutMargExtr = false, double minq = 0.1, double maxq = 0.1 }{1073}{processing}{}
\functionlistentry{double}{GetInterpolVal}{\hyperlink{Image}{Image} img,double x,double y}{69}{Images}{}
\functionlistentry{bool}{GetInterpolVal}{\hyperlink{Image}{Image} img,double x,double y,double \&val}{70}{Images}{}
\functionlistentry{int}{GetKey}{void}{1430}{genericTools}{}
\functionlistentry{MatrixStruct}{GetStatisticCor}{Statistic st,MatrixStruct cor}{1600}{obsolet}{}
\functionlistentry{MatrixStruct}{GetStatisticCov}{Statistic st,MatrixStruct cov}{1599}{obsolet}{}
\functionlistentry{int}{GetStatisticDim}{Statistic st,int *dim}{1596}{obsolet}{}
\functionlistentry{int}{GetStatisticMean}{Statistic st,double *mean}{1598}{obsolet}{}
\functionlistentry{int}{GetStatisticWeight}{Statistic st,double *sweight}{1597}{obsolet}{}
\functionlistentry{int}{GetVal}{const \hyperlink{Image}{Image} \&img,int x,int y}{65}{Images}{}
\functionlistentry{int}{GetVal}{const \hyperlink{Image}{Image} \&img,double x,double y,mode=DEFAULT}{66}{Images}{}
\functionlistentry{int}{GetVal}{const \hyperlink{Image}{Image} img,const IPoint \&p}{68}{Images}{}
\functionlistentry{double}{GetValD}{ImageD img,int x,int y}{81}{Images}{}
\functionlistentry{double}{GetValue}{ImageD img,IPoint p}{83}{Images}{}

\letterlabel{Gr}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ga}
\letterref{Ge}
\letterref{Gr}
\letterlabelend{Gr}
\functionlistentry{int}{GradDirImg}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&dest}{359}{filter}{}
\functionlistentry{int}{GradImg}{const \hyperlink{Image}{Image} \&src,int norm,\hyperlink{Image}{Image} \&dest}{358}{filter}{}
\functionlistentry{int}{GradThreshold}{\hyperlink{Image}{Image} img}{445}{conturs}{}
\functionlistentry{int}{GradXImg}{\hyperlink{Image}{Image} src,int norm,\hyperlink{Image}{Image} dest}{346}{filter}{}
\functionlistentry{int}{GradYImg}{\hyperlink{Image}{Image} src,int norm,\hyperlink{Image}{Image} dest}{347}{filter}{}
\functionlistentry{void}{GraphIter}{\hyperlink{Image}{Image} Original, \hyperlink{Image}{Image} WSImg, \hyperlink{Image}{Image} \&GrwImg, int Threshold}{1144}{segmentation}{}
\functionlistentry{int}{GrayNormalize}{const \hyperlink{Image}{Image} \&src,const \hyperlink{Image}{Image} \& dest, int mode=GV\_QUANTILE, bool cutMargExtr = false, double minq = 0.1, double maxq = 0.1}{1078}{processing}{}
\functionlistentry{int}{GrayNormalize}{const \hyperlink{Image}{Image} \&src, int mode=GV\_QUANTILE, bool cutMargExtr = false, double minq = 0.1, double maxq = 0.1}{1079}{processing}{}
\functionlistentry{int}{GrayTransform}{const \hyperlink{Image}{Image} \&src, const \hyperlink{Image}{Image} \&dest, double a1, double a0}{1074}{processing}{}
\functionlistentry{int}{GrayTransform}{const \hyperlink{Image}{Image} \&src, double a1, double a0}{1075}{processing}{}
\functionlistentry{int}{GrayTransformLimits}{const \hyperlink{Image}{Image} \&src, const \hyperlink{Image}{Image} \& dest, int min, int max}{1076}{processing}{}
\functionlistentry{int}{GrayTransformLimits}{const \hyperlink{Image}{Image} \&src, int min, int max}{1077}{processing}{}

\letterlabel{Ha}
\letterlabel{H}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ha}
\letterref{He}
\letterref{Hi}
\letterref{Hs}
\letterref{Hu}
\letterlabelend{Ha}
\functionlistentry{int}{HaarImg}{\hyperlink{Image}{Image} imgs,int depth,int mode,\hyperlink{Image}{Image} imgs}{1229}{signalTrafo}{}
\functionlistentry{int}{Hartley}{const \hyperlink{Vector}{Vector} \&src,const \hyperlink{Vector}{Vector} \&dst}{1198}{signalTrafo}{}
\functionlistentry{int}{Hartley}{\hyperlink{Vector}{Vector} \&src}{1199}{signalTrafo}{}
\functionlistentry{int}{HartleyImgD}{ImageD src,ImageD dest,int dir=XY}{1201}{signalTrafo}{}
\functionlistentry{int}{HartleyMPImgD}{ImageD mag,ImageD phase,ImageD dst}{1209}{signalTrafo}{}

\letterlabel{He}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ha}
\letterref{He}
\letterref{Hi}
\letterref{Hs}
\letterref{Hu}
\letterlabelend{He}
\functionlistentry{int}{HesseLine}{double p,double phi,int val,\hyperlink{Image}{Image} img}{1323}{graphics}{}
\functionlistentry{int}{HesseLine}{const \hyperlink{Vector}{Vector} \&p,int val,\hyperlink{Image}{Image} img}{1324}{graphics}{}

\letterlabel{Hi}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ha}
\letterref{He}
\letterref{Hi}
\letterref{Hs}
\letterref{Hu}
\letterlabelend{Hi}
\functionlistentry{int}{Hist::Add}{double val}{908}{statistics}{}
\functionlistentry{int}{Hist::Count}{int index}{909}{statistics}{}
\functionlistentry{}{Hist::Hist}{}{903}{statistics}{}
\functionlistentry{}{Hist::Hist}{const \hyperlink{Hist}{Hist} \&h}{904}{statistics}{}
\functionlistentry{}{Hist::Hist}{int knumber,double diff=1.0,double lower=-0.5}{905}{statistics}{}
\functionlistentry{int}{Hist::Limits}{double \&min,double \&max}{911}{statistics}{}
\functionlistentry{int}{Hist::Limits}{double \&min,double \&max,double quant}{912}{statistics}{}
\functionlistentry{double}{Hist::Rel}{int index}{910}{statistics}{}
\functionlistentry{int}{Hist::Reset}{}{906}{statistics}{}
\functionlistentry{int}{Hist::Reset}{int knumber,double diff=1.0,double lower=-0.5}{907}{statistics}{}
\functionlistentry{int}{Hist::Statistic}{int \&nbr,double \&mean,double \&dispers}{914}{statistics}{}
\functionlistentry{int}{Hist::Vis}{int val,\hyperlink{Image}{Image} img}{916}{statistics}{}
\functionlistentry{\hyperlink{Hist}{Hist}}{HistImg}{\hyperlink{Image}{Image} img,int diff=1,int clw=1}{913}{statistics}{}
\functionlistentry{int}{Histogram::addValue}{int val,int count = 1}{887}{statistics}{}
\functionlistentry{int}{Histogram::getCount}{int nr}{888}{statistics}{}
\functionlistentry{vector\textless {}int\textgreater }{Histogram::getCount}{}{890}{statistics}{}
\functionlistentry{void}{Histogram::getCount}{vector\textless {}int\textgreater  \&v}{891}{statistics}{}
\functionlistentry{int}{Histogram::getLimits}{int \&min, int \&max}{895}{statistics}{}
\functionlistentry{int}{Histogram::getLimits}{int \&min, int \&max, double quantil}{896}{statistics}{}
\functionlistentry{double}{Histogram::getRelative}{int nr}{892}{statistics}{}
\functionlistentry{vector\textless {}double\textgreater }{Histogram::getRelative}{}{893}{statistics}{}
\functionlistentry{void}{Histogram::getRelative}{vector\textless {}double\textgreater  \&v}{894}{statistics}{}
\functionlistentry{}{Histogram::Histogram}{}{880}{statistics}{}
\functionlistentry{}{Histogram::Histogram}{int knumber}{881}{statistics}{}
\functionlistentry{}{Histogram::Histogram}{const \hyperlink{Image}{Image} \&img,int diff=1}{882}{statistics}{}
\functionlistentry{int}{Histogram::isValid}{}{885}{statistics}{}
\functionlistentry{int}{Histogram::nClasses}{}{886}{statistics}{}
\functionlistentry{int}{Histogram::operator []}{int nr}{889}{statistics}{}
\functionlistentry{int}{Histogram::reset}{}{883}{statistics}{}
\functionlistentry{int}{Histogram::reset}{int knumber}{884}{statistics}{}
\functionlistentry{int}{Histogram::Statistic}{int \&sum}{897}{statistics}{}
\functionlistentry{int}{Histogram::Statistic}{int \&sum,double \&xm,double \&xs}{898}{statistics}{}
\functionlistentry{int}{Histogram::Statistic}{int \&sum,double \&xm,double \&xs,double \&skew}{899}{statistics}{}
\functionlistentry{int}{Histogram::Vis}{int val,const \hyperlink{Image}{Image} \&img}{901}{statistics}{}
\functionlistentry{int}{HistogramEqual}{const \hyperlink{Image}{Image} \&img1,const \hyperlink{Image}{Image} \&img2}{1080}{processing}{}

\letterlabel{Hs}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ha}
\letterref{He}
\letterref{Hi}
\letterref{Hs}
\letterref{Hu}
\letterlabelend{Hs}
\functionlistentry{int}{HsiToColorImage}{const \hyperlink{Image}{Image} \&hue, const \hyperlink{Image}{Image} \&saturation, const \hyperlink{Image}{Image} \&intensity, const \hyperlink{ColorImage}{ColorImage} \&dst}{1108}{processing}{}
\functionlistentry{void}{HsiToRgb}{double h, double s, double i, \hyperlink{ColorValue}{ColorValue} \&dst, int maxval = 255}{303}{datastructures}{}
\functionlistentry{void}{HsiToRgb}{double h, double s, double i, double \&r, double \&g, double \&b}{307}{datastructures}{}

\letterlabel{Hu}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ha}
\letterref{He}
\letterref{Hi}
\letterref{Hs}
\letterref{Hu}
\letterlabelend{Hu}
\functionlistentry{int}{Hungarian}{const \hyperlink{Matrix}{Matrix} \&cost,IMatrix \&reference\_pairs, double \&min\_cost}{1263}{registration}{}
\functionlistentry{int}{Hungarian}{const \hyperlink{Matrix}{Matrix} \&cost,IMatrix \&reference\_pairs, int mode=0}{1264}{registration}{}

\letterlabel{If}
\letterlabel{I}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{If}
\letterref{Im}
\letterref{In}
\letterref{Is}
\letterlabelend{If}
\functionlistentry{}{IfFailed}{function}{1553}{errorHandling}{}

\letterlabel{Im}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{If}
\letterref{Im}
\letterref{In}
\letterref{Is}
\letterlabelend{Im}
\functionlistentry{void*}{Image-$>$getDataPointer}{}{72}{Images}{}
\functionlistentry{int}{Image-$>$ImageType}{}{71}{Images}{}
\functionlistentry{}{Image3d}{int xs, int ys, int zs, int maxval = 255, double xscale = 1.0, double yscale = 1.0, double zscale = 1.0}{73}{Images}{}
\functionlistentry{}{Image3d}{const std::string \&filemask, double xscale = 1.0, double yscale = 1.0, double zscale = 1.0}{74}{Images}{}
\functionlistentry{}{Image3d}{const Image3d \&src, bool copydata = true}{75}{Images}{}
\functionlistentry{}{Image3d}{const Image3d \&src, Window3d w}{76}{Images}{}
\functionlistentry{void}{Image::copy}{const \hyperlink{Image}{Image} \&src}{7}{Images}{}
\functionlistentry{void}{Image::create}{int xsize,int ysize,int maxval,const string \&title=''''}{5}{Images}{}
\functionlistentry{void}{Image::create}{const \hyperlink{Image}{Image} \&img,const string \&title=''''}{6}{Images}{}
\functionlistentry{static \hyperlink{Image}{Image}}{Image::createImage}{int sizeX, int sizeY, int maxValue, const std::string \&title = ''''}{8}{Images}{}
\functionlistentry{int}{Image::getIntensity}{int x,int y}{42}{Images}{}
\functionlistentry{int}{Image::getIntensity}{IPoint p}{43}{Images}{}
\functionlistentry{int}{Image::getIntensityUnchecked}{int x,int y}{44}{Images}{}
\functionlistentry{int}{Image::getIntensityUnchecked}{IPoint p}{45}{Images}{}
\functionlistentry{int}{Image::getPixel}{int x,int y}{34}{Images}{}
\functionlistentry{int}{Image::getPixel}{IPoint p}{35}{Images}{}
\functionlistentry{int}{Image::getPixelUnchecked}{int x,int y}{38}{Images}{}
\functionlistentry{int}{Image::getPixelUnchecked}{IPoint p}{39}{Images}{}
\functionlistentry{}{Image::Image}{}{3}{Images}{}
\functionlistentry{}{Image::Image}{const \hyperlink{Image}{Image} \&img}{4}{Images}{}
\functionlistentry{}{Image::Image}{const \hyperlink{Image}{Image} \&img,const \hyperlink{Window}{Window} \&w,const string \&title=''''}{30}{Images}{}
\functionlistentry{bool}{Image::inside}{const IPoint p}{58}{Images}{}
\functionlistentry{bool}{Image::inside}{int x,int y}{59}{Images}{}
\functionlistentry{bool}{Image::inside}{const \hyperlink{Window}{Window} \&w}{60}{Images}{}
\functionlistentry{bool}{Image::isValid}{}{13}{Images}{}
\functionlistentry{\hyperlink{Image}{Image}}{Image::operator()}{const \hyperlink{Window}{Window} \&w}{31}{Images}{}
\functionlistentry{int}{Image::setIntensity}{int x,int y,int value}{54}{Images}{}
\functionlistentry{int}{Image::setIntensity}{IPoint p,int value}{55}{Images}{}
\functionlistentry{int}{Image::setIntensityUnchecked}{int x,int y,int value}{56}{Images}{}
\functionlistentry{int}{Image::setIntensityUnchecked}{IPoint p,int value}{57}{Images}{}
\functionlistentry{void}{Image::setPixel}{int x,int y,int value}{46}{Images}{}
\functionlistentry{void}{Image::setPixel}{IPoint p,int value}{47}{Images}{}
\functionlistentry{void}{Image::setPixelUnchecked}{int x,int y,int value}{50}{Images}{}
\functionlistentry{void}{Image::setPixelUnchecked}{IPoint p,int value}{51}{Images}{}
\functionlistentry{}{ImageDFunction::ImageDFunction}{const ImageD \&imgp, int mode = INTERPOL}{1062}{functions}{}
\functionlistentry{}{ImageFunction::ImageFunction}{const \hyperlink{Image}{Image} \&imgp, int mode = INTERPOL}{1061}{functions}{}
\functionlistentry{PeakList}{ImgPeakList}{\hyperlink{Image}{Image} img,\hyperlink{Image}{Image} mark,int panz=0,int mingrw=0, int zykl=FALSE, int noise=0,int feat=IPL\_NOFEAT,int gnull=0}{1258}{registration}{}

\letterlabel{In}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{If}
\letterref{Im}
\letterref{In}
\letterref{Is}
\letterlabelend{In}
\functionlistentry{int}{InfImgFile}{const string \&filename, int \&xsize, int \&ysize, int \&maxval,int \&nr}{117}{imageio}{}
\functionlistentry{int}{InfImgFile}{const string \&filename, int \&xsize, int \&ysize, int \&maxval}{118}{imageio}{}
\functionlistentry{int}{InfVis}{int code}{99}{Visualisierung}{}
\functionlistentry{Statistic}{InitStatistic}{int dim}{1594}{obsolet}{}
\functionlistentry{int}{InitTrans}{double tr[3][3]}{1584}{obsolet}{}
\functionlistentry{int}{Input}{const char *prompt}{1433}{genericTools}{}
\functionlistentry{int}{Input}{const char *prompt,int defvalue}{1434}{genericTools}{}
\functionlistentry{int}{Input}{const string \&prompt}{1435}{genericTools}{}
\functionlistentry{int}{Input}{const string \&prompt,int defvalue}{1436}{genericTools}{}
\functionlistentry{double}{InputD}{const char *prompt}{1437}{genericTools}{}
\functionlistentry{double}{InputD}{const char *prompt,double defvalue}{1438}{genericTools}{}
\functionlistentry{double}{InputD}{const string \&prompt}{1439}{genericTools}{}
\functionlistentry{double}{InputD}{const string \&prompt,double defvalue}{1440}{genericTools}{}
\functionlistentry{void}{InputS}{const char *p,char *s}{1441}{genericTools}{}
\functionlistentry{string}{InputS}{const string \&p}{1442}{genericTools}{}
\functionlistentry{int}{InputString}{char *Str,int Control,int *Ptr,int *scroll}{1443}{genericTools}{}
\functionlistentry{bool}{InsidePolygon}{const \hyperlink{Matrix}{Matrix} \&pl,const \hyperlink{Point}{Point} \&p}{280}{datastructures}{}
\functionlistentry{int}{Integer}{const string\& s}{1409}{genericTools}{}
\functionlistentry{int}{IntegrateFunc}{FuncD func,double s1,double s2,double *prec,double *val}{1402}{numeric}{}
\functionlistentry{int}{IntersecLine}{double p1,double phi1,double p2,double phi2,double p[2]}{1377}{numeric}{}
\functionlistentry{int}{Intersection}{const \hyperlink{Line3d}{Line3d} \&l1,const \hyperlink{Line3d}{Line3d} \&l2,Point3d \&p,double \&dist,\hyperlink{Vector}{Vector} \&res}{1388}{numeric}{}
\functionlistentry{int}{Intersection}{const \hyperlink{Line3d}{Line3d} \&l1,const \hyperlink{Line3d}{Line3d} \&l2,Point3d \&p,double \&dist}{1389}{numeric}{}
\functionlistentry{int}{Intersection}{const \hyperlink{Line3d}{Line3d} \&l1,const \hyperlink{Line3d}{Line3d} \&l2,Point3d \&p}{1390}{numeric}{}
\functionlistentry{int}{Intersection}{const \hyperlink{Line3d}{Line3d} \&l,const \hyperlink{Sphere}{Sphere} \&s,Point3d \&p1,Point3d \&p2}{1391}{numeric}{}
\functionlistentry{int}{InvarFivePoint2d}{double p[5][2],double *i1,double *i2}{1383}{numeric}{}
\functionlistentry{int}{InvarFivePoint3d}{double p[5][3],double *i1,double *i2}{1392}{numeric}{}
\functionlistentry{int}{InvConvolution}{const \hyperlink{Vector}{Vector} \&src1,const \hyperlink{Vector}{Vector} \&src2,double beta,\hyperlink{Vector}{Vector} \&dst}{1217}{signalTrafo}{}
\functionlistentry{int}{InvConvolutionFImgD}{ImageD re1,ImageD im1, ImageD re2,ImageD im2,ImageD re3,ImageD im3,double beta}{1219}{signalTrafo}{}
\functionlistentry{int}{InvConvolutionHImgD}{ImageD im1,ImageD im2,ImageD im3}{1220}{signalTrafo}{}
\functionlistentry{int}{InvConvolutionImg}{const \hyperlink{Image}{Image} \&im1,const \hyperlink{Image}{Image} \&im2, \hyperlink{Image}{Image} \&dst, double factor=0.0,double beta=0.000001,int mode=MD\_USE\_BIAS}{1221}{signalTrafo}{}
\functionlistentry{int}{InvConvolutionImg}{const \hyperlink{Image}{Image} \&im1,const \hyperlink{Image}{Image} \&im2, ImageD dst, double beta=0.000001,int mode=MD\_USE\_BIAS}{1222}{signalTrafo}{}
\functionlistentry{int}{InvConvolutionImgD}{ImageD im1,ImageD im2,ImageD dst,double beta=0.000001,int mode=MD\_USE\_BIAS}{1218}{signalTrafo}{}
\functionlistentry{\hyperlink{Freeman}{Freeman}}{Inverse}{}{473}{conturs}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{Inverse}{const \hyperlink{Matrix}{Matrix} \&m}{1114}{matrixAlgebra}{}
\functionlistentry{int}{InvertImg}{const \hyperlink{Image}{Image} \&img, const \hyperlink{Image}{Image} \&dest}{1092}{processing}{}
\functionlistentry{int}{InvertImg}{const \hyperlink{Image}{Image} \&img}{1093}{processing}{}
\functionlistentry{MatrixStruct}{InvertMat}{MatrixStruct A,MatrixStruct B}{1582}{obsolet}{}
\functionlistentry{int}{InvertTrans}{double tr[3][3]}{1588}{obsolet}{}
\functionlistentry{int}{InvRadonImg}{const \hyperlink{Image}{Image} \&radon,\hyperlink{Image}{Image} \&res,int fmax=-1}{1232}{signalTrafo}{}

\letterlabel{Is}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{If}
\letterref{Im}
\letterref{In}
\letterref{Is}
\letterlabelend{Is}
\functionlistentry{bool}{IsImg}{const \hyperlink{Image}{Image} \&img}{14}{Images}{}
\functionlistentry{bool}{IsImg}{const \hyperlink{ColorImage}{ColorImage} \&img}{26}{Images}{}
\functionlistentry{int}{IsMatrix}{MatrixStruct mat}{1577}{obsolet}{}
\functionlistentry{int}{isPolygon}{const \hyperlink{Matrix}{Matrix} \& pl}{279}{datastructures}{}
\functionlistentry{bool}{IsPositivDefinit}{const \hyperlink{Matrix}{Matrix} \&m}{1117}{matrixAlgebra}{}

\letterlabel{Kl}
\letterlabel{K}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Kl}
\letterlabelend{Kl}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{KLT}{const \hyperlink{Matrix}{Matrix} \&m}{876}{statistics}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{KLT}{const \hyperlink{Matrix}{Matrix} \&m,\hyperlink{Vector}{Vector} \&r}{877}{statistics}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{KLT}{const \hyperlink{Statistics}{Statistics} \&st}{878}{statistics}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{KLT}{const \hyperlink{Statistics}{Statistics} \&st,\hyperlink{Vector}{Vector} \&r}{879}{statistics}{}

\letterlabel{La}
\letterlabel{L}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{La}
\letterref{Le}
\letterref{Li}
\letterref{Lm}
\letterref{Lo}
\letterref{Ls}
\letterref{Lu}
\letterlabelend{La}
\functionlistentry{int}{LabToColorImage}{const \hyperlink{Image}{Image} \&lImg, const \hyperlink{Image}{Image} \&aImg, const \hyperlink{Image}{Image} \&bImg, const \hyperlink{ColorImage}{ColorImage} \&src}{1110}{processing}{}
\functionlistentry{void}{LabToRgb}{double l, double a, double b, \hyperlink{ColorValue}{ColorValue} \&dst, int maxval = 255}{306}{datastructures}{}
\functionlistentry{void}{LabToRgb}{double l, double a, double b, double \&rr, double \&gg, double \&bb}{316}{datastructures}{}
\functionlistentry{void}{LabToXyz}{double l, double a, double b, double \&x, double \&y, double \&z}{314}{datastructures}{}
\functionlistentry{int}{LaplaceImg}{\hyperlink{Image}{Image} src,int norm,\hyperlink{Image}{Image} dest}{351}{filter}{}
\functionlistentry{int}{LaplaceXImg}{\hyperlink{Image}{Image} src,int norm,\hyperlink{Image}{Image} dest}{349}{filter}{}
\functionlistentry{int}{LaplaceYImg}{\hyperlink{Image}{Image} src,int norm,\hyperlink{Image}{Image} dest}{350}{filter}{}

\letterlabel{Le}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{La}
\letterref{Le}
\letterref{Li}
\letterref{Lm}
\letterref{Lo}
\letterref{Ls}
\letterref{Lu}
\letterlabelend{Le}
\functionlistentry{double}{LengthVec}{double v[3]}{1557}{obsolet}{}
\functionlistentry{double}{LengthVecRn}{double *v,int dim}{1567}{obsolet}{}

\letterlabel{Li}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{La}
\letterref{Le}
\letterref{Li}
\letterref{Lm}
\letterref{Lo}
\letterref{Ls}
\letterref{Lu}
\letterlabelend{Li}
\functionlistentry{int}{limited}{int val,int min,int max}{1343}{numeric}{}
\functionlistentry{int}{limited}{int val,\hyperlink{Image}{Image} img}{1344}{numeric}{}
\functionlistentry{int}{Line}{int x1,int y1,int x2,int y2,int val,int mode,\hyperlink{Image}{Image} img}{1317}{graphics}{}
\functionlistentry{int}{Line}{int x1,int y1,int x2,int y2,int val,\hyperlink{Image}{Image} img}{1318}{graphics}{}
\functionlistentry{int}{Line}{const IVector \&p1,const IVector \&p2,int val,int mode,\hyperlink{Image}{Image} img}{1319}{graphics}{}
\functionlistentry{int}{Line}{const IVector \&p1,const IVector \&p2,int val,\hyperlink{Image}{Image} img}{1320}{graphics}{}
\functionlistentry{int}{Line}{const \hyperlink{Point}{Point} \&p1,const \hyperlink{Point}{Point} \&p2,int val,int mode,\hyperlink{Image}{Image} img}{1321}{graphics}{}
\functionlistentry{int}{Line}{const \hyperlink{Point}{Point} \&p1,const \hyperlink{Point}{Point} \&p2,int val,\hyperlink{Image}{Image} img}{1322}{graphics}{}
\functionlistentry{\hyperlink{Vector3d}{Vector3d} \&}{Line3d::DP}{}{676}{geoObject3d}{}
\functionlistentry{double}{Line3d::DX}{}{673}{geoObject3d}{}
\functionlistentry{double}{Line3d::DY}{}{674}{geoObject3d}{}
\functionlistentry{double}{Line3d::DZ}{}{675}{geoObject3d}{}
\functionlistentry{}{Line3d::Line3d}{}{659}{geoObject3d}{}
\functionlistentry{}{Line3d::Line3d}{double xp,double yp,double zp,double x2p,double y2p,double z2p}{660}{geoObject3d}{}
\functionlistentry{}{Line3d::Line3d}{const Point3d \&p1,const Point3d \&p2}{661}{geoObject3d}{}
\functionlistentry{}{Line3d::Line3d}{const \hyperlink{Line3d}{Line3d} \&p}{662}{geoObject3d}{}
\functionlistentry{explicit}{Line3d::Line3d}{const \hyperlink{Vector}{Vector} \&v}{663}{geoObject3d}{}
\functionlistentry{explicit}{Line3d::Line3d}{double d[]}{664}{geoObject3d}{}
\functionlistentry{\hyperlink{Vector3d}{Vector3d}}{Line3d::operator()}{double p}{677}{geoObject3d}{}
\functionlistentry{\hyperlink{Vector3d}{Vector3d} \&}{Line3d::P1}{}{668}{geoObject3d}{}
\functionlistentry{\hyperlink{Vector3d}{Vector3d}}{Line3d::P2}{}{672}{geoObject3d}{}
\functionlistentry{double}{Line3d::Volume}{}{678}{geoObject3d}{}
\functionlistentry{double}{Line3d::X1}{}{665}{geoObject3d}{}
\functionlistentry{double}{Line3d::X2}{}{669}{geoObject3d}{}
\functionlistentry{double}{Line3d::Y1}{}{666}{geoObject3d}{}
\functionlistentry{double}{Line3d::Y2}{}{670}{geoObject3d}{}
\functionlistentry{double}{Line3d::Z1}{}{667}{geoObject3d}{}
\functionlistentry{double}{Line3d::Z2}{}{671}{geoObject3d}{}
\functionlistentry{int}{LinearOptimization}{int rows,int columns,double **matrix,double *rside,double *costfunction,double *solution,double \&costs}{1136}{matrixAlgebra}{}
\functionlistentry{\hyperlink{Contur}{Contur}}{LineContur}{\hyperlink{Contur}{Contur} c,int p1[2][,int p2[2]]}{1331}{graphics}{}
\functionlistentry{double}{LineSeg::Angle}{const \hyperlink{LineSeg}{LineSeg} \&sec}{570}{geoObject}{}
\functionlistentry{void}{LineSeg::CalcHesse}{double \&p,double \&phi}{566}{geoObject}{}
\functionlistentry{\hyperlink{Point}{Point}}{LineSeg::ClosestPoint}{\hyperlink{Point}{Point} p}{573}{geoObject}{}
\functionlistentry{\hyperlink{Point}{Point}}{LineSeg::ClosestPoint}{\hyperlink{Point}{Point} p,double \&my}{574}{geoObject}{}
\functionlistentry{double}{LineSeg::Distance}{\hyperlink{Point}{Point} p}{575}{geoObject}{}
\functionlistentry{\hyperlink{Point}{Point}}{LineSeg::getP1}{}{558}{geoObject}{}
\functionlistentry{\hyperlink{Point}{Point}}{LineSeg::getP2}{}{559}{geoObject}{}
\functionlistentry{bool}{LineSeg::Intersection}{const \hyperlink{LineSeg}{LineSeg} \&second}{576}{geoObject}{}
\functionlistentry{bool}{LineSeg::Intersection}{const \hyperlink{LineSeg}{LineSeg} \&second,\hyperlink{Point}{Point} \&ip}{577}{geoObject}{}
\functionlistentry{bool}{LineSeg::Intersection}{const \hyperlink{LineSeg}{LineSeg} \&second,\hyperlink{Point}{Point} \&ip,double \&my1,double \&my2}{578}{geoObject}{}
\functionlistentry{bool}{LineSeg::LeftOf}{\hyperlink{Point}{Point} p}{572}{geoObject}{}
\functionlistentry{double}{LineSeg::LimitedMy}{double my}{565}{geoObject}{}
\functionlistentry{}{LineSeg::LineSeg}{}{550}{geoObject}{}
\functionlistentry{}{LineSeg::LineSeg}{\hyperlink{Point}{Point} p1,\hyperlink{Point}{Point} p2,int type=\hyperlink{LineSeg}{LineSeg}::segment}{551}{geoObject}{}
\functionlistentry{}{LineSeg::LineSeg}{IPoint p1,IPoint p2,int type=\hyperlink{LineSeg}{LineSeg}::segment}{552}{geoObject}{}
\functionlistentry{}{LineSeg::LineSeg}{const \hyperlink{LineSeg}{LineSeg} \&p}{553}{geoObject}{}
\functionlistentry{}{LineSeg::LineSeg}{double x1,double y1,double x2,double y2,int type=\hyperlink{LineSeg}{LineSeg}::segment}{554}{geoObject}{}
\functionlistentry{}{LineSeg::LineSeg}{double p,double phi}{555}{geoObject}{}
\functionlistentry{explicit}{LineSeg::LineSeg}{const \hyperlink{Vector}{Vector} \&v,int type=\hyperlink{LineSeg}{LineSeg}::segment}{556}{geoObject}{}
\functionlistentry{explicit}{LineSeg::LineSeg}{double d[],int type=\hyperlink{LineSeg}{LineSeg}::segment}{557}{geoObject}{}
\functionlistentry{\hyperlink{Point}{Point}}{LineSeg::Normal}{}{579}{geoObject}{}
\functionlistentry{double}{LineSeg::OrientationAngle}{}{569}{geoObject}{}
\functionlistentry{double}{LineSeg::P}{}{567}{geoObject}{}
\functionlistentry{double}{LineSeg::Phi}{}{568}{geoObject}{}
\functionlistentry{\hyperlink{Point}{Point}}{LineSeg::RelPoint}{double my}{564}{geoObject}{}
\functionlistentry{bool}{LineSeg::RightOf}{\hyperlink{Point}{Point} p}{571}{geoObject}{}
\functionlistentry{void}{LineSeg::setP1}{\hyperlink{Point}{Point} p}{560}{geoObject}{}
\functionlistentry{void}{LineSeg::setP2}{\hyperlink{Point}{Point} p}{561}{geoObject}{}
\functionlistentry{void}{LineSeg::setType}{int type}{563}{geoObject}{}
\functionlistentry{int}{LineSeg::Type}{}{562}{geoObject}{}
\functionlistentry{Segment}{LineSegContur}{\hyperlink{Contur}{Contur} c,int mlng,double mdist}{1184}{fitting}{}
\functionlistentry{Segment}{LineSegPointList}{PointList pl,int closed,int mlng,double mdist}{1189}{fitting}{}

\letterlabel{Lm}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{La}
\letterref{Le}
\letterref{Li}
\letterref{Lm}
\letterref{Lo}
\letterref{Ls}
\letterref{Lu}
\letterlabelend{Lm}
\functionlistentry{int}{LMDif}{\hyperlink{Vector}{Vector} \&variable,int optnumber,LMFunc *func,int funcdim,int \&inumber,int maxiter=MAX\_INT}{1137}{matrixAlgebra}{}
\functionlistentry{int}{LMDif}{\hyperlink{Vector}{Vector} \&variable,int optnumber,LMFunc *func,int funcdim}{1138}{matrixAlgebra}{}
\functionlistentry{int}{LMDif}{\hyperlink{Vector}{Vector} \&variable,IVector optvar, LMFunc *func,int funcdim,int \&inumber,int maxiter=MAX\_INT}{1139}{matrixAlgebra}{}
\functionlistentry{int}{LMDif}{\hyperlink{Vector}{Vector} \&variable,IVector optvar,LMFunc *func,int funcdim}{1140}{matrixAlgebra}{}
\functionlistentry{int}{LMDif}{const vector\textless {}double*\textgreater  \&ov,const LMFunctor \&fn, int maxiter=MAX\_INT}{1141}{matrixAlgebra}{}

\letterlabel{Lo}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{La}
\letterref{Le}
\letterref{Li}
\letterref{Lm}
\letterref{Lo}
\letterref{Ls}
\letterref{Lu}
\letterlabelend{Lo}
\functionlistentry{int}{LocalSeg}{\hyperlink{Image}{Image} source,\hyperlink{Image}{Image} oimg,int neighb,int level}{443}{conturs}{}
\functionlistentry{int}{LocalSeg}{\hyperlink{Image}{Image} source,\hyperlink{Image}{Image} oimg,int neighb,int level1,int level2}{444}{conturs}{}
\functionlistentry{int}{LogImgD}{ImageD src,ImageD dest}{1100}{processing}{}
\functionlistentry{int}{LogPolarC}{ImageD src,ImageD dest,double x,double y,double \&r,double \&phi,double r1=1,double r2=0,int sym=2}{1106}{processing}{}
\functionlistentry{int}{LogPolarImg}{const \hyperlink{Image}{Image} \&src, const \hyperlink{Image}{Image} \&dest,double r1=1,double r2=0,int sym=2}{1105}{processing}{}
\functionlistentry{int}{LogPolarImgD}{ImageD src,ImageD dest,double r1=1,double r2=0,int sym=2}{1104}{processing}{}
\functionlistentry{string}{lowercase}{const string \&s}{1411}{genericTools}{}

\letterlabel{Ls}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{La}
\letterref{Le}
\letterref{Li}
\letterref{Lm}
\letterref{Lo}
\letterref{Ls}
\letterref{Lu}
\letterlabelend{Ls}
\functionlistentry{int}{LSIFilter::Filter}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&dst,int offset}{330}{filter}{}
\functionlistentry{int}{LSIFilter::Filter}{const \hyperlink{Image}{Image} \&src,ImageD dst}{331}{filter}{}
\functionlistentry{int}{LSIFilter::Filter}{ImageD src,ImageD dst}{332}{filter}{}
\functionlistentry{double}{LSIFilter::getMask}{int x,int y}{323}{filter}{}
\functionlistentry{}{LSIFilter::LSIFilter}{}{318}{filter}{}
\functionlistentry{}{LSIFilter::LSIFilter}{const \hyperlink{LSIFilter}{LSIFilter} \&f}{319}{filter}{}
\functionlistentry{}{LSIFilter::LSIFilter}{const \hyperlink{Matrix}{Matrix} \&m}{320}{filter}{}
\functionlistentry{}{LSIFilter::LSIFilter}{const IMatrix \&m,int norm}{321}{filter}{}
\functionlistentry{}{LSIFilter::LSIFilter}{int *m,int norm}{322}{filter}{}
\functionlistentry{void}{LSIFilter::NegateMask}{}{324}{filter}{}
\functionlistentry{double}{LSIFilter::proposeOffset}{const \hyperlink{Image}{Image} \&img}{325}{filter}{}
\functionlistentry{int}{LSIImg}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&dst,const \hyperlink{LSIFilter}{LSIFilter} \&f,int offset}{333}{filter}{}
\functionlistentry{int}{LSIImg}{\hyperlink{Image}{Image} src,int nx,int ny,int *mask,int norm,int offset,\hyperlink{Image}{Image} dest}{334}{filter}{}
\functionlistentry{int}{LSIImg}{\hyperlink{Image}{Image} src,int nx,int ny,double *mask,int offset,\hyperlink{Image}{Image} dest}{335}{filter}{}
\functionlistentry{int}{LSIImg}{\hyperlink{Image}{Image} src,const \hyperlink{Matrix}{Matrix} \&mask,int offset,\hyperlink{Image}{Image} dest}{336}{filter}{}
\functionlistentry{int}{LSIImg}{\hyperlink{Image}{Image} src,const IMatrix \&mask,int norm,int offset,\hyperlink{Image}{Image} dest}{337}{filter}{}

\letterlabel{Lu}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{La}
\letterref{Le}
\letterref{Li}
\letterref{Lm}
\letterref{Lo}
\letterref{Ls}
\letterref{Lu}
\letterlabelend{Lu}
\functionlistentry{int}{LUDecomposition}{const \hyperlink{Matrix}{Matrix} \&a,\hyperlink{Matrix}{Matrix} \&L,\hyperlink{Matrix}{Matrix} \&U}{1121}{matrixAlgebra}{}
\functionlistentry{int}{LUDecompositionPacked}{const \hyperlink{Matrix}{Matrix} \&a,\hyperlink{Matrix}{Matrix} \&LU,IVector \&indx,bool pivot=true}{1122}{matrixAlgebra}{}
\functionlistentry{\hyperlink{Vector}{Vector}}{LUSolve}{const \hyperlink{Matrix}{Matrix} \&LU,const IVector \&indx,const \hyperlink{Vector}{Vector} \&i}{1123}{matrixAlgebra}{}

\letterlabel{Ma}
\letterlabel{M}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ma}
\letterref{Me}
\letterref{Mi}
\letterref{Mk}
\letterref{Mo}
\letterref{Mp}
\letterref{Mu}
\letterlabelend{Ma}
\functionlistentry{\hyperlink{Contur}{Contur}}{MakeContur}{}{604}{geoObject}{}
\functionlistentry{int}{MarkContur}{\hyperlink{Contur}{Contur} c,int val,\hyperlink{Image}{Image} img}{1336}{graphics}{}
\functionlistentry{int}{Marker}{int mode, int x,int y,int val,int size,\hyperlink{Image}{Image} img}{1311}{graphics}{}
\functionlistentry{int}{Marker}{int mode, const IVector \&p,int val,int size,\hyperlink{Image}{Image} img}{1312}{graphics}{}
\functionlistentry{int}{Marker}{int mode, const \hyperlink{Point}{Point} \&p,int val,int size,\hyperlink{Image}{Image} img}{1313}{graphics}{}
\functionlistentry{\hyperlink{Trafo}{Trafo}}{MatchObject}{(const \hyperlink{Contur}{Contur} \&cont1,const \hyperlink{Contur}{Contur} \&cont2,int tmode,double \&eval,int mmode=MM\_SQUARE,int anz=0)}{1266}{registration}{}
\functionlistentry{\hyperlink{Trafo}{Trafo}}{MatchObject}{(const \hyperlink{Contur}{Contur} \&cont1,const \hyperlink{Contur}{Contur} \&cont2,int tmode=TRM\_AFFINE)}{1267}{registration}{}
\functionlistentry{\hyperlink{Trafo}{Trafo}}{MatchObject}{(const \hyperlink{Contur}{Contur} \&cont1,const \hyperlink{Matrix}{Matrix} \&pl2,int tmode,double \&eval,int mmode=MM\_SQUARE,int anz=0)}{1268}{registration}{}
\functionlistentry{\hyperlink{Trafo}{Trafo}}{MatchObject}{(const \hyperlink{Contur}{Contur} \&cont1,const \hyperlink{Matrix}{Matrix} \&pl2,int tmode=TRM\_AFFINE)}{1269}{registration}{}
\functionlistentry{\hyperlink{Trafo}{Trafo}}{MatchObject}{(const \hyperlink{Matrix}{Matrix} \&pl1,const \hyperlink{Matrix}{Matrix} \&pl2,int tmode,double \&eval,int mmode=MM\_SQUARE,int anz=0)}{1270}{registration}{}
\functionlistentry{\hyperlink{Trafo}{Trafo}}{MatchObject}{(const \hyperlink{Matrix}{Matrix} \&pl1,const \hyperlink{Matrix}{Matrix} \&pl2,int tmode=TRM\_AFFINE)}{1271}{registration}{}
\functionlistentry{\hyperlink{Trafo}{Trafo}}{MatchObject}{(const \hyperlink{Matrix}{Matrix} \&pl1,const \hyperlink{Contur}{Contur} \&cont2,int tmode,double \&eval,int mmode=MM\_SQUARE,int anz=0)}{1272}{registration}{}
\functionlistentry{\hyperlink{Trafo}{Trafo}}{MatchObject}{(const \hyperlink{Matrix}{Matrix} \&pl1,const \hyperlink{Contur}{Contur} \&cont2,int tmode=TRM\_AFFINE)}{1273}{registration}{}
\functionlistentry{\hyperlink{Trafo}{Trafo}}{MatchPointlists}{const \hyperlink{Matrix}{Matrix} \&p1,const \hyperlink{Matrix}{Matrix} \&p2,int mode=TRM\_PROJECTIVE}{1244}{registration}{}
\functionlistentry{\hyperlink{Trafo}{Trafo}}{MatchPointlists}{const \hyperlink{Matrix}{Matrix} \&p1,const \hyperlink{Matrix}{Matrix} \&p2, int mode,const \hyperlink{Vector}{Vector} \&w}{1245}{registration}{}
\functionlistentry{\hyperlink{Trafo}{Trafo}}{MatchPointlists}{const vector\textless {}\hyperlink{Point}{Point}\textgreater  \&pl1, const vector\textless {}\hyperlink{Point}{Point}\textgreater  \&pl2, int mode = TRM\_PROJECTIVE}{1246}{registration}{}
\functionlistentry{\hyperlink{Trafo}{Trafo}}{MatchPointlists}{const vector\textless {}\hyperlink{Point}{Point}\textgreater  \&pl1, const vector\textless {}\hyperlink{Point}{Point}\textgreater  \&pl2, int mode = TRM\_PROJECTIVE, const vector\textless {}double\textgreater  \&weight}{1247}{registration}{}
\functionlistentry{\hyperlink{Trafo}{Trafo}}{MatchPointlists}{PointList pl1,PointList pl2,int mode}{1248}{registration}{}
\functionlistentry{\hyperlink{Trafo}{Trafo}}{MatchPointlistsLinOpt}{const \hyperlink{Matrix}{Matrix} \&p1,const \hyperlink{Matrix}{Matrix} \&p2,int mode=TRM\_AFFINE}{1249}{registration}{}
\functionlistentry{\hyperlink{Trafo}{Trafo}}{MatchPointlistsLinOpt}{const \hyperlink{Matrix}{Matrix} \&p1,const \hyperlink{Matrix}{Matrix} \&p2,int mode,const \hyperlink{Vector}{Vector} \&w,double limit=1000000.0}{1250}{registration}{}
\functionlistentry{int}{MatchPointlistsLinOpt}{PointList pl1,PointList pl2,double tr[][3],int mode=TRM\_AFFINE,double limit=1000000.0}{1251}{registration}{}
\functionlistentry{MatrixStruct}{Mateigen}{MatrixStruct A,double *eval,MatrixStruct evect}{1134}{matrixAlgebra}{}
\functionlistentry{int}{Matrix::AddDyadicProd}{const \hyperlink{Vector}{Vector} \& v,const \hyperlink{Vector}{Vector} \& w,double factor}{276}{datastructures}{}
\functionlistentry{int}{Matrix::AddDyadicProd}{const \hyperlink{Vector}{Vector} \& v, double factor}{277}{datastructures}{}
\functionlistentry{int}{Matrix::cols}{}{265}{datastructures}{}
\functionlistentry{int}{Matrix::DeleteCol}{int n}{271}{datastructures}{}
\functionlistentry{int}{Matrix::DeleteCol}{int n1,int n2}{272}{datastructures}{}
\functionlistentry{int}{Matrix::DeleteRow}{int n}{269}{datastructures}{}
\functionlistentry{int}{Matrix::DeleteRow}{int n1,int n2}{270}{datastructures}{}
\functionlistentry{void}{Matrix::ExchangeCol}{int i1,int i2}{268}{datastructures}{}
\functionlistentry{void}{Matrix::ExchangeRow}{int i1,int i2}{267}{datastructures}{}
\functionlistentry{}{Matrix::Matrix}{}{255}{datastructures}{}
\functionlistentry{}{Matrix::Matrix}{const int rows,const int cols,int initmode=0}{256}{datastructures}{}
\functionlistentry{explicit}{Matrix::Matrix}{const int rows,const int cols,double *init}{257}{datastructures}{}
\functionlistentry{}{Matrix::Matrix}{const \hyperlink{Matrix}{Matrix}\& m}{258}{datastructures}{}
\functionlistentry{}{Matrix::Matrix}{const IMatrix\& im}{259}{datastructures}{}
\functionlistentry{explicit}{Matrix::Matrix}{const \hyperlink{Image}{Image}\& m,int mode=RAW,int sign=UNSIGNED}{260}{datastructures}{}
\functionlistentry{explicit}{Matrix::Matrix}{const ImageD \& m}{261}{datastructures}{}
\functionlistentry{double}{Matrix::MaxVal}{}{273}{datastructures}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{Matrix::MulTrans}{const \hyperlink{Matrix}{Matrix} \&m2}{262}{datastructures}{}
\functionlistentry{\hyperlink{Vector}{Vector}}{Matrix::MulTrans}{const \hyperlink{Vector}{Vector} \&v}{263}{datastructures}{}
\functionlistentry{int}{Matrix::rows}{}{264}{datastructures}{}
\functionlistentry{int}{Matrix::Sort}{int col=0,bool asc=true}{278}{datastructures}{}
\functionlistentry{void}{Matrix::SumCols}{\hyperlink{Vector}{Vector} \&sum}{275}{datastructures}{}
\functionlistentry{void}{Matrix::SumRows}{\hyperlink{Vector}{Vector} \&sum}{274}{datastructures}{}
\functionlistentry{int}{Max}{int val1,int val2}{1352}{numeric}{}
\functionlistentry{double}{MaxD}{double val1,double val2}{1354}{numeric}{}
\functionlistentry{int}{MaxImg}{const \hyperlink{Image}{Image} \&img1,const \hyperlink{Image}{Image} \&img2,const \hyperlink{Image}{Image} \&dest,int mode=MD\_NORMALIZE}{1090}{processing}{}

\letterlabel{Me}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ma}
\letterref{Me}
\letterref{Mi}
\letterref{Mk}
\letterref{Mo}
\letterref{Mp}
\letterref{Mu}
\letterlabelend{Me}
\functionlistentry{\hyperlink{Vector}{Vector}}{Mean}{const \hyperlink{Statistics}{Statistics} \&st}{868}{statistics}{}
\functionlistentry{int}{MeanImg}{\hyperlink{Image}{Image} src,\hyperlink{Image}{Image} dest}{348}{filter}{}
\functionlistentry{int}{MedianImg}{const \hyperlink{Image}{Image} \&img,int size,\hyperlink{Image}{Image} \&dest}{386}{filter}{}
\functionlistentry{int}{Menu}{const vector$<$string$>$ \&t,int x1=-1,int y1=-1,int x2=-1,int y2=-1, bool restore=false,const string \&title=''''}{1447}{genericTools}{}
\functionlistentry{int}{Menu}{const vector$<$string$>$ \&t,const vector$<$int$>$ \&menuId, int x1=2,int y1=2,int x2=30,int y2=22, bool restore=false,const string \&title=''''}{1448}{genericTools}{}
\functionlistentry{void}{Message}{char *name, char *msg, int code}{1546}{errorHandling}{}
\functionlistentry{int}{MexicanHatImg}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&dest,double sigma,int neighb=0}{355}{filter}{}
\functionlistentry{int}{MexicanHatImg}{const \hyperlink{Image}{Image} \&src,ImageD dest,double sigma,int neighb=0}{356}{filter}{}
\functionlistentry{int}{MexicanHatImg}{ImageD src,ImageD dest,double sigma,int neighb=0}{357}{filter}{}

\letterlabel{Mi}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ma}
\letterref{Me}
\letterref{Mi}
\letterref{Mk}
\letterref{Mo}
\letterref{Mp}
\letterref{Mu}
\letterlabelend{Mi}
\functionlistentry{int}{Min}{int val1,int val2}{1353}{numeric}{}
\functionlistentry{double}{MinD}{double val1,double val2}{1355}{numeric}{}
\functionlistentry{int}{MinImg}{const \hyperlink{Image}{Image} \&img1,const \hyperlink{Image}{Image} \&img2,const \hyperlink{Image}{Image} \&dest,int mode=MD\_NORMALIZE}{1091}{processing}{}
\functionlistentry{int}{MinMaxImg}{const \hyperlink{Image}{Image} \&src,int nx, int ny,\hyperlink{Image}{Image} \&minimg, \hyperlink{Image}{Image} \&maximg}{383}{filter}{}
\functionlistentry{double}{MinTree::getCluster}{\hyperlink{Forest}{Forest} \&f, int nCluster}{1294}{graph}{}
\functionlistentry{double}{MinTree::getForest}{\hyperlink{Forest}{Forest} \&f, double maxlen}{1293}{graph}{}
\functionlistentry{double}{MinTree::getTree}{\hyperlink{Forest}{Forest} \&f}{1292}{graph}{}
\functionlistentry{}{MinTree::MinTree}{const vector\textless {}\hyperlink{Point}{Point}\textgreater  \&pointlist}{1289}{graph}{}
\functionlistentry{}{MinTree::MinTree}{const vector\textless {}vector\textless {}double\textgreater  \textgreater  \&nodelist, const VectorDistance \&vd = EuclideanVectorDistance()}{1290}{graph}{}
\functionlistentry{}{MinTree::MinTree}{const \hyperlink{Matrix}{Matrix} \&distances}{1291}{graph}{}

\letterlabel{Mk}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ma}
\letterref{Me}
\letterref{Mi}
\letterref{Mk}
\letterref{Mo}
\letterref{Mp}
\letterref{Mu}
\letterlabelend{Mk}
\functionlistentry{\hyperlink{LSIFilter}{LSIFilter}}{mkDirDoBFilter}{int n,double dir,double len,double width}{328}{filter}{}
\functionlistentry{\hyperlink{LSIFilter}{LSIFilter}}{mkDirEdgeFilter}{int n,double dir,double rad}{329}{filter}{}
\functionlistentry{\hyperlink{LSIFilter}{LSIFilter}}{mkDirSmearFilter}{int n,double dir,double len,double width}{327}{filter}{}
\functionlistentry{\hyperlink{LSIFilter}{LSIFilter}}{mkPolynomFilter}{int n,int grad,int i,int j}{326}{filter}{}

\letterlabel{Mo}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ma}
\letterref{Me}
\letterref{Mi}
\letterref{Mk}
\letterref{Mo}
\letterref{Mp}
\letterref{Mu}
\letterlabelend{Mo}
\functionlistentry{int}{Mod}{int val,int mod}{1357}{numeric}{}
\functionlistentry{ImageD}{MomentImg}{\hyperlink{Image}{Image} imgs,int p,int q,int n,ImageD imgd}{1230}{signalTrafo}{}
\functionlistentry{int}{MomentPolygon}{PointList p,double m[15],double s[2]}{1603}{obsolet}{}
\functionlistentry{int}{MomentPolygon}{const \hyperlink{Matrix}{Matrix} \&p,double m[15],double s[2]}{1604}{obsolet}{}
\functionlistentry{int}{MomentRegion}{\hyperlink{Contur}{Contur} c, double m[15], double s[2]}{1606}{obsolet}{}
\functionlistentry{\hyperlink{Vector}{Vector}}{Moments::AffineAlgebraicInvariants}{}{821}{moments}{}
\functionlistentry{\hyperlink{Vector}{Vector}}{Moments::AffineHuInvariants}{}{823}{moments}{}
\functionlistentry{\hyperlink{Moments}{Moments}}{Moments::AffineTransform}{const \hyperlink{Trafo}{Trafo} \&tr}{820}{moments}{}
\functionlistentry{\hyperlink{Moments}{Moments}}{Moments::CentralMoments}{}{813}{moments}{}
\functionlistentry{void}{Moments::getCentroid}{double \&xc,double \&yc}{812}{moments}{}
\functionlistentry{\hyperlink{Vector}{Vector}}{Moments::HuInvariants}{}{822}{moments}{}
\functionlistentry{double *}{Moments::Mom}{}{810}{moments}{}
\functionlistentry{}{Moments::Moments}{}{803}{moments}{}
\functionlistentry{}{Moments::Moments}{double m[15]}{804}{moments}{}
\functionlistentry{}{Moments::Moments}{const \hyperlink{Region}{Region} \&r}{805}{moments}{}
\functionlistentry{}{Moments::Moments}{const \hyperlink{Contur}{Contur} \&c}{806}{moments}{}
\functionlistentry{}{Moments::Moments}{const \hyperlink{Matrix}{Matrix} \&p}{807}{moments}{}
\functionlistentry{}{Moments::Moments}{PointList p}{808}{moments}{}
\functionlistentry{}{Moments::Moments}{PointList p,int a1,int a2}{809}{moments}{}
\functionlistentry{\hyperlink{Moments}{Moments}}{Moments::Normalize}{\hyperlink{Trafo}{Trafo} \&tr,nmode mode=\hyperlink{Moments}{Moments}::standard}{837}{moments}{}
\functionlistentry{\hyperlink{Moments}{Moments}}{Moments::Normalize}{nmode mode=\hyperlink{Moments}{Moments}::standard}{838}{moments}{}
\functionlistentry{\hyperlink{Moments}{Moments}}{Moments::NormalizeRotation}{}{834}{moments}{}
\functionlistentry{\hyperlink{Moments}{Moments}}{Moments::NormalizeRotation}{double \&phi}{835}{moments}{}
\functionlistentry{\hyperlink{Moments}{Moments}}{Moments::NormalizeRotation}{double \&c,double \&s}{836}{moments}{}
\functionlistentry{\hyperlink{Moments}{Moments}}{Moments::NormalizeScaling}{scalemode mode=anisotropic}{831}{moments}{}
\functionlistentry{\hyperlink{Moments}{Moments}}{Moments::NormalizeScaling}{double \&alpha}{832}{moments}{}
\functionlistentry{\hyperlink{Moments}{Moments}}{Moments::NormalizeScaling}{double \&alpha,double \&beta}{833}{moments}{}
\functionlistentry{\hyperlink{Moments}{Moments}}{Moments::NormalizeSign}{}{824}{moments}{}
\functionlistentry{\hyperlink{Moments}{Moments}}{Moments::NormalizeTranslation}{}{825}{moments}{}
\functionlistentry{\hyperlink{Moments}{Moments}}{Moments::NormalizeTranslation}{double \&x,double \&y}{826}{moments}{}
\functionlistentry{\hyperlink{Moments}{Moments}}{Moments::NormalizeXShearing}{}{827}{moments}{}
\functionlistentry{\hyperlink{Moments}{Moments}}{Moments::NormalizeXShearing}{double \&beta}{828}{moments}{}
\functionlistentry{\hyperlink{Moments}{Moments}}{Moments::NormalizeYShearing}{}{829}{moments}{}
\functionlistentry{\hyperlink{Moments}{Moments}}{Moments::NormalizeYShearing}{double \&beta}{830}{moments}{}
\functionlistentry{\hyperlink{Moments}{Moments}}{Moments::Rotate}{double phi}{815}{moments}{}
\functionlistentry{\hyperlink{Moments}{Moments}}{Moments::Scale}{double a}{818}{moments}{}
\functionlistentry{\hyperlink{Moments}{Moments}}{Moments::Scale}{double a,double b}{819}{moments}{}
\functionlistentry{\hyperlink{Moments}{Moments}}{Moments::Translate}{double dx,double dy}{814}{moments}{}
\functionlistentry{\hyperlink{Moments}{Moments}}{Moments::XShear}{double s}{816}{moments}{}
\functionlistentry{\hyperlink{Moments}{Moments}}{Moments::YShear}{double s}{817}{moments}{}
\functionlistentry{int}{Mouse}{\hyperlink{Image}{Image} img,int *x,int *y}{100}{Visualisierung}{}
\functionlistentry{int}{Mouse}{\hyperlink{Image}{Image} img,int \&x,int \&y}{101}{Visualisierung}{}
\functionlistentry{int}{MoveImgD}{ImageD src,ImageD dest}{1097}{processing}{}
\functionlistentry{MatrixStruct}{MoveMat}{MatrixStruct m1,MatrixStruct m2}{1578}{obsolet}{}
\functionlistentry{double*}{MoveVec}{double v1[3],double v2[3]}{1556}{obsolet}{}
\functionlistentry{double*}{MoveVecRn}{double *v1,int dim,double *v2}{1566}{obsolet}{}

\letterlabel{Mp}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ma}
\letterref{Me}
\letterref{Mi}
\letterref{Mk}
\letterref{Mo}
\letterref{Mp}
\letterref{Mu}
\letterlabelend{Mp}
\functionlistentry{int}{MPSpectrumFImgD}{ImageD re,ImageD im,ImageD mag,ImageD phase}{1205}{signalTrafo}{}
\functionlistentry{int}{MPSpectrumHImgD}{ImageD sp,ImageD mag,ImageD phase}{1206}{signalTrafo}{}
\functionlistentry{int}{MPSpectrumImgD}{ImageD im,ImageD mag,ImageD phase}{1207}{signalTrafo}{}

\letterlabel{Mu}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ma}
\letterref{Me}
\letterref{Mi}
\letterref{Mk}
\letterref{Mo}
\letterref{Mp}
\letterref{Mu}
\letterlabelend{Mu}
\functionlistentry{int}{MulDiv}{int val1,int val2,int val3}{1356}{numeric}{}
\functionlistentry{int}{MulImgD}{ImageD img1,ImageD img2,ImageD dest}{1099}{processing}{}
\functionlistentry{MatrixStruct}{MulMat}{MatrixStruct m1,MatrixStruct m2,MatrixStruct m3}{1580}{obsolet}{}
\functionlistentry{int}{MulMatVec}{MatrixStruct A,double *b,double *x}{1581}{obsolet}{}

\letterlabel{Ne}
\letterlabel{N}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ne}
\letterref{No}
\letterref{Nu}
\letterlabelend{Ne}
\functionlistentry{}{Neighbor4Walker::Neighbor4Walker}{IPoint p}{191}{datastructures}{}
\functionlistentry{}{Neighbor8Walker::Neighbor8Walker}{IPoint p}{192}{datastructures}{}
\functionlistentry{\hyperlink{Image}{Image}}{NewImg}{int xsize,int ysize,int maxval,const string \&title=''''}{10}{Images}{}
\functionlistentry{\hyperlink{Image}{Image}}{NewImg}{const \hyperlink{Image}{Image} \&img,int copy=false,const string \&title=''''}{11}{Images}{}
\functionlistentry{\hyperlink{ColorImage}{ColorImage}}{NewImg}{int xsize,int ysize,int maxval,const string \&title=''''}{22}{Images}{}
\functionlistentry{\hyperlink{ColorImage}{ColorImage}}{NewImg}{const \hyperlink{ColorImage}{ColorImage} \&img,int copy=false,const string \&title=''''}{23}{Images}{}
\functionlistentry{ImageD}{NewImgD}{int xsize,int ysize,double minval=0.0,double maxval=0.0}{77}{Images}{}
\functionlistentry{ImageD}{NewImgD}{ImageD img,bool copy=false}{78}{Images}{}
\functionlistentry{ImageD}{NewImgD}{const \hyperlink{Image}{Image} \&img,bool copy=false}{79}{Images}{}
\functionlistentry{MatrixStruct}{NewMatrix}{int typ,int rows,int columns}{1575}{obsolet}{}
\functionlistentry{PeakList}{NewPeakList}{}{1259}{registration}{}

\letterlabel{No}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ne}
\letterref{No}
\letterref{Nu}
\letterlabelend{No}
\functionlistentry{int}{NonLinEquSys}{FuncD *func,int dim,int *step,double *mse,double *x}{1127}{matrixAlgebra}{}
\functionlistentry{int}{NormalEquationSys}{MatrixStruct A,double *b,double *x}{1126}{matrixAlgebra}{}
\functionlistentry{\hyperlink{Vector}{Vector}}{Normalize}{const \hyperlink{Vector}{Vector} \&v}{253}{datastructures}{}
\functionlistentry{int}{NormalizeMoments}{const double m1[15],double m2[15]}{1614}{obsolet}{}
\functionlistentry{double*}{NormVec}{double v1[3],double v2[3]}{1560}{obsolet}{}
\functionlistentry{double*}{NormVecRn}{double *v1,int dim,double *v2}{1570}{obsolet}{}

\letterlabel{Nu}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ne}
\letterref{No}
\letterref{Nu}
\letterlabelend{Nu}
\functionlistentry{string}{NumberString}{int i,unsigned int width=0}{1404}{genericTools}{}
\functionlistentry{string}{NumberString}{unsigned int i,unsigned int width=0}{1405}{genericTools}{}
\functionlistentry{string}{NumberString}{long int i,unsigned int width=0}{1406}{genericTools}{}
\functionlistentry{string}{NumberString}{long long int i,unsigned int width=0}{1407}{genericTools}{}
\functionlistentry{string}{NumberString}{double f,unsigned int width=0,unsigned int prec=0}{1408}{genericTools}{}

\letterlabel{Of}
\letterlabel{O}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Of}
\letterref{On}
\letterref{Op}
\letterref{Or}
\letterlabelend{Of}
\functionlistentry{void}{OffMessage}{void}{1547}{errorHandling}{}

\letterlabel{On}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Of}
\letterref{On}
\letterref{Op}
\letterref{Or}
\letterlabelend{On}
\functionlistentry{void}{OnMessage}{void}{1548}{errorHandling}{}

\letterlabel{Op}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Of}
\letterref{On}
\letterref{Op}
\letterref{Or}
\letterlabelend{Op}
\functionlistentry{void}{OpenAlpha}{unsigned char *windowname}{1416}{genericTools}{}
\functionlistentry{int}{OpeningImg}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&dest,int nx=3, int ny=-1}{379}{filter}{}
\functionlistentry{int}{OpeningImg}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&dest,const IMatrix \&mask}{380}{filter}{}
\functionlistentry{double \&}{operator ()}{int xi,int yi}{811}{moments}{}
\functionlistentry{\hyperlink{Trafo}{Trafo}}{operator *}{const \hyperlink{Trafo}{Trafo} \&,const \hyperlink{Trafo}{Trafo} \&}{687}{geoTrafo}{}
\functionlistentry{\hyperlink{Vector}{Vector}}{operator *}{const \hyperlink{Trafo}{Trafo} \&,const \hyperlink{Vector}{Vector} \&}{688}{geoTrafo}{}
\functionlistentry{ostream \&}{operator <<}{ostream \&s,const \hyperlink{Statistics}{Statistics} \&t}{874}{statistics}{}
\functionlistentry{istream \&}{operator >>}{istream \&s,\hyperlink{Statistics}{Statistics} \&st}{875}{statistics}{}
\functionlistentry{\hyperlink{Contur}{Contur}}{operator+}{const \hyperlink{Contur}{Contur} \&c1,const \hyperlink{Contur}{Contur} \&c2}{404}{conturs}{}
\functionlistentry{\hyperlink{Camera}{Camera} \&}{operator=}{const \hyperlink{Camera}{Camera} \&c}{773}{cameraModel}{}

\letterlabel{Or}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Of}
\letterref{On}
\letterref{Op}
\letterref{Or}
\letterlabelend{Or}
\functionlistentry{double}{Orientation}{const \hyperlink{Moments}{Moments} \&m}{857}{moments}{}
\functionlistentry{int}{OrientationMoments}{double moment[15],double \&angle}{1274}{registration}{}
\functionlistentry{int}{OrientedDoBImg}{const \hyperlink{Image}{Image} \&src,const \hyperlink{Image}{Image} \&dir, \hyperlink{Image}{Image} \&dest,int fsize=11,int flength=10,int fwidth=1}{365}{filter}{}
\functionlistentry{int}{OrientedEdgeImg}{const \hyperlink{Image}{Image} \&src,const \hyperlink{Image}{Image} \&dir, \hyperlink{Image}{Image} \&dest,int fsize=11,int rad=10}{366}{filter}{}
\functionlistentry{int}{OrientedSmearImg}{const \hyperlink{Image}{Image} \&src,const \hyperlink{Image}{Image} \&dir, \hyperlink{Image}{Image} \&dest,int fsize=11,int flength=10,int fwidth=1}{364}{filter}{}

\letterlabel{Pa}
\letterlabel{P}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Pa}
\letterref{Pe}
\letterref{Ph}
\letterref{Po}
\letterref{Pr}
\letterref{Pu}
\letterlabelend{Pa}
\functionlistentry{int}{ParamQuadrFunc}{double par[5],int type,double koeff[6]}{1382}{numeric}{}

\letterlabel{Pe}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Pa}
\letterref{Pe}
\letterref{Ph}
\letterref{Po}
\letterref{Pr}
\letterref{Pu}
\letterlabelend{Pe}
\functionlistentry{int*}{Peak1D}{double* values,int anz,int\& panz,int zykl,int noise}{1256}{registration}{}
\functionlistentry{IVector}{Peak1D}{const \hyperlink{Vector}{Vector}\& vec,int panz,int zykl,int noise}{1257}{registration}{}
\functionlistentry{double}{PeakValuation}{\hyperlink{Image}{Image} img,\hyperlink{Image}{Image} mark,double\& x0,double\& y0, int mode=PN\_CONVOLUTION,int gnull=0,int zykl=TRUE}{1255}{registration}{}

\letterlabel{Ph}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Pa}
\letterref{Pe}
\letterref{Ph}
\letterref{Po}
\letterref{Pr}
\letterref{Pu}
\letterlabelend{Ph}
\functionlistentry{int}{PhasenSpektrumQFT}{\hyperlink{QuatMatrix}{QuatMatrix}\& input, \hyperlink{Image}{Image}\& alpha, \hyperlink{Image}{Image}\& beta, \hyperlink{Image}{Image}\& delta, int mode=CENTER}{1544}{quaternions}{}

\letterlabel{Po}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Pa}
\letterref{Pe}
\letterref{Ph}
\letterref{Po}
\letterref{Pr}
\letterref{Pu}
\letterlabelend{Po}
\functionlistentry{\hyperlink{Point}{Point}}{Point::normalized}{}{173}{datastructures}{}
\functionlistentry{bool}{Point::operator !=}{const \hyperlink{Point}{Point} \&p}{160}{datastructures}{}
\functionlistentry{\hyperlink{Point}{Point}}{Point::operator *}{double f}{165}{datastructures}{}
\functionlistentry{double}{Point::operator *}{\hyperlink{Point}{Point} second}{167}{datastructures}{}
\functionlistentry{\hyperlink{Point}{Point}}{Point::operator *=}{double f}{166}{datastructures}{}
\functionlistentry{\hyperlink{Point}{Point}}{Point::operator +}{const \hyperlink{Point}{Point} \&p}{161}{datastructures}{}
\functionlistentry{\hyperlink{Point}{Point}}{Point::operator +=}{const \hyperlink{Point}{Point} \&p}{162}{datastructures}{}
\functionlistentry{\hyperlink{Point}{Point}}{Point::operator -}{const \hyperlink{Point}{Point} \&p}{163}{datastructures}{}
\functionlistentry{\hyperlink{Point}{Point}}{Point::operator -=}{const \hyperlink{Point}{Point} \&p}{164}{datastructures}{}
\functionlistentry{\hyperlink{Point}{Point}}{Point::operator /}{double d}{168}{datastructures}{}
\functionlistentry{\hyperlink{Point}{Point}}{Point::operator /=}{double d}{169}{datastructures}{}
\functionlistentry{bool}{Point::operator ==}{const \hyperlink{Point}{Point} \&p}{159}{datastructures}{}
\functionlistentry{double}{Point::phi}{}{172}{datastructures}{}
\functionlistentry{}{Point::Point}{}{152}{datastructures}{}
\functionlistentry{}{Point::Point}{double x, double y}{153}{datastructures}{}
\functionlistentry{explicit}{Point::Point}{const \hyperlink{Vector}{Vector} \&v}{154}{datastructures}{}
\functionlistentry{explicit}{Point::Point}{const IVector \&v}{155}{datastructures}{}
\functionlistentry{explicit}{Point::Point}{double d[]}{156}{datastructures}{}
\functionlistentry{double}{Point::r}{}{171}{datastructures}{}
\functionlistentry{int}{Point::Shift}{double dx,double dy}{170}{datastructures}{}
\functionlistentry{double}{Point::X}{}{157}{datastructures}{}
\functionlistentry{double}{Point::Y}{}{158}{datastructures}{}
\functionlistentry{bool}{pointInside}{double x,double y,const \hyperlink{Contur}{Contur} \&c}{459}{conturs}{}
\functionlistentry{bool}{pointInside}{const \hyperlink{Point}{Point} \&p,const \hyperlink{Contur}{Contur} \&c}{460}{conturs}{}
\functionlistentry{bool}{pointInside}{double x,double y,const \hyperlink{Matrix}{Matrix} \&pl}{461}{conturs}{}
\functionlistentry{bool}{pointInside}{const \hyperlink{Point}{Point} \&p,const \hyperlink{Matrix}{Matrix} \&pl}{462}{conturs}{}
\functionlistentry{int}{PointListMoment}{PointList pl,int a1,int a2,double m[15],double s[2]}{1605}{obsolet}{}
\functionlistentry{}{PointListWalker::PointListWalker}{}{185}{datastructures}{}
\functionlistentry{}{PointListWalker::PointListWalker}{IPoint p}{186}{datastructures}{}
\functionlistentry{}{PointListWalker::PointListWalker}{const vector\textless {}IPoint\textgreater  \&pl,int idx = 0}{187}{datastructures}{}
\functionlistentry{}{PointListWalker::PointListWalker}{const \hyperlink{Contur}{Contur} \&c}{188}{datastructures}{}
\functionlistentry{void}{PointListWalker::setPointList}{const vector\textless {}IPoint\textgreater  \&v,int idx = 0}{189}{datastructures}{}
\functionlistentry{void}{PointListWalker::setStartIndex}{int idx = 0}{190}{datastructures}{}
\functionlistentry{int}{PolarC}{ImageD src,ImageD dest,double x,double y,double \&r,double \&phi,double r1=1,double r2=0,int sm=2}{1103}{processing}{}
\functionlistentry{int}{PolarImg}{const \hyperlink{Image}{Image} \&src,const \hyperlink{Image}{Image} \&dest,double r1=1,double r2=0,int sym=2}{1102}{processing}{}
\functionlistentry{int}{PolarImgD}{ImageD src,ImageD dest,double r1=1,double r2=0,int sym=2}{1101}{processing}{}
\functionlistentry{\hyperlink{LineSeg}{LineSeg}}{Polygon::edge}{int i}{619}{geoObject}{}
\functionlistentry{const \hyperlink{Point}{Point} \&}{Polygon::operator[]}{int i}{618}{geoObject}{}
\functionlistentry{}{Polygon::Polygon}{}{611}{geoObject}{}
\functionlistentry{}{Polygon::Polygon}{const \hyperlink{Polygon}{Polygon} \&p}{612}{geoObject}{}
\functionlistentry{}{Polygon::Polygon}{\hyperlink{Point}{Point} p}{613}{geoObject}{}
\functionlistentry{explicit}{Polygon::Polygon}{const \hyperlink{Matrix}{Matrix} \&m}{614}{geoObject}{}
\functionlistentry{}{Polygon::Polygon}{const vector<\hyperlink{Point}{Point}> \&pl}{615}{geoObject}{}
\functionlistentry{explicit}{Polygon::Polygon}{const \hyperlink{Contur}{Contur} \&c}{616}{geoObject}{}
\functionlistentry{void}{Polygon::Reset}{}{621}{geoObject}{}
\functionlistentry{void}{Polygon::Reset}{\hyperlink{Point}{Point} p}{622}{geoObject}{}
\functionlistentry{int}{Polygon::size}{}{617}{geoObject}{}
\functionlistentry{\hyperlink{LineSeg}{LineSeg}}{PolygonalCurve::edge}{int i}{600}{geoObject}{}
\functionlistentry{bool}{PolygonalCurve::isClosed()}{}{598}{geoObject}{}
\functionlistentry{const \hyperlink{Point}{Point} \&}{PolygonalCurve::operator[]}{int i}{599}{geoObject}{}
\functionlistentry{}{PolygonalCurve::PolygonalCurve}{bool closed=false}{591}{geoObject}{}
\functionlistentry{}{PolygonalCurve::PolygonalCurve}{const \hyperlink{PolygonalCurve}{PolygonalCurve} \&p}{592}{geoObject}{}
\functionlistentry{}{PolygonalCurve::PolygonalCurve}{\hyperlink{Point}{Point} p,bool closed=false}{593}{geoObject}{}
\functionlistentry{explicit}{PolygonalCurve::PolygonalCurve}{const \hyperlink{Matrix}{Matrix} \&m, bool closed=false}{594}{geoObject}{}
\functionlistentry{}{PolygonalCurve::PolygonalCurve}{const vector<\hyperlink{Point}{Point}> \&pl,bool closed=false}{595}{geoObject}{}
\functionlistentry{explicit}{PolygonalCurve::PolygonalCurve}{const \hyperlink{Contur}{Contur} \&c, bool closed=false}{596}{geoObject}{}
\functionlistentry{\hyperlink{PolygonalCurve}{PolygonalCurve}}{PolygonalCurve::ReducedToPrecision}{double prec,int mode=1}{609}{geoObject}{}
\functionlistentry{void}{PolygonalCurve::ReducedToPrecision}{double prec,\hyperlink{PolygonalCurve}{PolygonalCurve} \&res,int mode=1}{610}{geoObject}{}
\functionlistentry{void}{PolygonalCurve::Reset}{}{602}{geoObject}{}
\functionlistentry{void}{PolygonalCurve::Reset}{\hyperlink{Point}{Point} p}{603}{geoObject}{}
\functionlistentry{int}{PolygonalCurve::size}{}{597}{geoObject}{}
\functionlistentry{int}{Polynom1o::getCoefficient}{double \&a0, double \&a1}{1008}{functions}{}
\functionlistentry{}{Polynom1o::Polynom1o}{void}{1003}{functions}{}
\functionlistentry{}{Polynom1o::Polynom1o}{double a0, double a1}{1004}{functions}{}
\functionlistentry{}{Polynom1o::Polynom1o}{const vector\textless {}double\textgreater  \&v}{1005}{functions}{}
\functionlistentry{}{Polynom1o::Polynom1o}{const \hyperlink{Polynom1o}{Polynom1o} \&f}{1006}{functions}{}
\functionlistentry{int}{Polynom1o::setCoefficient}{double a0, double a1}{1007}{functions}{}
\functionlistentry{void}{Polynom2d1o::getCoefficient}{double \&a00, double \&a10, double \&a01}{1043}{functions}{}
\functionlistentry{}{Polynom2d1o::Polynom2d1o}{void}{1038}{functions}{}
\functionlistentry{}{Polynom2d1o::Polynom2d1o}{double a00, double a10, double a01}{1039}{functions}{}
\functionlistentry{}{Polynom2d1o::Polynom2d1o}{const vector\textless {}double\textgreater  \&v}{1040}{functions}{}
\functionlistentry{}{Polynom2d1o::Polynom2d1o}{const \hyperlink{Polynom2d1o}{Polynom2d1o} \&f}{1041}{functions}{}
\functionlistentry{void}{Polynom2d1o::setCoefficient}{double a00, double a10, double a01}{1042}{functions}{}
\functionlistentry{void}{Polynom2d2o::getCoefficient}{double \&a00, double \&a10, double \&a01, double \&a20, double \&a11, double \&a02}{1049}{functions}{}
\functionlistentry{}{Polynom2d2o::Polynom2d2o}{void}{1044}{functions}{}
\functionlistentry{}{Polynom2d2o::Polynom2d2o}{double a00, double a10, double a01, double a20, double a11, double a02}{1045}{functions}{}
\functionlistentry{}{Polynom2d2o::Polynom2d2o}{const vector\textless {}double\textgreater  \&v}{1046}{functions}{}
\functionlistentry{}{Polynom2d2o::Polynom2d2o}{const \hyperlink{Polynom2d2o}{Polynom2d2o} \&f}{1047}{functions}{}
\functionlistentry{void}{Polynom2d2o::setCoefficient}{double a00, double a10, double a01, double a20, double a11, double a02}{1048}{functions}{}
\functionlistentry{}{Polynom2d::Polynom2d}{void}{1050}{functions}{}
\functionlistentry{}{Polynom2d::Polynom2d}{int ord}{1051}{functions}{}
\functionlistentry{}{Polynom2d::Polynom2d}{const vector\textless {}double\textgreater  \&v}{1052}{functions}{}
\functionlistentry{}{Polynom2d::Polynom2d}{const \hyperlink{Polynom2d}{Polynom2d} \&f}{1053}{functions}{}
\functionlistentry{int}{Polynom2o::getCoefficient}{double \&a0, double \&a1, double \&a2}{1014}{functions}{}
\functionlistentry{}{Polynom2o::Polynom2o}{void}{1009}{functions}{}
\functionlistentry{}{Polynom2o::Polynom2o}{double a0, double a1, double a2}{1010}{functions}{}
\functionlistentry{}{Polynom2o::Polynom2o}{const \hyperlink{Vector}{Vector} \&v}{1011}{functions}{}
\functionlistentry{}{Polynom2o::Polynom2o}{const \hyperlink{Polynom2o}{Polynom2o} \&f}{1012}{functions}{}
\functionlistentry{int}{Polynom2o::setCoefficient}{double a0, double a1, double a2}{1013}{functions}{}
\functionlistentry{}{Polynom::Polynom}{void}{1015}{functions}{}
\functionlistentry{}{Polynom::Polynom}{int ord}{1016}{functions}{}
\functionlistentry{}{Polynom::Polynom}{const vector\textless {}double\textgreater  \&v}{1017}{functions}{}
\functionlistentry{}{Polynom::Polynom}{const \hyperlink{Polynom}{Polynom} \&f}{1018}{functions}{}
\functionlistentry{int}{PolyNormMoments}{double m[21],double maf[21],double atr[3][3]}{1618}{obsolet}{}
\functionlistentry{void}{PopAlpha}{void}{1420}{genericTools}{}
\functionlistentry{int}{PowerSpectrumFImgD}{ImageD re,ImageD im,ImageD imgd,int mode=MD\_POWER}{1202}{signalTrafo}{}
\functionlistentry{int}{PowerSpectrumHImgD}{ImageD src,ImageD imgd,int mode=MD\_POWER}{1203}{signalTrafo}{}
\functionlistentry{int}{PowerSpectrumImgD}{ImageD imgs,ImageD imgd,int mode=MD\_POWER}{1204}{signalTrafo}{}
\functionlistentry{int}{PowerSpektrumQFT}{\hyperlink{QuatMatrix}{QuatMatrix}\& input, \hyperlink{Image}{Image}\& output,int type=POWER, int mode=CENTER}{1541}{quaternions}{}

\letterlabel{Pr}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Pa}
\letterref{Pe}
\letterref{Ph}
\letterref{Po}
\letterref{Pr}
\letterref{Pu}
\letterlabelend{Pr}
\functionlistentry{int}{PreprocessImg}{(\hyperlink{Image}{Image} imgs,\hyperlink{Image}{Image} imgd)}{1254}{registration}{}
\functionlistentry{int}{Print}{const string \&s}{1432}{genericTools}{}
\functionlistentry{int}{Printf}{const char *format,...}{1431}{genericTools}{}
\functionlistentry{int}{PrintHist}{const \hyperlink{Hist}{Hist} \& h}{915}{statistics}{}
\functionlistentry{int}{PrintHistogram}{const \hyperlink{Histogram}{Histogram} \& h}{902}{statistics}{}
\functionlistentry{void}{PrintVecRn}{char *str,double *v,int dim}{1574}{obsolet}{}

\letterlabel{Pu}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Pa}
\letterref{Pe}
\letterref{Ph}
\letterref{Po}
\letterref{Pr}
\letterref{Pu}
\letterlabelend{Pu}
\functionlistentry{void}{PushAlpha}{void}{1419}{genericTools}{}
\functionlistentry{int}{Put}{\hyperlink{Statistics}{Statistics} \&st,const \hyperlink{Vector}{Vector} \&val,double weight=1.0}{867}{statistics}{}
\functionlistentry{int}{PutChar}{int c}{1428}{genericTools}{}
\functionlistentry{int}{PutStatistic}{Statistic st,double v[dim],double weight}{1595}{obsolet}{}
\functionlistentry{void}{PutVal}{\hyperlink{Image}{Image} \&img,int x,int y,int val}{64}{Images}{}
\functionlistentry{void}{PutVal}{\hyperlink{Image}{Image} \& img,const IPoint \&p,int val}{67}{Images}{}
\functionlistentry{void}{PutValD}{ImageD img,int x,int y,double val}{80}{Images}{}
\functionlistentry{void}{PutValue}{ImageD img,IPoint p,double val}{82}{Images}{}

\letterlabel{Qe}
\letterlabel{Q}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Qe}
\letterref{Qf}
\letterref{Qr}
\letterref{Qu}
\letterlabelend{Qe}
\functionlistentry{\hyperlink{Quaternion}{Quaternion}}{qexp}{\hyperlink{Quaternion}{Quaternion}\& x}{1477}{quaternions}{}
\functionlistentry{\hyperlink{Quaternion}{Quaternion}}{qexp}{\hyperlink{RotQuaternion}{RotQuaternion}\& x}{1501}{quaternions}{}

\letterlabel{Qf}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Qe}
\letterref{Qf}
\letterref{Qr}
\letterref{Qu}
\letterlabelend{Qf}
\functionlistentry{int}{QFourier}{\hyperlink{QuatMatrix}{QuatMatrix}\& input, \hyperlink{QuatMatrix}{QuatMatrix}\& output,int option=NORMAL}{1540}{quaternions}{}

\letterlabel{Qr}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Qe}
\letterref{Qf}
\letterref{Qr}
\letterref{Qu}
\letterlabelend{Qr}
\functionlistentry{int}{QRDecomposition}{const \hyperlink{Matrix}{Matrix} \&A,\hyperlink{Matrix}{Matrix} \&Q,\hyperlink{Matrix}{Matrix} \&R}{1133}{matrixAlgebra}{}

\letterlabel{Qu}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Qe}
\letterref{Qf}
\letterref{Qr}
\letterref{Qu}
\letterlabelend{Qu}
\functionlistentry{}{QuadraticFormVectorDistance::QuadraticFormVectorDistance}{const \hyperlink{Matrix}{Matrix} \&a}{1238}{features}{}
\functionlistentry{\hyperlink{Quaternion}{Quaternion}}{Quaternion::getConjugate}{}{1467}{quaternions}{}
\functionlistentry{\hyperlink{Quaternion}{Quaternion}}{Quaternion::getEigenachse}{}{1474}{quaternions}{}
\functionlistentry{double}{Quaternion::getEigenwinkel}{}{1473}{quaternions}{}
\functionlistentry{double}{Quaternion::getI}{}{1457}{quaternions}{}
\functionlistentry{vector3d}{Quaternion::getImaginary}{}{1460}{quaternions}{}
\functionlistentry{\hyperlink{Quaternion}{Quaternion}}{Quaternion::getInverse}{}{1468}{quaternions}{}
\functionlistentry{double}{Quaternion::getJ}{}{1458}{quaternions}{}
\functionlistentry{double}{Quaternion::getK}{}{1459}{quaternions}{}
\functionlistentry{\hyperlink{Quaternion}{Quaternion}}{Quaternion::getNegate}{}{1466}{quaternions}{}
\functionlistentry{double}{Quaternion::getNorm}{}{1471}{quaternions}{}
\functionlistentry{\hyperlink{Quaternion}{Quaternion}}{Quaternion::getNormalize}{}{1469}{quaternions}{}
\functionlistentry{vector3d}{Quaternion::getPhases}{}{1475}{quaternions}{}
\functionlistentry{double}{Quaternion::getReal}{}{1456}{quaternions}{}
\functionlistentry{\hyperlink{Quaternion}{Quaternion}}{Quaternion::getSquare}{}{1470}{quaternions}{}
\functionlistentry{double}{Quaternion::getSquareNorm}{}{1472}{quaternions}{}
\functionlistentry{bool}{Quaternion::isUnitQuaternion}{}{1476}{quaternions}{}
\functionlistentry{}{Quaternion::Quaternion}{}{1452}{quaternions}{}
\functionlistentry{}{Quaternion::Quaternion}{double real, double i, double j, double k}{1453}{quaternions}{}
\functionlistentry{}{Quaternion::Quaternion}{double real, \hyperlink{Vector3d}{Vector3d}\& imaginary}{1454}{quaternions}{}
\functionlistentry{}{Quaternion::Quaternion}{const \hyperlink{Quaternion}{Quaternion}\& b}{1455}{quaternions}{}
\functionlistentry{void}{Quaternion::setI}{double i}{1462}{quaternions}{}
\functionlistentry{void}{Quaternion::setImaginary}{vector3d\& imaginary}{1465}{quaternions}{}
\functionlistentry{void}{Quaternion::setJ}{double j}{1463}{quaternions}{}
\functionlistentry{void}{Quaternion::setK}{double k}{1464}{quaternions}{}
\functionlistentry{void}{Quaternion::setReal}{double real}{1461}{quaternions}{}
\functionlistentry{unsigned int}{QuatMatrix::getColumns}{}{1508}{quaternions}{}
\functionlistentry{unsigned int}{QuatMatrix::getRows}{}{1507}{quaternions}{}
\functionlistentry{}{QuatMatrix::QuatMatrix}{}{1504}{quaternions}{}
\functionlistentry{}{QuatMatrix::QuatMatrix}{unsigned int rows, unsigned int columns}{1505}{quaternions}{}
\functionlistentry{}{QuatMatrix::QuatMatrix}{const \hyperlink{QuatMatrix}{QuatMatrix}\& qm}{1506}{quaternions}{}
\functionlistentry{unsigned int}{QuatVector::getDimension}{}{1512}{quaternions}{}
\functionlistentry{}{QuatVector::QuatVector}{}{1509}{quaternions}{}
\functionlistentry{}{QuatVector::QuatVector}{unsigned int dimension}{1510}{quaternions}{}
\functionlistentry{}{QuatVector::QuatVector}{const \hyperlink{QuatVector}{QuatVector}\& qv}{1511}{quaternions}{}

\letterlabel{Ra}
\letterlabel{R}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ra}
\letterref{Re}
\letterref{Rg}
\letterref{Ri}
\letterref{Ro}
\letterlabelend{Ra}
\functionlistentry{int}{RadonImg}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&radon}{1231}{signalTrafo}{}
\functionlistentry{int}{Random}{int val}{860}{statistics}{}
\functionlistentry{double}{RandomD}{}{861}{statistics}{}
\functionlistentry{void}{Randomize}{}{859}{statistics}{}
\functionlistentry{int}{RankImg}{const \hyperlink{Image}{Image} \&src,int neighb,int rank,\hyperlink{Image}{Image} \&dest}{384}{filter}{}
\functionlistentry{int}{RankImg}{const \hyperlink{Image}{Image} \&src,int nx,int ny,int rank,\hyperlink{Image}{Image} \&dest}{385}{filter}{}
\functionlistentry{\hyperlink{Line3d}{Line3d}}{Ray}{const \hyperlink{Point}{Point} \&bp}{788}{cameraModel}{}
\functionlistentry{\hyperlink{Line3d}{Line3d}}{Ray}{double u,double v}{789}{cameraModel}{}
\functionlistentry{\hyperlink{Line3d}{Line3d}}{Ray}{const \hyperlink{Vector}{Vector} \&bp}{790}{cameraModel}{}

\letterlabel{Re}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ra}
\letterref{Re}
\letterref{Rg}
\letterref{Ri}
\letterref{Ro}
\letterlabelend{Re}
\functionlistentry{int}{Read}{\hyperlink{Statistics}{Statistics} \&st,const string \&fn}{873}{statistics}{}
\functionlistentry{int}{ReadColorImageCache$<$T$>$::FrameNumber}{}{137}{imageio}{}
\functionlistentry{int}{ReadColorImageCache$<$T$>$::getError}{}{139}{imageio}{}
\functionlistentry{bool}{ReadColorImageCache$<$T$>$::Read}{const \hyperlink{ColorImage}{ColorImage} \&img,int frame}{134}{imageio}{}
\functionlistentry{bool}{ReadColorImageCache$<$T$>$::Read}{const \hyperlink{Image}{Image} \&imgr,const \hyperlink{Image}{Image} \&imgg,const \hyperlink{Image}{Image} \&imgb,int frame}{135}{imageio}{}
\functionlistentry{}{ReadColorImageCache$<$T$>$::ReadColorImageCache}{T \&tr,int xsize,int ysize,int maxval,int csize}{132}{imageio}{}
\functionlistentry{int}{ReadImageCache$<$T$>$::FrameNumber}{}{136}{imageio}{}
\functionlistentry{int}{ReadImageCache$<$T$>$::getError}{}{138}{imageio}{}
\functionlistentry{bool}{ReadImageCache$<$T$>$::Read}{const \hyperlink{Image}{Image} \&img,int frame=ReadImagCache$<$T$>$::next}{133}{imageio}{}
\functionlistentry{}{ReadImageCache$<$T$>$::ReadImageCache}{T \&tr,int xsize,int ysize,int maxval,int csize}{131}{imageio}{}
\functionlistentry{\hyperlink{Image}{Image}}{ReadImg}{const string \&filename,\hyperlink{Image}{Image} \&img,int flag=IB\_SCALE}{113}{imageio}{}
\functionlistentry{int}{ReadImg}{const string \&file,\hyperlink{Image}{Image} \&imgr,\hyperlink{Image}{Image} \&imgg,\hyperlink{Image}{Image} \&imgb, int flag=IB\_SCALE}{115}{imageio}{}
\functionlistentry{Statistic}{ReadStatistic}{char *file}{1602}{obsolet}{}
\functionlistentry{\hyperlink{PolygonalCurve}{PolygonalCurve}}{Reduced}{int nr, int mode=1}{607}{geoObject}{}
\functionlistentry{void}{Reduced}{int nr, \hyperlink{PolygonalCurve}{PolygonalCurve} \&p, int mode=1}{608}{geoObject}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{ReducePolygon}{const \hyperlink{Matrix}{Matrix} \&pl,int n}{281}{datastructures}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{ReducePolygon}{const \hyperlink{Contur}{Contur} \&c,int n}{282}{datastructures}{}
\functionlistentry{double}{ReferenceCosts}{const \hyperlink{Matrix}{Matrix} \&costs,const IMatrix \&pairs}{1262}{registration}{}
\functionlistentry{void}{Region::add}{int x,int y}{477}{conturs}{}
\functionlistentry{void}{Region::add}{const IPoint \&p}{478}{conturs}{}
\functionlistentry{void}{Region::add}{const \hyperlink{Point}{Point} \&p}{479}{conturs}{}
\functionlistentry{void}{Region::add}{int x1,int y1,int x2,int y2}{480}{conturs}{}
\functionlistentry{void}{Region::add}{const \hyperlink{Window}{Window} \&w}{481}{conturs}{}
\functionlistentry{void}{Region::add}{const \hyperlink{Region}{Region} \&r}{482}{conturs}{}
\functionlistentry{int}{Region::CalcMoments}{\hyperlink{Moments}{Moments} \&m}{494}{conturs}{}
\functionlistentry{void}{Region::del}{int x,int y}{485}{conturs}{}
\functionlistentry{void}{Region::del}{const \hyperlink{Point}{Point} \&p}{486}{conturs}{}
\functionlistentry{void}{Region::del}{const IPoint \&p}{487}{conturs}{}
\functionlistentry{void}{Region::del}{int x1,int y1,int x2,int y2}{488}{conturs}{}
\functionlistentry{void}{Region::del}{const \hyperlink{Region}{Region} \&r}{489}{conturs}{}
\functionlistentry{int}{Region::getArea}{}{493}{conturs}{}
\functionlistentry{void}{Region::getPoints}{vector\textless {}IPoint\textgreater  \&points}{495}{conturs}{}
\functionlistentry{bool}{Region::inside}{int x,int y}{491}{conturs}{}
\functionlistentry{bool}{Region::isEmpty}{void}{492}{conturs}{}
\functionlistentry{\hyperlink{Region}{Region}}{Region::operator +}{const \hyperlink{Region}{Region} \&r1,const \hyperlink{Region}{Region} \&r2}{484}{conturs}{}
\functionlistentry{const \hyperlink{Region}{Region} \&}{Region::operator +=}{const \hyperlink{Region}{Region} \&r2}{483}{conturs}{}
\functionlistentry{\hyperlink{Region}{Region}}{Region::operator -}{const \hyperlink{Region}{Region} \&r1,const \hyperlink{Region}{Region} \&r2}{490}{conturs}{}
\functionlistentry{}{Region::Region}{}{474}{conturs}{}
\functionlistentry{}{Region::Region}{const \hyperlink{Region}{Region} \&r}{475}{conturs}{}
\functionlistentry{}{Region::Region}{const \hyperlink{Contur}{Contur} \&c}{476}{conturs}{}
\functionlistentry{\hyperlink{Region}{Region}}{RegionGrow}{int x,int y,const \hyperlink{Image}{Image} \&orig,int maxsize=INT\_MAX,int refvalue=-1}{1145}{segmentation}{}
\functionlistentry{int}{RegionGrow}{int x,int y,const \hyperlink{Image}{Image} \&orig,\hyperlink{Image}{Image} \&mark,int val=1,int maxsize=INT\_MAX,int refvalue=-1}{1146}{segmentation}{}
\functionlistentry{\hyperlink{Region}{Region}}{RegionGrowGrw}{int x,int y,const \hyperlink{Image}{Image} \&orig,double stdmax=3.0,int maxSize=INT\_MAX}{1147}{segmentation}{}
\functionlistentry{int}{RegionGrowGrw}{int x,int y,const \hyperlink{Image}{Image} \&orig,\hyperlink{Image}{Image} \&mark,int val=1,double stdmax=3.0,int maxSize=INT\_MAX}{1148}{segmentation}{}
\functionlistentry{}{RegionWalker::RegionWalker}{const \hyperlink{Region}{Region} \&region}{193}{datastructures}{}
\functionlistentry{}{RegionWalker::RegionWalker}{const \hyperlink{Contur}{Contur} \&contur}{194}{datastructures}{}
\functionlistentry{int}{RelaxImg}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&dest,int neighb=3}{388}{filter}{}
\functionlistentry{int}{RenormImg}{const \hyperlink{Image}{Image} \&img,const \hyperlink{Image}{Image} \&dest}{1094}{processing}{}
\functionlistentry{void}{Resize}{int n}{238}{datastructures}{}
\functionlistentry{}{ReturnErrorIfFailed}{function}{1552}{errorHandling}{}
\functionlistentry{}{ReturnNullIfFailed}{function}{1551}{errorHandling}{}

\letterlabel{Rg}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ra}
\letterref{Re}
\letterref{Rg}
\letterref{Ri}
\letterref{Ro}
\letterlabelend{Rg}
\functionlistentry{void}{RgbToHsi}{const \hyperlink{ColorValue}{ColorValue} \&src, int maxval, double \&h, double \&s, double \&i}{295}{datastructures}{}
\functionlistentry{void}{RgbToHsi}{const \hyperlink{ColorValue}{ColorValue} \&src, double \&h, double \&s, double \&i}{296}{datastructures}{}
\functionlistentry{void}{RgbToHsi}{double r, double g, double b, double \&h, double \&s, double \&i}{308}{datastructures}{}
\functionlistentry{void}{RgbToLab}{const \hyperlink{ColorValue}{ColorValue} \&src, int maxval, double \&x, double \&y, double \&z}{301}{datastructures}{}
\functionlistentry{void}{RgbToLab}{const \hyperlink{ColorValue}{ColorValue} \&src, double \&x, double \&y, double \&z}{302}{datastructures}{}
\functionlistentry{void}{RgbToLab}{double r, double g, double b, double \&x, double \&y, double \&z}{315}{datastructures}{}
\functionlistentry{void}{RgbToXyz}{const \hyperlink{ColorValue}{ColorValue} \&src, int maxval, double \&x, double \&y, double \&z}{299}{datastructures}{}
\functionlistentry{void}{RgbToXyz}{const \hyperlink{ColorValue}{ColorValue} \&src, double \&x, double \&y, double \&z}{300}{datastructures}{}
\functionlistentry{void}{RgbToXyz}{double r, double g, double b, double \&x, double \&y, double \&z}{311}{datastructures}{}
\functionlistentry{void}{RgbToYuv}{const \hyperlink{ColorValue}{ColorValue} \&src, int maxval, double \&h, double \&s, double \&i}{297}{datastructures}{}
\functionlistentry{void}{RgbToYuv}{const \hyperlink{ColorValue}{ColorValue} \&src, double \&h, double \&s, double \&i}{298}{datastructures}{}
\functionlistentry{void}{RgbToYuv}{double r, double g, double b, double \&h, double \&s, double \&i}{310}{datastructures}{}

\letterlabel{Ri}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ra}
\letterref{Re}
\letterref{Rg}
\letterref{Ri}
\letterref{Ro}
\letterlabelend{Ri}
\functionlistentry{int}{RidgeThreshold}{\hyperlink{Image}{Image} img}{450}{conturs}{}

\letterlabel{Ro}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ra}
\letterref{Re}
\letterref{Rg}
\letterref{Ri}
\letterref{Ro}
\letterlabelend{Ro}
\functionlistentry{int}{Root2}{double p1,p0,Complex *cptr1,*cptr2}{1396}{numeric}{}
\functionlistentry{int}{Root3}{double p2,p1,p0,Complex c[3]}{1397}{numeric}{}
\functionlistentry{int}{Root4}{double p3,p2,p1,p0,Complex c[4]}{1398}{numeric}{}
\functionlistentry{int}{RotateMoments}{const double m1[15],double c,double s, double m2[15]}{1612}{obsolet}{}
\functionlistentry{\hyperlink{RotQuaternion}{RotQuaternion}}{RotQuaternion::getConjugate}{}{1492}{quaternions}{}
\functionlistentry{\hyperlink{RotQuaternion}{RotQuaternion}}{RotQuaternion::getEigenachse}{}{1498}{quaternions}{}
\functionlistentry{double}{RotQuaternion::getEigenwinkel}{}{1497}{quaternions}{}
\functionlistentry{double}{RotQuaternion::getI}{}{1483}{quaternions}{}
\functionlistentry{vector3d}{RotQuaternion::getImaginary}{}{1486}{quaternions}{}
\functionlistentry{\hyperlink{RotQuaternion}{RotQuaternion}}{RotQuaternion::getInverse}{}{1493}{quaternions}{}
\functionlistentry{double}{RotQuaternion::getJ}{}{1484}{quaternions}{}
\functionlistentry{double}{RotQuaternion::getK}{}{1485}{quaternions}{}
\functionlistentry{\hyperlink{RotQuaternion}{RotQuaternion}}{RotQuaternion::getNegate}{}{1491}{quaternions}{}
\functionlistentry{double}{RotQuaternion::getNorm}{}{1495}{quaternions}{}
\functionlistentry{vector3d}{RotQuaternion::getPhases}{}{1499}{quaternions}{}
\functionlistentry{double}{RotQuaternion::getReal}{}{1482}{quaternions}{}
\functionlistentry{double}{RotQuaternion::getRotationAngle}{}{1487}{quaternions}{}
\functionlistentry{vector3d}{RotQuaternion::getRotationAxis}{}{1488}{quaternions}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{RotQuaternion::getRotationMatrix}{}{1500}{quaternions}{}
\functionlistentry{\hyperlink{RotQuaternion}{RotQuaternion}}{RotQuaternion::getSquare}{}{1494}{quaternions}{}
\functionlistentry{double}{RotQuaternion::getSquareNorm}{}{1496}{quaternions}{}
\functionlistentry{}{RotQuaternion::RotQuaternion}{}{1478}{quaternions}{}
\functionlistentry{}{RotQuaternion::RotQuaternion}{double angle, double x, double y, double z}{1479}{quaternions}{}
\functionlistentry{}{RotQuaternion::RotQuaternion}{double angle, vector3d\& axis}{1480}{quaternions}{}
\functionlistentry{}{RotQuaternion::RotQuaternion}{const \hyperlink{RotQuaternion}{RotQuaternion}\& b) { Es wird eine Kopie der Rotationsquaternion b erzeugt. (Kopier-Konstruktor} }{1481}{quaternions}{}
\functionlistentry{void}{RotQuaternion::setRotationAngle}{double angle}{1489}{quaternions}{}
\functionlistentry{void}{RotQuaternion::setRotationAxis}{vector3d\& axis}{1490}{quaternions}{}
\functionlistentry{int}{RotTrans}{double x0, double y0, double phi, double tr[3][3]}{1586}{obsolet}{}
\functionlistentry{void}{RotTransPoint}{double p1[2],double centre[2],double arc,double p2[2]}{1372}{numeric}{}
\functionlistentry{double}{RoughnessContur}{\hyperlink{Contur}{Contur} c, int diff}{431}{conturs}{}
\functionlistentry{double}{Round}{double val}{1359}{numeric}{}
\functionlistentry{int}{RoundInt}{double val}{1360}{numeric}{}
\functionlistentry{void}{RoundInt}{double val,int \&i}{1361}{numeric}{}

\letterlabel{Sc}
\letterlabel{S}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Sc}
\letterref{Se}
\letterref{Sh}
\letterref{Si}
\letterref{Sk}
\letterref{Sm}
\letterref{So}
\letterref{Sp}
\letterref{Sq}
\letterref{St}
\letterref{Su}
\letterlabelend{Sc}
\functionlistentry{int}{ScaleMoments}{const double m1[15],double a,double b, double m2[15]}{1611}{obsolet}{}
\functionlistentry{int}{ScaleTrans}{double x0, double y0, double a, double b, double tr[3][3]}{1587}{obsolet}{}
\functionlistentry{double*}{ScaleVec}{double v1[3],double fac,double v2[3]}{1561}{obsolet}{}
\functionlistentry{double*}{ScaleVecRn}{double *v1,int dim,double fac,double *v2}{1571}{obsolet}{}
\functionlistentry{double}{ScalProdVec}{double v1[3],double v2[3]}{1562}{obsolet}{}
\functionlistentry{double}{ScalProdVecRn}{double *v1,double *v2,int dim}{1572}{obsolet}{}
\functionlistentry{int}{ScanImg}{int ch,\hyperlink{Image}{Image} \&pi,int interactive=TRUE}{148}{imageio}{}
\functionlistentry{int}{ScanImg}{int ch,\hyperlink{Image}{Image} \&pr,\hyperlink{Image}{Image} \&pg,\hyperlink{Image}{Image} \&pb,int interactive=TRUE}{149}{imageio}{}
\functionlistentry{int}{ScanInfo}{int ch,int \&xm,int \&ym,int \&maxval,int \&channels, int \&flags,string \&descr}{150}{imageio}{}
\functionlistentry{void}{ScanWindow}{int ch,int x1,int y1,int x2,int y2}{147}{imageio}{}

\letterlabel{Se}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Sc}
\letterref{Se}
\letterref{Sh}
\letterref{Si}
\letterref{Sk}
\letterref{Sm}
\letterref{So}
\letterref{Sp}
\letterref{Sq}
\letterref{St}
\letterref{Su}
\letterlabelend{Se}
\functionlistentry{int}{SearchCircStart}{\hyperlink{Image}{Image} iv,\hyperlink{Image}{Image} io,int c[2],int r,int pgl,int ps[2]}{447}{conturs}{}
\functionlistentry{int}{SearchCStart}{\hyperlink{Image}{Image} iv,\hyperlink{Image}{Image} io,\hyperlink{Contur}{Contur} c,int *ptr,int pgl,int ps[2]}{448}{conturs}{}
\functionlistentry{int}{SearchGradStart}{\hyperlink{Image}{Image} iv,\hyperlink{Image}{Image} io,int thr,int diff,int ps[2],int mode}{446}{conturs}{}
\functionlistentry{int}{SearchRidgeStart}{\hyperlink{Image}{Image} imgv,\hyperlink{Image}{Image} imgo,int thr,int diff,int ps[2],int mode}{451}{conturs}{}
\functionlistentry{int}{SearchStart}{\hyperlink{Image}{Image} iv,\hyperlink{Image}{Image} io,object\_rc (*cls)(),int thr,int diff,int ps[2],int mode=HORZ}{438}{conturs}{}
\functionlistentry{int}{SearchStart}{\hyperlink{Image}{Image} iv,\hyperlink{Image}{Image} io,int (*cls)(),int thr,int diff,IPoint \&ps,int mode=HORZ}{439}{conturs}{}
\functionlistentry{Segment}{SegmentPointList}{PointList pl, int mode}{1186}{fitting}{}
\functionlistentry{Segment}{SegmentPointList}{PointList pl, int mode, [double maxdev]}{1187}{fitting}{}
\functionlistentry{\hyperlink{Contur}{Contur}}{SelContur}{\hyperlink{Image}{Image} img,int force\_close=FALSE}{1341}{graphics}{}
\functionlistentry{int}{SelectWindow}{const \hyperlink{Image}{Image} \&img,int mode}{111}{Visualisierung}{}
\functionlistentry{bool}{SelFile}{const string \&mask,string \&filename,string \&dirname,int mode=DIR\_FILE,const string \&title='''', int x1=-1,int y1=-1,int x2=-1,int y2=-1}{1449}{genericTools}{}
\functionlistentry{bool}{SelFile}{const string \&mask, string \&filename}{1450}{genericTools}{}
\functionlistentry{\hyperlink{LineSeg}{LineSeg}}{SelLine}{\hyperlink{Image}{Image} img}{1338}{graphics}{}
\functionlistentry{int}{SelLine}{\hyperlink{Image}{Image} img,IPoint \&p1,IPoint p2}{1339}{graphics}{}
\functionlistentry{int}{SelLine}{\hyperlink{Image}{Image} img,int p0[2],int p[2]}{1340}{graphics}{}
\functionlistentry{int}{SelPoint}{int mode,const \hyperlink{Image}{Image} \&img,int p[2]}{102}{Visualisierung}{}
\functionlistentry{IPoint}{SelPoint}{int mode,const \hyperlink{Image}{Image} \&img}{103}{Visualisierung}{}
\functionlistentry{IPoint}{SelPoint}{int mode,const \hyperlink{Image}{Image} \&img,int \&rc}{104}{Visualisierung}{}
\functionlistentry{\hyperlink{Point}{Point}}{SelPoint}{const \hyperlink{Image}{Image} \&img,int \&rc}{105}{Visualisierung}{}
\functionlistentry{\hyperlink{Point}{Point}}{SelPoint}{const \hyperlink{Image}{Image} \&img}{106}{Visualisierung}{}
\functionlistentry{IVector}{SelVector}{int mode,const \hyperlink{Image}{Image} \&img,int \&rc}{107}{Visualisierung}{}
\functionlistentry{IVector}{SelVector}{int mode,const \hyperlink{Image}{Image} \&img}{108}{Visualisierung}{}
\functionlistentry{IVector}{SelVector}{const \hyperlink{Image}{Image} \&img,int \&rc}{109}{Visualisierung}{}
\functionlistentry{IVector}{SelVector}{const \hyperlink{Image}{Image} \&img}{110}{Visualisierung}{}
\functionlistentry{void}{SetAlphaCursor}{int x,int y}{1422}{genericTools}{}
\functionlistentry{void}{SetAttribute}{int fg,int bg,int inv,int high}{1427}{genericTools}{}
\functionlistentry{int}{SetGreyColor}{int val,int red,int green,int blue}{96}{Visualisierung}{}
\functionlistentry{int}{SetGreyLUT}{int val1,int val2}{97}{Visualisierung}{}
\functionlistentry{int}{setImg}{const \hyperlink{Image}{Image} \&img,int val}{1084}{processing}{}
\functionlistentry{int}{setImg}{const \hyperlink{Image}{Image} \&img,const Function2d \& fn}{1085}{processing}{}
\functionlistentry{int}{SetImgD}{ImageD img,double val}{1096}{processing}{}
\functionlistentry{void}{SetOk}{void}{1549}{errorHandling}{}
\functionlistentry{int}{SetOverlayColor}{int val,int red,int green,int blue}{98}{Visualisierung}{}

\letterlabel{Sh}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Sc}
\letterref{Se}
\letterref{Sh}
\letterref{Si}
\letterref{Sk}
\letterref{Sm}
\letterref{So}
\letterref{Sp}
\letterref{Sq}
\letterref{St}
\letterref{Su}
\letterlabelend{Sh}
\functionlistentry{int}{ShiftTrans}{double x0, double y0, double tr[3][3]}{1585}{obsolet}{}
\functionlistentry{int}{Show}{int mode,\hyperlink{Image}{Image} img,const string \& title=''''}{89}{Visualisierung}{}
\functionlistentry{int}{Show}{int mode,\hyperlink{Image}{Image} img1,\hyperlink{Image}{Image} img2,const string \& title=''''}{90}{Visualisierung}{}
\functionlistentry{int}{Show}{int mode,\hyperlink{Image}{Image} img1,\hyperlink{Image}{Image} img2,\hyperlink{Image}{Image} img3,const string \&title=''''}{91}{Visualisierung}{}
\functionlistentry{int}{Show}{const \hyperlink{ColorImage}{ColorImage} \& img, int mode=ON}{92}{Visualisierung}{}

\letterlabel{Si}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Sc}
\letterref{Se}
\letterref{Sh}
\letterref{Si}
\letterref{Sk}
\letterref{Sm}
\letterref{So}
\letterref{Sp}
\letterref{Sq}
\letterref{St}
\letterref{Su}
\letterlabelend{Si}
\functionlistentry{int}{Sign}{int val}{1350}{numeric}{}
\functionlistentry{double}{SignD}{double val}{1351}{numeric}{}
\functionlistentry{int}{SingularValueDcmp}{const \hyperlink{Matrix}{Matrix} \&A,\hyperlink{Matrix}{Matrix} \&U,\hyperlink{Matrix}{Matrix} \&S,\hyperlink{Matrix}{Matrix} \&V}{1131}{matrixAlgebra}{}
\functionlistentry{int}{SingularValueDcmp}{const \hyperlink{Matrix}{Matrix} \&A,\hyperlink{Matrix}{Matrix} \&U,\hyperlink{Vector}{Vector} \&S,\hyperlink{Matrix}{Matrix} \&V}{1132}{matrixAlgebra}{}
\functionlistentry{int}{SingularValueDcmp}{MatrixStruct A,MatrixStruct *U,MatrixStruct *S,MatrixStruct *V}{1135}{matrixAlgebra}{}

\letterlabel{Sk}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Sc}
\letterref{Se}
\letterref{Sh}
\letterref{Si}
\letterref{Sk}
\letterref{Sm}
\letterref{So}
\letterref{Sp}
\letterref{Sq}
\letterref{St}
\letterref{Su}
\letterlabelend{Sk}
\functionlistentry{int}{SkelettImg}{const \hyperlink{Image}{Image} \&src,const \hyperlink{Image}{Image} \&dest,int lvl=1}{389}{filter}{}

\letterlabel{Sm}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Sc}
\letterref{Se}
\letterref{Sh}
\letterref{Si}
\letterref{Sk}
\letterref{Sm}
\letterref{So}
\letterref{Sp}
\letterref{Sq}
\letterref{St}
\letterref{Su}
\letterlabelend{Sm}
\functionlistentry{int}{SmearImg}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&dest,int n=3}{338}{filter}{}
\functionlistentry{int}{SmearImg}{const \hyperlink{Image}{Image} \&src,\hyperlink{Image}{Image} \&dest,int nx,int ny}{339}{filter}{}
\functionlistentry{int}{SmearImg}{const \hyperlink{Image}{Image} \&img,int n}{340}{filter}{}
\functionlistentry{int}{SmearImgD}{ImageD src,ImageD dest,int nx,int ny}{341}{filter}{}
\functionlistentry{int}{SmearImgD}{ImageD src,ImageD dest,int n}{342}{filter}{}

\letterlabel{So}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Sc}
\letterref{Se}
\letterref{Sh}
\letterref{Si}
\letterref{Sk}
\letterref{Sm}
\letterref{So}
\letterref{Sp}
\letterref{Sq}
\letterref{St}
\letterref{Su}
\letterlabelend{So}
\functionlistentry{bool}{Solve2}{double a1,double b1,double i1,double a2,double b2,double i2,double \&x1,double \&x2}{1124}{matrixAlgebra}{}
\functionlistentry{\hyperlink{Vector}{Vector}}{SolveLinEqu}{const \hyperlink{Matrix}{Matrix} \&M,const \hyperlink{Vector}{Vector} \&i}{1120}{matrixAlgebra}{}
\functionlistentry{MatrixStruct}{SortMatrix}{MatrixStruct A,int col,int mode}{1583}{obsolet}{}

\letterlabel{Sp}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Sc}
\letterref{Se}
\letterref{Sh}
\letterref{Si}
\letterref{Sk}
\letterref{Sm}
\letterref{So}
\letterref{Sp}
\letterref{Sq}
\letterref{St}
\letterref{Su}
\letterlabelend{Sp}
\functionlistentry{double}{SpatProdVec}{double v1[3],double v2[3],double v3[3]}{1564}{obsolet}{}
\functionlistentry{double}{Sphere::R}{}{656}{geoObject3d}{}
\functionlistentry{void}{Sphere::setR}{double vr}{657}{geoObject3d}{}
\functionlistentry{}{Sphere::Sphere}{}{649}{geoObject3d}{}
\functionlistentry{}{Sphere::Sphere}{double xp,double yp,double zp,double rp}{650}{geoObject3d}{}
\functionlistentry{}{Sphere::Sphere}{const \hyperlink{Vector3d}{Vector3d} \&p,double rp}{651}{geoObject3d}{}
\functionlistentry{}{Sphere::Sphere}{const Point3d \&p,double rp}{652}{geoObject3d}{}
\functionlistentry{}{Sphere::Sphere}{const \hyperlink{Sphere}{Sphere} \&p}{653}{geoObject3d}{}
\functionlistentry{explicit}{Sphere::Sphere}{const \hyperlink{Vector}{Vector} \&v}{654}{geoObject3d}{}
\functionlistentry{explicit}{Sphere::Sphere}{double d[]}{655}{geoObject3d}{}
\functionlistentry{double}{Sphere::Volume}{}{658}{geoObject3d}{}
\functionlistentry{string}{Split}{string \&text,const string \&del,int erase=true, int need\_del=false}{1413}{genericTools}{}
\functionlistentry{string}{SplitFilename}{const string \&fullname,string \&path,string \&basename,string \&ext}{1414}{genericTools}{}
\functionlistentry{string}{SplitFilename}{const string \&fullname,string \&path,string \&filename}{1415}{genericTools}{}
\functionlistentry{vector$<$vector$<$int$>$ $>$}{SplitToBranches}{\hyperlink{Forest}{Forest} f}{1297}{graph}{}

\letterlabel{Sq}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Sc}
\letterref{Se}
\letterref{Sh}
\letterref{Si}
\letterref{Sk}
\letterref{Sm}
\letterref{So}
\letterref{Sp}
\letterref{Sq}
\letterref{St}
\letterref{Su}
\letterlabelend{Sq}
\functionlistentry{double}{Sqr}{double val}{1345}{numeric}{}

\letterlabel{St}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Sc}
\letterref{Se}
\letterref{Sh}
\letterref{Si}
\letterref{Sk}
\letterref{Sm}
\letterref{So}
\letterref{Sp}
\letterref{Sq}
\letterref{St}
\letterref{Su}
\letterlabelend{St}
\functionlistentry{int}{Statistics::Init}{}{865}{statistics}{}
\functionlistentry{int}{Statistics::Init}{int dim}{866}{statistics}{}
\functionlistentry{}{Statistics::Statistics}{}{863}{statistics}{}
\functionlistentry{}{Statistics::Statistics}{int dim}{864}{statistics}{}

\letterlabel{Su}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Sc}
\letterref{Se}
\letterref{Sh}
\letterref{Si}
\letterref{Sk}
\letterref{Sm}
\letterref{So}
\letterref{Sp}
\letterref{Sq}
\letterref{St}
\letterref{Su}
\letterlabelend{Su}
\functionlistentry{int}{SubImg}{const \hyperlink{Image}{Image} \&img1,const \hyperlink{Image}{Image} \&img2,int smode,const \hyperlink{Image}{Image} \&dest,int mode=MD\_NORMALIZE}{1088}{processing}{}
\functionlistentry{int}{SubImg}{const \hyperlink{Image}{Image} \&img1,const \hyperlink{Image}{Image} \&img2,const \hyperlink{Image}{Image} \&dest,int smode=SMD\_ABSOLUTE,int mode=MD\_NORMALIZE}{1089}{processing}{}
\functionlistentry{int}{SubRankImg}{const \hyperlink{Image}{Image} \&src,int neighb,int rank,\hyperlink{Image}{Image} \&dest}{387}{filter}{}
\functionlistentry{double*}{SubVec}{double v1[3],double v2[3],double v3[3]}{1559}{obsolet}{}
\functionlistentry{double*}{SubVecRn}{double *v1,double *v2,int dim,double *v3}{1569}{obsolet}{}

\letterlabel{Ta}
\letterlabel{T}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ta}
\letterref{Te}
\letterref{Ti}
\letterref{Tr}
\letterlabelend{Ta}
\functionlistentry{int}{TangentCircle}{double p[2],double par[3],double p1[2],double p2[2]}{1378}{numeric}{}

\letterlabel{Te}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ta}
\letterref{Te}
\letterref{Ti}
\letterref{Tr}
\letterlabelend{Te}
\functionlistentry{int}{Text}{const string \&s,IPoint p,int val,int exp,\hyperlink{Image}{Image} \& img}{1314}{graphics}{}
\functionlistentry{int}{Text}{const string \&s,int x,int y,int val,int exp,\hyperlink{Image}{Image} \& img}{1315}{graphics}{}
\functionlistentry{int}{Text}{const char *s,int x,int y,int val,int exp,\hyperlink{Image}{Image} \& img}{1316}{graphics}{}

\letterlabel{Ti}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ta}
\letterref{Te}
\letterref{Ti}
\letterref{Tr}
\letterlabelend{Ti}
\functionlistentry{double}{TimeD}{int mode=TM\_WORLD}{1444}{genericTools}{}
\functionlistentry{int}{TimeWarp}{const \hyperlink{Matrix}{Matrix} \&cost,IMatrix \&reference\_pairs, int mode=TW\_NORMAL}{1265}{registration}{}

\letterlabel{Tr}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ta}
\letterref{Te}
\letterref{Ti}
\letterref{Tr}
\letterlabelend{Tr}
\functionlistentry{int}{Trafo::DimD}{void}{690}{geoTrafo}{}
\functionlistentry{int}{Trafo::DimS}{void}{689}{geoTrafo}{}
\functionlistentry{int}{Trafo::Flip}{int axis}{704}{geoTrafo}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{Trafo::Init}{void}{692}{geoTrafo}{}
\functionlistentry{\hyperlink{Trafo}{Trafo}}{Trafo::Inverse}{}{694}{geoTrafo}{}
\functionlistentry{int}{Trafo::Invert}{}{693}{geoTrafo}{}
\functionlistentry{double \&}{Trafo::operator ()}{int x,int y}{686}{geoTrafo}{}
\functionlistentry{\hyperlink{Trafo}{Trafo} \&}{Trafo::operator =}{const \hyperlink{Trafo}{Trafo} \&}{684}{geoTrafo}{}
\functionlistentry{\hyperlink{Trafo}{Trafo} \&}{Trafo::operator =}{const \hyperlink{Matrix}{Matrix} \&}{685}{geoTrafo}{}
\functionlistentry{int}{Trafo::Projective}{void}{713}{geoTrafo}{}
\functionlistentry{int}{Trafo::Rotate}{double x0,double y0,double phi}{699}{geoTrafo}{}
\functionlistentry{int}{Trafo::Rotate}{vector3d point,vector3d dir,double phi}{700}{geoTrafo}{}
\functionlistentry{int}{Trafo::RotateX}{double phi}{701}{geoTrafo}{}
\functionlistentry{int}{Trafo::RotateY}{double phi}{702}{geoTrafo}{}
\functionlistentry{int}{Trafo::RotateZ}{double phi}{703}{geoTrafo}{}
\functionlistentry{int}{Trafo::Scale}{double x0, double y0, double f}{707}{geoTrafo}{}
\functionlistentry{int}{Trafo::Scale}{double x0, double y0, double fx,double fy}{708}{geoTrafo}{}
\functionlistentry{int}{Trafo::Scale}{vector3d v, double f}{709}{geoTrafo}{}
\functionlistentry{int}{Trafo::Scale}{vector3d v, double fx,double fy,double fz}{710}{geoTrafo}{}
\functionlistentry{int}{Trafo::Scale}{\hyperlink{Vector}{Vector} v, double f}{711}{geoTrafo}{}
\functionlistentry{int}{Trafo::Scale}{\hyperlink{Vector}{Vector} v, \hyperlink{Vector}{Vector} f}{712}{geoTrafo}{}
\functionlistentry{int}{Trafo::ShearX}{double dxy}{705}{geoTrafo}{}
\functionlistentry{int}{Trafo::ShearY}{double dyx}{706}{geoTrafo}{}
\functionlistentry{int}{Trafo::Shift}{double x0,double y0}{695}{geoTrafo}{}
\functionlistentry{int}{Trafo::Shift}{double x0,double y0,double y0}{696}{geoTrafo}{}
\functionlistentry{int}{Trafo::Shift}{vector3d v}{697}{geoTrafo}{}
\functionlistentry{int}{Trafo::Shift}{\hyperlink{Vector}{Vector} v}{698}{geoTrafo}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{Trafo::Tmatrix}{void}{691}{geoTrafo}{}
\functionlistentry{}{Trafo::Trafo}{void}{680}{geoTrafo}{}
\functionlistentry{}{Trafo::Trafo}{const \hyperlink{Trafo}{Trafo} \&}{681}{geoTrafo}{}
\functionlistentry{}{Trafo::Trafo}{const \hyperlink{Matrix}{Matrix} \&}{682}{geoTrafo}{}
\functionlistentry{}{Trafo::Trafo}{int dims,int dimd}{683}{geoTrafo}{}
\functionlistentry{\hyperlink{TrafoDualQuaternion}{TrafoDualQuaternion}}{TrafoDualQuaternion::getConjugate}{}{1534}{quaternions}{}
\functionlistentry{\hyperlink{Quaternion}{Quaternion}}{TrafoDualQuaternion::getDual}{}{1530}{quaternions}{}
\functionlistentry{\hyperlink{TrafoDualQuaternion}{TrafoDualQuaternion}}{TrafoDualQuaternion::getInverse}{}{1536}{quaternions}{}
\functionlistentry{\hyperlink{TrafoDualQuaternion}{TrafoDualQuaternion}}{TrafoDualQuaternion::getNegate}{}{1533}{quaternions}{}
\functionlistentry{\hyperlink{Quaternion}{Quaternion}}{TrafoDualQuaternion::getReal}{}{1529}{quaternions}{}
\functionlistentry{\hyperlink{TrafoDualQuaternion}{TrafoDualQuaternion}}{TrafoDualQuaternion::getTilde}{}{1535}{quaternions}{}
\functionlistentry{\hyperlink{Matrix}{Matrix}}{TrafoDualQuaternion::getTransformationMatrix}{}{1537}{quaternions}{}
\functionlistentry{void}{TrafoDualQuaternion::setDual}{vector3d\& trans}{1532}{quaternions}{}
\functionlistentry{void}{TrafoDualQuaternion::setRotation}{\hyperlink{RotQuaternion}{RotQuaternion}\& rot}{1531}{quaternions}{}
\functionlistentry{}{TrafoDualQuaternion::TrafoDualQuaternion}{}{1526}{quaternions}{}
\functionlistentry{}{TrafoDualQuaternion::TrafoDualQuaternion}{\hyperlink{RotQuaternion}{RotQuaternion}\& rot, vector3d\& trans}{1527}{quaternions}{}
\functionlistentry{}{TrafoDualQuaternion::TrafoDualQuaternion}{const \hyperlink{TrafoDualQuaternion}{TrafoDualQuaternion}\& b}{1528}{quaternions}{}
\functionlistentry{\hyperlink{Contur}{Contur}}{TransContur}{\hyperlink{Contur}{Contur} c,double tr[3][3]}{1593}{obsolet}{}
\functionlistentry{int}{Transform}{const \hyperlink{Trafo}{Trafo} \&,double \&x,double \&y}{714}{geoTrafo}{}
\functionlistentry{int}{Transform}{const \hyperlink{Trafo}{Trafo} \&,\hyperlink{Point}{Point} \&p}{715}{geoTrafo}{}
\functionlistentry{int}{Transform}{const \hyperlink{Trafo}{Trafo} \&,double x,double y,double \&xt,double \&yt}{716}{geoTrafo}{}
\functionlistentry{int}{Transform}{const \hyperlink{Trafo}{Trafo} \&,\hyperlink{Point}{Point} p1,\hyperlink{Point}{Point} \&p2}{717}{geoTrafo}{}
\functionlistentry{int}{Transform}{const \hyperlink{Trafo}{Trafo} \&,double \&x,double \&y,double \&z)}{720}{geoTrafo}{}
\functionlistentry{int}{Transform}{const \hyperlink{Trafo}{Trafo} \&,double x,double y,double z,double \&xt,double \&yt,double \&zt}{721}{geoTrafo}{}
\functionlistentry{int}{Transform}{const \hyperlink{Trafo}{Trafo} \&,double x,double y,double z,double \&xt,double \&yt}{722}{geoTrafo}{}
\functionlistentry{\hyperlink{Contur}{Contur}}{Transform}{const \hyperlink{Trafo}{Trafo} \& tr,const \hyperlink{Contur}{Contur} \& c}{725}{geoTrafo}{}
\functionlistentry{int}{Transform}{const \hyperlink{Trafo}{Trafo} \&,const \hyperlink{Image}{Image} \&simg,\hyperlink{Image}{Image} \&dimg,int mode=DEFAULT}{726}{geoTrafo}{}
\functionlistentry{int}{Transform}{const \hyperlink{Trafo}{Trafo} \&,const \hyperlink{Image}{Image} \&simg,\hyperlink{Image}{Image} \&dimg,int mode, \hyperlink{Image}{Image} \&mark,int val=1}{727}{geoTrafo}{}
\functionlistentry{int}{TransformAndRound}{const \hyperlink{Trafo}{Trafo} \&,int \&x,int \&y}{718}{geoTrafo}{}
\functionlistentry{int}{TransformAndRound}{const \hyperlink{Trafo}{Trafo} \&,int x,int y,int \&xt,int \&yt}{719}{geoTrafo}{}
\functionlistentry{int}{TransformList}{const \hyperlink{Trafo}{Trafo} \&tr,\hyperlink{Matrix}{Matrix} \&m}{723}{geoTrafo}{}
\functionlistentry{int}{TransformList}{const \hyperlink{Trafo}{Trafo} \&tr,const \hyperlink{Matrix}{Matrix} \&m,\hyperlink{Matrix}{Matrix} \&m2}{724}{geoTrafo}{}
\functionlistentry{int}{TransImg}{\hyperlink{Image}{Image} imgs,double tr[3][3],int mode,\hyperlink{Image}{Image} imgd}{1592}{obsolet}{}
\functionlistentry{int}{TranslateMoments}{const double m1[15],double x,double y,double m2[15]}{1607}{obsolet}{}
\functionlistentry{MatrixStruct}{TranspMat}{MatrixStruct m1,MatrixStruct m2}{1579}{obsolet}{}
\functionlistentry{double*}{TransPoint}{double p1[2],double tr[3][3],double p2[2]}{1591}{obsolet}{}
\functionlistentry{void}{Triangle2Region}{const \hyperlink{Triangle}{Triangle} \&t, \hyperlink{Region}{Region} \&r}{590}{geoObject}{}
\functionlistentry{\hyperlink{Point}{Point}}{Triangle::getCCCenter}{}{587}{geoObject}{}
\functionlistentry{double}{Triangle::getCCRadius}{}{588}{geoObject}{}
\functionlistentry{\hyperlink{Point}{Point}}{Triangle::getCorner}{int i}{583}{geoObject}{}
\functionlistentry{bool}{Triangle::isInsideCC}{\hyperlink{Point}{Point} point}{589}{geoObject}{}
\functionlistentry{bool}{Triangle::isValid}{}{582}{geoObject}{}
\functionlistentry{const \hyperlink{Point}{Point} \&}{Triangle::P1}{}{584}{geoObject}{}
\functionlistentry{const \hyperlink{Point}{Point} \&}{Triangle::P2}{}{585}{geoObject}{}
\functionlistentry{const \hyperlink{Point}{Point} \&}{Triangle::P3}{}{586}{geoObject}{}
\functionlistentry{}{Triangle::Triangle}{}{580}{geoObject}{}
\functionlistentry{}{Triangle::Triangle}{\hyperlink{Point}{Point} p1, \hyperlink{Point}{Point} p2, \hyperlink{Point}{Point} p3}{581}{geoObject}{}

\letterlabel{Up}
\letterlabel{U}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Up}
\letterlabelend{Up}
\functionlistentry{int}{UpdateLimitImgD}{ImageD img}{84}{Images}{}
\functionlistentry{string}{uppercase}{const string \&s}{1412}{genericTools}{}

\letterlabel{Ve}
\letterlabel{V}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ve}
\letterref{Vi}
\letterlabelend{Ve}
\functionlistentry{void}{Vector3d::Normalize}{}{203}{datastructures}{}
\functionlistentry{\hyperlink{Vector3d}{Vector3d}}{Vector3d::Normalized}{}{202}{datastructures}{}
\functionlistentry{\hyperlink{Vector}{Vector}}{Vector3d::operator Vector}{}{201}{datastructures}{}
\functionlistentry{}{Vector3d::Vector3d}{}{195}{datastructures}{}
\functionlistentry{}{Vector3d::Vector3d}{const \hyperlink{Vector3d}{Vector3d} \&p}{196}{datastructures}{}
\functionlistentry{}{Vector3d::Vector3d}{double xp,double yp,double zp}{197}{datastructures}{}
\functionlistentry{explicit}{Vector3d::Vector3d}{const \hyperlink{Vector}{Vector} \&v}{198}{datastructures}{}
\functionlistentry{explicit}{Vector3d::Vector3d}{const IVector \&v}{199}{datastructures}{}
\functionlistentry{explicit}{Vector3d::Vector3d}{double p[]}{200}{datastructures}{}
\functionlistentry{void}{Vector::Append}{double val}{245}{datastructures}{}
\functionlistentry{void}{Vector::Append}{const \hyperlink{Vector}{Vector} \&v}{246}{datastructures}{}
\functionlistentry{double \&}{Vector::at}{int idx}{233}{datastructures}{}
\functionlistentry{void}{Vector::Delete}{int i1,int i2}{248}{datastructures}{}
\functionlistentry{void}{Vector::Delete}{int i}{249}{datastructures}{}
\functionlistentry{bool}{Vector::empty}{}{236}{datastructures}{}
\functionlistentry{void}{Vector::Exchange}{int i1,int i2}{247}{datastructures}{}
\functionlistentry{double}{Vector::Length}{}{250}{datastructures}{}
\functionlistentry{void}{Vector::Normalize}{}{251}{datastructures}{}
\functionlistentry{void}{Vector::Set}{double val}{239}{datastructures}{}
\functionlistentry{void}{Vector::SetV}{double d1}{240}{datastructures}{}
\functionlistentry{void}{Vector::SetV}{double d1,double d2}{241}{datastructures}{}
\functionlistentry{void}{Vector::SetV}{double d1,double d2,double d3}{242}{datastructures}{}
\functionlistentry{void}{Vector::SetV}{double d1,double d2,double d3,double d4}{243}{datastructures}{}
\functionlistentry{void}{Vector::SetV}{double d1,double d2,double d3,double d4,double d5}{244}{datastructures}{}
\functionlistentry{int}{Vector::Size}{}{234}{datastructures}{}
\functionlistentry{unsigned int}{Vector::size}{}{235}{datastructures}{}
\functionlistentry{void}{Vector::Sort}{int order=0}{252}{datastructures}{}
\functionlistentry{}{Vector::Vector}{}{224}{datastructures}{}
\functionlistentry{}{Vector::Vector}{int n}{225}{datastructures}{}
\functionlistentry{}{Vector::Vector}{int n,double *data}{226}{datastructures}{}
\functionlistentry{}{Vector::Vector}{const \hyperlink{Vector}{Vector} \&v}{227}{datastructures}{}
\functionlistentry{explicit}{Vector::Vector}{const vector<double> \&v}{228}{datastructures}{}
\functionlistentry{}{Vector::Vector}{double d1,double d2}{229}{datastructures}{}
\functionlistentry{}{Vector::Vector}{double d1,double d2,double d3}{230}{datastructures}{}
\functionlistentry{}{Vector::Vector}{double d1,double d2,double d3,double d4}{231}{datastructures}{}
\functionlistentry{}{Vector::Vector}{double d1,double d2,double d3,double d4,double d5}{232}{datastructures}{}
\functionlistentry{double}{VectorDistance::Distance}{const vector$<$double$>$ \&x,const vector$<$double$>$ \&x}{1234}{features}{}
\functionlistentry{double}{VectorDistance::Distance}{const \hyperlink{Vector}{Vector} \&x,const \hyperlink{Vector}{Vector} \&y}{1235}{features}{}
\functionlistentry{double}{VectorDistance::operator()}{const vector$<$double$>$ \&x,const vector$<$double$>$ \&y}{1236}{features}{}
\functionlistentry{double}{VectorDistance::operator()}{const \hyperlink{Vector}{Vector} \&x,const \hyperlink{Vector}{Vector} \&y}{1237}{features}{}

\letterlabel{Vi}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ve}
\letterref{Vi}
\letterlabelend{Vi}
\functionlistentry{void}{VideoFile::getPara}{int \&xs,int \&ys,int \&mv,int \&fps}{122}{imageio}{}
\functionlistentry{int}{VideoFile::open}{const string \&fn,ios\_base::openmode mode = ios\_base::in}{121}{imageio}{}
\functionlistentry{bool}{VideoFile::Read}{\hyperlink{Image}{Image} \&img,int ch=3}{125}{imageio}{}
\functionlistentry{bool}{VideoFile::Read}{\hyperlink{Image}{Image} \&ir,\hyperlink{Image}{Image} \&ig,\hyperlink{Image}{Image} \&ib}{126}{imageio}{}
\functionlistentry{bool}{VideoFile::Read}{\hyperlink{ColorImage}{ColorImage} \&irgb}{127}{imageio}{}
\functionlistentry{void}{VideoFile::setCPara}{const string \&p}{124}{imageio}{}
\functionlistentry{void}{VideoFile::setPara}{int xs,int ys,int mv,int fps,int bitrate=0}{123}{imageio}{}
\functionlistentry{}{VideoFile::VideoFile}{}{119}{imageio}{}
\functionlistentry{}{VideoFile::VideoFile}{const string \&fn,ios\_base::openmode mode = ios\_base::in}{120}{imageio}{}
\functionlistentry{bool}{VideoFile::Write}{const \hyperlink{Image}{Image} \&img}{128}{imageio}{}
\functionlistentry{bool}{VideoFile::Write}{const \hyperlink{Image}{Image} \&ir,const \hyperlink{Image}{Image} \&ig,const \hyperlink{Image}{Image} \&ib}{129}{imageio}{}
\functionlistentry{bool}{VideoFile::Write}{const ImageRGB \&irgb}{130}{imageio}{}
\functionlistentry{int}{VideoFileCached::FrameNumber}{}{145}{imageio}{}
\functionlistentry{int}{VideoFileCached::getError}{}{146}{imageio}{}
\functionlistentry{void}{VideoFileCached::getPara}{int \&xs,int \&ys,int \&mv,int \&fps}{141}{imageio}{}
\functionlistentry{bool}{VideoFileCached::Read}{\hyperlink{Image}{Image} \&ir,\hyperlink{Image}{Image} \&ig,\hyperlink{Image}{Image} \&ib,int frame=\hyperlink{VideoFileCached}{VideoFileCached}::next}{142}{imageio}{}
\functionlistentry{bool}{VideoFileCached::Read}{\hyperlink{ColorImage}{ColorImage} \&img,int frame=\hyperlink{VideoFileCached}{VideoFileCached}::next}{143}{imageio}{}
\functionlistentry{bool}{VideoFileCached::Read}{ImageRGB \&img,int frame=\hyperlink{VideoFileCached}{VideoFileCached}::next}{144}{imageio}{}
\functionlistentry{}{VideoFileCached::VideoFileCached}{const string \&fn,int buffersize}{140}{imageio}{}

\letterlabel{Wa}
\letterlabel{W}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Wa}
\letterref{We}
\letterref{Wh}
\letterref{Wi}
\letterref{Wr}
\letterref{Ws}
\letterlabelend{Wa}
\functionlistentry{void}{Walker::init}{}{178}{datastructures}{}
\functionlistentry{void}{Walker::moveTo}{IPoint p}{177}{datastructures}{}
\functionlistentry{void}{Walker::next}{}{179}{datastructures}{}
\functionlistentry{void}{Walker::next}{int steps}{180}{datastructures}{}
\functionlistentry{bool}{Walker::ready}{}{181}{datastructures}{}
\functionlistentry{}{Walker::Walker}{}{174}{datastructures}{}
\functionlistentry{}{Walker::Walker}{IPoint p}{175}{datastructures}{}
\functionlistentry{}{Walker::Walker}{int x, int y}{176}{datastructures}{}

\letterlabel{We}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Wa}
\letterref{We}
\letterref{Wh}
\letterref{Wi}
\letterref{Wr}
\letterref{Ws}
\letterlabelend{We}
\functionlistentry{double}{Weight}{const \hyperlink{Statistics}{Statistics} \&st}{869}{statistics}{}

\letterlabel{Wh}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Wa}
\letterref{We}
\letterref{Wh}
\letterref{Wi}
\letterref{Wr}
\letterref{Ws}
\letterlabelend{Wh}
\functionlistentry{int}{WhiteningFImgD}{ImageD re1,ImageD im1,ImageD re2,ImageD im2,double beta=0}{1227}{signalTrafo}{}
\functionlistentry{int}{WhiteningHImgD}{ImageD imgs,ImageD imgd,double beta=0}{1228}{signalTrafo}{}
\functionlistentry{int}{WhiteningImgD}{ImageD img1,ImageD img2,double beta=0}{1226}{signalTrafo}{}

\letterlabel{Wi}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Wa}
\letterref{We}
\letterref{Wh}
\letterref{Wi}
\letterref{Wr}
\letterref{Ws}
\letterlabelend{Wi}
\functionlistentry{int}{Window::GetBottom}{}{214}{datastructures}{}
\functionlistentry{int}{Window::GetLeft}{}{208}{datastructures}{}
\functionlistentry{int}{Window::GetRight}{}{210}{datastructures}{}
\functionlistentry{IPoint}{Window::getSize}{}{218}{datastructures}{}
\functionlistentry{int}{Window::GetTop}{}{212}{datastructures}{}
\functionlistentry{int}{Window::Height}{}{207}{datastructures}{}
\functionlistentry{bool}{Window::Inside}{const IPoint \&p}{219}{datastructures}{}
\functionlistentry{bool}{Window::Inside}{int x,int y}{220}{datastructures}{}
\functionlistentry{bool}{Window::operator !=}{const \hyperlink{Window}{Window} \&w}{222}{datastructures}{}
\functionlistentry{bool}{Window::operator ==}{const \hyperlink{Window}{Window} \&w}{221}{datastructures}{}
\functionlistentry{const IPoint \&}{Window::P1}{}{216}{datastructures}{}
\functionlistentry{const IPoint \&}{Window::P2}{}{217}{datastructures}{}
\functionlistentry{int}{Window::Shift}{int dx,int dy}{223}{datastructures}{}
\functionlistentry{int}{Window::Width}{}{206}{datastructures}{}
\functionlistentry{}{Window::Window}{}{204}{datastructures}{}
\functionlistentry{}{Window::Window}{int x1,int y1,int x2,int y2}{205}{datastructures}{}
\functionlistentry{int}{Window::XA}{}{211}{datastructures}{}
\functionlistentry{int}{Window::XI}{}{209}{datastructures}{}
\functionlistentry{int}{Window::YA}{}{215}{datastructures}{}
\functionlistentry{int}{Window::Yi}{}{213}{datastructures}{}
\functionlistentry{}{WindowWalker::WindowWalker}{const \hyperlink{Window}{Window} \&w}{182}{datastructures}{}
\functionlistentry{}{WindowWalker::WindowWalker}{const \hyperlink{Image}{Image} \&img center}{183}{datastructures}{}
\functionlistentry{}{WindowWalker::WindowWalker}{IPoint center, int sizex, int sizey = -1}{184}{datastructures}{}

\letterlabel{Wr}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Wa}
\letterref{We}
\letterref{Wh}
\letterref{Wi}
\letterref{Wr}
\letterref{Ws}
\letterlabelend{Wr}
\functionlistentry{int}{Write}{const \hyperlink{Statistics}{Statistics} \&st,const string \&fn}{872}{statistics}{}
\functionlistentry{int}{WriteImg}{const \hyperlink{Image}{Image} \&img,const string \&filename}{114}{imageio}{}
\functionlistentry{int}{WriteImg}{const \hyperlink{Image}{Image} \&ir,const \hyperlink{Image}{Image} \&ig,const \hyperlink{Image}{Image} \&ib,const string \&filename}{116}{imageio}{}
\functionlistentry{int}{WriteStatistic}{Statistic st,char *file}{1601}{obsolet}{}

\letterlabel{Ws}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Wa}
\letterref{We}
\letterref{Wh}
\letterref{Wi}
\letterref{Wr}
\letterref{Ws}
\letterlabelend{Ws}
\functionlistentry{int}{WST}{\hyperlink{Image}{Image} in, \hyperlink{Image}{Image} WSImg, int mode=1}{1143}{segmentation}{}

\letterlabel{Xs}
\letterlabel{X}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Xs}
\letterref{Xy}
\letterlabelend{Xs}
\functionlistentry{int}{XShearMoments}{const double m[15],double a,double ms[15]}{1609}{obsolet}{}

\letterlabel{Xy}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Xs}
\letterref{Xy}
\letterlabelend{Xy}
\functionlistentry{void}{XyzToLab}{double x, double y, double z, double \&l, double \&a, double \&b}{313}{datastructures}{}
\functionlistentry{void}{XyzToRgb}{double x, double y, double z, \hyperlink{ColorValue}{ColorValue} \&dst, int maxval = 255}{305}{datastructures}{}
\functionlistentry{void}{XyzToRgb}{double x, double y, double z, double \&r, double \&g, double \&b}{312}{datastructures}{}

\letterlabel{Ys}
\letterlabel{Y}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ys}
\letterref{Yu}
\letterlabelend{Ys}
\functionlistentry{int}{YShearMoments}{const double m1[15],double b,double m2[15]}{1610}{obsolet}{}

\letterlabel{Yu}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Ys}
\letterref{Yu}
\letterlabelend{Yu}
\functionlistentry{int}{YuvToColorImage}{const \hyperlink{Image}{Image} \&y, const \hyperlink{Image}{Image} \&u, const \hyperlink{Image}{Image} \&v, const \hyperlink{ColorImage}{ColorImage} \&dst}{1112}{processing}{}
\functionlistentry{void}{YuvToRgb}{double y, double u, double v, \hyperlink{ColorValue}{ColorValue} \&dst, int maxval = 255}{304}{datastructures}{}
\functionlistentry{void}{YuvToRgb}{double y, double u, double v, double \&r, double \&g, double \&b}{309}{datastructures}{}

\letterlabel{Zo}
\letterlabel{Z}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}

\letterref{Zo}
\letterlabelend{Zo}
\functionlistentry{int}{Zoom}{\hyperlink{Image}{Image} img,int val,int x,int y}{93}{Visualisierung}{}
\functionlistentry{int}{Zoom}{\hyperlink{Image}{Image} img}{94}{Visualisierung}{}
 
\end{document}
