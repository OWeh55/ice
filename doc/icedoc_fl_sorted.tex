\label{FunktionsListe}

\letterlabel{A}
\letterlabel{A}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}
\letterlabelend{A}
\functionlistentry{}{accu1::accu1}{}{917}{statistics}{}
\functionlistentry{}{accu1::accu1}{int n,double min=0.0,double max=1.0,bool mod=false}{919}{statistics}{}
\functionlistentry{void}{accu1::Add}{double val}{923}{statistics}{}
\functionlistentry{void}{accu1::getMax}{double \&val}{927}{statistics}{}
\functionlistentry{void}{accu1::getMax}{double \&val,double \&ct}{928}{statistics}{}
\functionlistentry{void}{accu1::setDim}{int n,double min=0.0,double max=1.0,bool mod=false}{921}{statistics}{}
\functionlistentry{}{accu2::accu2}{}{918}{statistics}{}
\functionlistentry{}{accu2::accu2}{int n1,double min1,double max1,bool mod1, int n1,double min2, double max2,bool mod2,int smear=1}{920}{statistics}{}
\functionlistentry{void}{accu2::Add}{double val1,double val2}{924}{statistics}{}
\functionlistentry{void}{accu2::Add}{const Vector \&v}{925}{statistics}{}
\functionlistentry{void}{accu2::Add}{Point v}{926}{statistics}{}
\functionlistentry{void}{accu2::getMax}{double \&val1,double \&val2}{929}{statistics}{}
\functionlistentry{void}{accu2::getMax}{double \&val1,double \&val2,double \&ct}{930}{statistics}{}
\functionlistentry{Point}{accu2::getMax}{}{931}{statistics}{}
\functionlistentry{Point}{accu2::getMax}{double \&ct}{932}{statistics}{}
\functionlistentry{void}{accu2::setDim}{int dim,int n,double min=0.0,double max=1.0,bool mod=false}{922}{statistics}{}
\functionlistentry{int}{AddImg}{const Image \&img1,const Image \&img2, const Image \&dest,int mode=MD\_NORMALIZE}{1090}{processing}{}
\functionlistentry{int}{AddImgD}{ImageD img1,ImageD img2,ImageD dest}{1101}{processing}{}
\functionlistentry{double*}{AddVec}{double v1[3],double v2[3],double v3[3]}{1569}{obsolet}{}
\functionlistentry{double*}{AddVecRn}{double *v1,double *v2,int dim,double *v3}{1579}{obsolet}{}
\functionlistentry{int}{AffinAlgebraicInvar}{double m[15],double flu[4]}{1626}{obsolet}{}
\functionlistentry{Trafo}{AffineFit}{const Moments \&m1,const Moments \&m2}{839}{moments}{}
\functionlistentry{double}{AffinFitMoments}{double m1[15],double m2[15],double tr[3][3]}{1631}{obsolet}{}
\functionlistentry{double}{AffinFitPolygons}{PointList pl1,PointList pl2,double tr[3][3]}{1632}{obsolet}{}
\functionlistentry{int}{AffinHuInvar}{double m[15],double hu[7]}{1627}{obsolet}{}
\functionlistentry{int}{AffinIterateMoments}{double m[21],double maf[21],double atr[3][3]}{1630}{obsolet}{}
\functionlistentry{int}{AffinNormMoments}{double m[21],double maf[21],double atr[3][3]}{1628}{obsolet}{}
\functionlistentry{int}{AffinTransMoments}{const double m1[15],double tr[3][3],double m2[15]}{1619}{obsolet}{}
\functionlistentry{void}{Alpha}{int mode}{1429}{genericTools}{}
\functionlistentry{int}{AlphaSizeX}{void}{1436}{genericTools}{}
\functionlistentry{int}{AlphaSizeY}{void}{1437}{genericTools}{}
\functionlistentry{double}{AngleVec}{double v1[3],double v2[3]}{1576}{obsolet}{}
\functionlistentry{double}{AngleVecRn}{double *v1,double *v2,int dim}{1584}{obsolet}{}
\functionlistentry{int}{Append}{const Vector \&v}{266}{datastructures}{}
\functionlistentry{double}{Arcus}{double degree}{1359}{numeric}{}
\functionlistentry{double}{AreaPolygon}{PointList pl}{1390}{numeric}{}
\functionlistentry{double}{AreaPolygon}{const Matrix \&pl}{1391}{numeric}{}
\functionlistentry{int}{AssignCalibPattern}{Image \&image, Matrix \&imagepoints, Matrix \&worldpoints, Image debug\_image = Image(), Image debug\_mark = Image()}{794}{cameraModel}{}
\functionlistentry{int}{AssignCalibPattern}{Image \&image, Matrix \&imagepoints, Matrix \&worldpoints, Camera \&c, Image debug\_image = Image(), Image debug\_mark = Image()}{795}{cameraModel}{}
\functionlistentry{int}{AssignFunction}{const Matrix \&cost,IMatrix \&pairs,int mode}{1264}{registration}{}

\letterlabel{B}
\letterlabel{B}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}
\letterlabelend{B}
\functionlistentry{int}{Bairstow}{const Vector \&para,Matrix\& result,int inumber = 1000}{1410}{numeric}{}
\functionlistentry{void}{Bell}{void}{1435}{genericTools}{}
\functionlistentry{int}{BinImg}{const Image \&src,Image \&dest,int thr=1,int val=-1}{1067}{processing}{}
\functionlistentry{int}{BinImg}{Image \&src,int thr=1}{1068}{processing}{}
\functionlistentry{int}{BoxImg}{const Image \&src,Image \&dest,int n=3}{343}{filter}{}
\functionlistentry{int}{BoxImg}{const Image \&src,Image \&dest,int nx,int ny}{344}{filter}{}

\letterlabel{C}
\letterlabel{C}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}
\letterlabelend{C}
\functionlistentry{int}{CalcCentralMoments}{const double m[15],double mc[15]}{1624}{obsolet}{}
\functionlistentry{Contur}{CalcContur}{Image iv,Image io,object\_rc (*cls)(),int thr,int ps[2],int lng=0,object\_rc marked=isunderground,object\_rc outside=isunderground}{440}{conturs}{}
\functionlistentry{Contur}{CalcContur}{Image iv,Image io,object\_rc (*cls)(),int thr,const IPoint \&ps,int lng=0,object\_rc marked=isunderground,object\_rc outside=isunderground}{441}{conturs}{}
\functionlistentry{int}{CalcDirectionImg}{const Image \&src,Image \&dir,int dsize=11}{360}{filter}{}
\functionlistentry{int}{CalcDirectionImg}{const Image \&src,Image \&dir,int dsize=11,ImageD eval}{361}{filter}{}
\functionlistentry{int}{CalcDirectionStructImg}{const Image \&src,Image \&dir,int dsize=11}{362}{filter}{}
\functionlistentry{int}{CalcDirectionStructImg}{const Image \&src,Image \&dir,int dsize=11,ImageD lambda1,ImageD lambda2}{363}{filter}{}
\functionlistentry{Contur}{CalcGradContur}{Image iv,Image io,int thr,int maxg,int ps[2],int lng}{449}{conturs}{}
\functionlistentry{Contur}{CalcRidgeContur}{Image imgv,Image imgo,int thr,int ps[2],int lng}{452}{conturs}{}
\functionlistentry{double}{CalcThreshold}{const Hist \&h}{432}{conturs}{}
\functionlistentry{double}{CalcThreshold}{const Hist \&h,double \&discmax}{433}{conturs}{}
\functionlistentry{int}{CalcThreshold}{const Histogram \&h}{434}{conturs}{}
\functionlistentry{int}{CalcThreshold}{const Histogram \&h,double \&discmax}{435}{conturs}{}
\functionlistentry{int}{CalcThreshold}{Image img}{436}{conturs}{}
\functionlistentry{int}{CalcThreshold}{Image img,double \&discmax,int diff=1}{437}{conturs}{}
\functionlistentry{int}{Calibrate}{vector$<$Image$>$ \&images, Camera \&c, bool dist=true, Image debug\_image = Image(), Image debug\_mark = Image()}{792}{cameraModel}{}
\functionlistentry{int}{Calibrate}{vector$<$Image$>$ \&images, vector$<$Camera$>$ \&cv, bool dist=true, Image debug\_image = Image(), Image debug\_mark = Image()}{793}{cameraModel}{}
\functionlistentry{int}{CalibrateWithHomographies}{vector$<$Trafo$>$ \&H, Camera \&c}{799}{cameraModel}{}
\functionlistentry{int}{CalibrateWithHomographies}{vector$<$Trafo$>$ \&H, vector$<$Camera$>$ \&cv}{800}{cameraModel}{}
\functionlistentry{int}{CalibrateWithPattern}{vector$<$Matrix$>$ \&imagepoints, vector$<$Matrix$>$ \&worldpoints, Camera \&c}{797}{cameraModel}{}
\functionlistentry{int}{CalibrateWithPattern}{vector$<$Matrix$>$ \&imagepoints, vector$<$Matrix$>$ \&worldpoints, vector$<$Camera$>$ \&cv}{798}{cameraModel}{}
\functionlistentry{}{Camera::Camera}{int dtyp=1}{770}{cameraModel}{}
\functionlistentry{}{Camera::Camera}{const Vector \&v,int dtyp=1}{771}{cameraModel}{}
\functionlistentry{}{Camera::Camera}{const Camera \&c}{772}{cameraModel}{}
\functionlistentry{const Distortion}{Camera::Dist}{}{779}{cameraModel}{}
\functionlistentry{int}{Camera::DistType}{}{780}{cameraModel}{}
\functionlistentry{void}{Camera::Get}{double \&fp,double \&ap,double \&sp,double \&u0p,double \&v0p}{777}{cameraModel}{}
\functionlistentry{void}{Camera::GetExt}{double \&dxp,double \&dyp,double \&dzp, double \&ap,double \&bp,double \&cp}{778}{cameraModel}{}
\functionlistentry{Vector}{Camera::MakeVector}{int what=Camera::all}{782}{cameraModel}{}
\functionlistentry{void}{Camera::Set}{double fp,double ap,double sp, double u0p,double v0p,const Distortion \&d}{774}{cameraModel}{}
\functionlistentry{void}{Camera::Set}{double fp,double ap,double sp,double u0p,double v0p}{775}{cameraModel}{}
\functionlistentry{void}{Camera::Set}{const Vector \&v,int what=Camera::all}{783}{cameraModel}{}
\functionlistentry{void}{Camera::SetDist}{const Distortion \&d}{781}{cameraModel}{}
\functionlistentry{void}{Camera::SetExt}{double dxp,double dyp,double dzp,double ap,double bp,double cp}{776}{cameraModel}{}
\functionlistentry{string}{Camera::toString}{const string \&del}{791}{cameraModel}{}
\functionlistentry{Vector}{Camera::Transform}{const Vector \&v}{784}{cameraModel}{}
\functionlistentry{Point}{Camera::Transform}{const Vector3d \&v}{785}{cameraModel}{}
\functionlistentry{Point}{Camera::Transform}{const Point3d \&v}{786}{cameraModel}{}
\functionlistentry{void}{Camera::Transform}{double x,double y,double z,double \&u,double \&v}{787}{cameraModel}{}
\functionlistentry{int}{CepstrumImgD}{ImageD imgs,ImageD imgd}{1213}{signalTrafo}{}
\functionlistentry{Matrix}{CholeskyDecomposition}{const Matrix \&m}{1119}{matrixAlgebra}{}
\functionlistentry{double}{CholeskyDeterminant}{const Matrix \&m}{1122}{matrixAlgebra}{}
\functionlistentry{Matrix}{CholeskyInverse}{const Matrix \&m}{1118}{matrixAlgebra}{}
\functionlistentry{}{Circle::Circle}{}{514}{geoObject}{}
\functionlistentry{}{Circle::Circle}{const Circle \&c}{515}{geoObject}{}
\functionlistentry{}{Circle::Circle}{double xm,double ym,double r}{516}{geoObject}{}
\functionlistentry{}{Circle::Circle}{Point m,double r}{517}{geoObject}{}
\functionlistentry{explicit}{Circle::Circle}{const Vector \&c}{518}{geoObject}{}
\functionlistentry{explicit}{Circle::Circle}{const double d[]}{519}{geoObject}{}
\functionlistentry{double}{Circle::getR}{}{520}{geoObject}{}
\functionlistentry{void}{Circle::setR}{double val}{521}{geoObject}{}
\functionlistentry{Contur}{CircleContur}{double par[3]}{1343}{graphics}{}
\functionlistentry{}{CircleSeg::CircleSeg}{}{522}{geoObject}{}
\functionlistentry{}{CircleSeg::CircleSeg}{const CircleSeg \&c}{523}{geoObject}{}
\functionlistentry{}{CircleSeg::CircleSeg}{double xm,double ym,double r, double phi1,double phi2}{524}{geoObject}{}
\functionlistentry{}{CircleSeg::CircleSeg}{Point p,double r,double phi1,double phi2}{525}{geoObject}{}
\functionlistentry{explicit}{CircleSeg::CircleSeg}{const Vector \&c}{526}{geoObject}{}
\functionlistentry{explicit}{CircleSeg::CircleSeg}{const double d[]}{527}{geoObject}{}
\functionlistentry{double }{CircleSeg::getPhi1}{}{528}{geoObject}{}
\functionlistentry{double}{CircleSeg::getPhi2}{}{530}{geoObject}{}
\functionlistentry{void}{CircleSeg::setPhi1}{double val}{529}{geoObject}{}
\functionlistentry{void}{CircleSeg::setPhi2}{double val}{531}{geoObject}{}
\functionlistentry{Contur}{CircleSegmentContur}{double par[5]}{1345}{graphics}{}
\functionlistentry{}{Classifier::Classifier}{}{942}{classification}{}
\functionlistentry{}{Classifier::Classifier}{int classes,int dimension}{943}{classification}{}
\functionlistentry{}{Classifier::Classifier}{const Classifier \&c}{944}{classification}{}
\functionlistentry{int}{Classifier::Classify}{const vector\textless {}double\textgreater  \&features}{958}{classification}{}
\functionlistentry{int}{Classifier::Classify}{const Vector \&features}{959}{classification}{}
\functionlistentry{int}{Classifier::Classify}{const vector\textless {}double\textgreater  \&features, vector\textless {}double\textgreater  \&probabilities}{960}{classification}{}
\functionlistentry{int}{Classifier::Classify}{Matrix \&m}{961}{classification}{}
\functionlistentry{int}{Classifier::Classify}{const Matrix \&m,IVector \&cl}{962}{classification}{}
\functionlistentry{int}{Classifier::Finish}{}{953}{classification}{}
\functionlistentry{int}{Classifier::Init}{}{945}{classification}{}
\functionlistentry{int}{Classifier::Init}{int classes,int dimension}{946}{classification}{}
\functionlistentry{int}{Classifier::Read}{const string \&fn}{964}{classification}{}
\functionlistentry{double}{Classifier::Test}{const vector\textless {}ClassSample\textgreater  \&samples}{954}{classification}{}
\functionlistentry{double}{Classifier::Test}{const Matrix \&m}{955}{classification}{}
\functionlistentry{double}{Classifier::Test}{const Matrix \&features,const IVector \&classnr}{956}{classification}{}
\functionlistentry{double}{Classifier::Test}{const Matrix \&m,Matrix \&f}{957}{classification}{}
\functionlistentry{int}{Classifier::Train}{const ClassSample \&sample}{947}{classification}{}
\functionlistentry{int}{Classifier::Train}{int cl,const vector\textless {}double\textgreater  \&feat}{948}{classification}{}
\functionlistentry{int}{Classifier::Train}{int cl,const Vector \&feat}{949}{classification}{}
\functionlistentry{int}{Classifier::Train}{const vector\textless {}ClassSamples\textgreater  \&samples}{950}{classification}{}
\functionlistentry{int}{Classifier::Train}{const Matrix \&m}{951}{classification}{}
\functionlistentry{int}{Classifier::Train}{const Matrix \&features,const IVector \&classnr}{952}{classification}{}
\functionlistentry{int}{Classifier::Write}{const string \&fn}{963}{classification}{}
\functionlistentry{}{ClassifierBayes2::ClassifierBayes2}{}{982}{classification}{}
\functionlistentry{}{ClassifierBayes2::ClassifierBayes2}{int classes,int dimension, double p0,double p1,double c01,double c10}{983}{classification}{}
\functionlistentry{}{ClassifierBayes2::ClassifierBayes2}{const ClassifierBayes2 \&c}{984}{classification}{}
\functionlistentry{int}{ClassifierBayes2::Init}{int classes,int dimension,double p0,double p0,double c01, double c10}{985}{classification}{}
\functionlistentry{}{ClassifierBayes::ClassifierBayes}{}{986}{classification}{}
\functionlistentry{}{ClassifierBayes::ClassifierBayes}{int classes,int dimension, bool rejection=false, int apm=APM\_EQUAL}{987}{classification}{}
\functionlistentry{}{ClassifierBayes::ClassifierBayes}{int classes, const vector\textless {}double\textgreater  \& app, bool rejection}{988}{classification}{}
\functionlistentry{}{ClassifierBayes::ClassifierBayes}{const ClassifierBayes \&c}{989}{classification}{}
\functionlistentry{int}{ClassifierBayes::Init}{int classes,int dimension}{990}{classification}{}
\functionlistentry{}{ClassifierMD::ClassifierMD}{}{969}{classification}{}
\functionlistentry{}{ClassifierMD::ClassifierMD}{int classes,int dimension}{970}{classification}{}
\functionlistentry{}{ClassifierMD::ClassifierMD}{const ClassifierMD \&c}{971}{classification}{}
\functionlistentry{}{ClassifierNearestNeighbor::ClassifierNearestNeighbor}{}{972}{classification}{}
\functionlistentry{}{ClassifierNearestNeighbor::ClassifierNearestNeighbor}{int classes,int dimension,int nNeighbors = 1,bool norm = false}{973}{classification}{}
\functionlistentry{}{ClassifierNearestNeighbor::ClassifierNearestNeighbor}{const ClassifierNearestNeighbor \&c}{974}{classification}{}
\functionlistentry{bool}{ClassifierNearestNeighbor::getConsiderDistances}{}{979}{classification}{}
\functionlistentry{int}{ClassifierNearestNeighbor::getNNeighbors}{}{977}{classification}{}
\functionlistentry{double}{ClassifierNearestNeighbor::getRejectionThreshold}{}{981}{classification}{}
\functionlistentry{void}{ClassifierNearestNeighbor::Init}{int classes,int dimension,int neighbors = 1, bool norm = false}{975}{classification}{}
\functionlistentry{void}{ClassifierNearestNeighbor::setConsiderDistances}{bool considerDistances}{978}{classification}{}
\functionlistentry{void}{ClassifierNearestNeighbor::setNNeighbors}{int k}{976}{classification}{}
\functionlistentry{void}{ClassifierNearestNeighbor::setRejectionThreshold}{double theshold}{980}{classification}{}
\functionlistentry{}{ClassifierNormal::ClassifierNormal}{}{965}{classification}{}
\functionlistentry{}{ClassifierNormal::ClassifierNormal}{int classes,int dimension}{966}{classification}{}
\functionlistentry{void}{ClassifierNormal::doNormalization}{int mode = normalizeCenter $|$ normalizeScaling $|$ normalizeIsotropic}{967}{classification}{}
\functionlistentry{void}{ClassifierNormal::normalize}{vector\textless {}double\textgreater  \&feat}{968}{classification}{}
\functionlistentry{}{ClassSample::ClassSample}{}{938}{classification}{}
\functionlistentry{}{ClassSample::ClassSample}{int c, const vector\textless {}double\textgreater  \& f}{939}{classification}{}
\functionlistentry{double \&}{ClassSample::operator[]}{int i}{940}{classification}{}
\functionlistentry{int}{ClassSample::size}{}{941}{classification}{}
\functionlistentry{void}{Clear}{}{237}{datastructures}{}
\functionlistentry{void}{ClearAlpha}{void}{1432}{genericTools}{}
\functionlistentry{int}{ClearImg}{const Image \&img}{1086}{processing}{}
\functionlistentry{int}{ClearImgD}{ImageD img}{1098}{processing}{}
\functionlistentry{void}{CloseAlpha}{void}{1428}{genericTools}{}
\functionlistentry{double}{ClosestPointLineSeg}{double p[2],double ls0[2],double ls1[2],double pf[2]}{1385}{numeric}{}
\functionlistentry{int}{ClosingImg}{const Image \&src,Image \&dest,int nx=3, int ny=-1}{381}{filter}{}
\functionlistentry{int}{ClosingImg}{const Image \&src,Image \&dest,const IMatrix \&mask}{382}{filter}{}
\functionlistentry{Image}{ColorImage::blueImage}{void}{29}{Images}{}
\functionlistentry{}{ColorImage::ColorImage}{}{15}{Images}{}
\functionlistentry{}{ColorImage::ColorImage}{const ColorImage \&img}{16}{Images}{}
\functionlistentry{}{ColorImage::ColorImage}{const ColorImage \&img,const Window \&w,const string \&title=''''}{32}{Images}{}
\functionlistentry{void}{ColorImage::copy}{const ColorImage \&src}{19}{Images}{}
\functionlistentry{void}{ColorImage::create}{int xsize,int ysize,int maxval,const string \&title=''''}{17}{Images}{}
\functionlistentry{void}{ColorImage::create}{const ColorImage \&img,const string \&title=''''}{18}{Images}{}
\functionlistentry{static ColorImage}{ColorImage::createColorImage}{int sizeX, int sizeY, int maxValue, const std::string \&title = ''''}{20}{Images}{}
\functionlistentry{static ColorImage}{ColorImage::createColorImage}{const ColorImage \&src, bool copy, const std::string \&title = ''''}{21}{Images}{}
\functionlistentry{ColorValue}{ColorImage::getPixel}{int x,int y}{36}{Images}{}
\functionlistentry{ColorValue}{ColorImage::getPixel}{IPoint p}{37}{Images}{}
\functionlistentry{ColorValue}{ColorImage::getPixelUnchecked}{int x,int y}{40}{Images}{}
\functionlistentry{ColorValue}{ColorImage::getPixelUnchecked}{IPoint p}{41}{Images}{}
\functionlistentry{Image}{ColorImage::greenImage}{void}{28}{Images}{}
\functionlistentry{bool}{ColorImage::inside}{const IPoint p}{61}{Images}{}
\functionlistentry{bool}{ColorImage::inside}{int x,int y}{62}{Images}{}
\functionlistentry{bool}{ColorImage::inside}{const Window \&w}{63}{Images}{}
\functionlistentry{bool}{ColorImage::isValid}{}{25}{Images}{}
\functionlistentry{ColorImage}{ColorImage::operator()}{const Window \&w}{33}{Images}{}
\functionlistentry{Image}{ColorImage::redImage}{void}{27}{Images}{}
\functionlistentry{void}{ColorImage::setPixel}{int x,int y,ColorValue cv}{48}{Images}{}
\functionlistentry{void}{ColorImage::setPixel}{IPoint p,ColorValue cv}{49}{Images}{}
\functionlistentry{void}{ColorImage::setPixelUnchecked}{int x,int y,ColorValue cv}{52}{Images}{}
\functionlistentry{void}{ColorImage::setPixelUnchecked}{IPoint p,ColorValue cv}{53}{Images}{}
\functionlistentry{int}{ColorImageToHsi}{const ColorImage \&src, const Image \&hue, const Image \&saturation, const Image \&intensity}{1110}{processing}{}
\functionlistentry{int}{ColorImageToLab}{const ColorImage \&src, const Image \&lImg, const Image \&aImg, const Image \&bImg}{1112}{processing}{}
\functionlistentry{int}{ColorImageToYuv}{const ColorImage \&src, const Image \&y, const Image \&u, const Image \&v}{1114}{processing}{}
\functionlistentry{double}{ColorValue::abs}{}{290}{datastructures}{}
\functionlistentry{double}{ColorValue::abs2}{}{291}{datastructures}{}
\functionlistentry{int}{ColorValue::absL1}{}{292}{datastructures}{}
\functionlistentry{}{ColorValue::ColorValue}{}{287}{datastructures}{}
\functionlistentry{explicit}{ColorValue::ColorValue}{int val}{288}{datastructures}{}
\functionlistentry{}{ColorValue::ColorValue}{int redval,int greenval,int blueval}{289}{datastructures}{}
\functionlistentry{int}{ColorValue::getGray}{}{293}{datastructures}{}
\functionlistentry{ColorValue}{ColorValue::Limited}{int maxValue}{294}{datastructures}{}
\functionlistentry{int}{ComputeHomography}{Matrix \&imagepoints, Matrix \&worldpoints, Trafo \&H}{796}{cameraModel}{}
\functionlistentry{double}{computeMinTree}{const vector$<$Point$>$ \&pointlist,Forest \& tree,double maxlen=0.0}{1306}{graph}{}
\functionlistentry{double}{computeMinTree}{const Matrix \&pointlist,Forest \& tree,double maxlen=0.0}{1307}{graph}{}
\functionlistentry{}{Constant2d::Constant2d}{void}{1035}{functions}{}
\functionlistentry{}{Constant2d::Constant2d}{double a}{1036}{functions}{}
\functionlistentry{}{Constant2d::Constant2d}{const vector\textless {}double\textgreater  \&v}{1037}{functions}{}
\functionlistentry{}{Constant2d::Constant2d}{const Constant2d \&f}{1038}{functions}{}
\functionlistentry{void}{Constant2d::getCoefficient}{double \&a}{1040}{functions}{}
\functionlistentry{void}{Constant2d::setCoefficient}{double a}{1039}{functions}{}
\functionlistentry{}{Constant::Constant}{void}{1000}{functions}{}
\functionlistentry{}{Constant::Constant}{double a}{1001}{functions}{}
\functionlistentry{}{Constant::Constant}{const vector\textless {}double\textgreater  \&v}{1002}{functions}{}
\functionlistentry{}{Constant::Constant}{const Constant \&f}{1003}{functions}{}
\functionlistentry{int}{Constant::getCoefficient}{double \&pa}{1005}{functions}{}
\functionlistentry{int}{Constant::setCoefficient}{double pa}{1004}{functions}{}
\functionlistentry{int}{Contur::Add}{Freeman dir}{400}{conturs}{}
\functionlistentry{int}{Contur::Add}{IPoint p}{401}{conturs}{}
\functionlistentry{int}{Contur::Add}{int x,int y}{402}{conturs}{}
\functionlistentry{int}{Contur::Add}{const Contur \&c}{403}{conturs}{}
\functionlistentry{void}{Contur::Close}{}{405}{conturs}{}
\functionlistentry{}{Contur::Contur}{}{391}{conturs}{}
\functionlistentry{}{Contur::Contur}{const Contur \&c}{392}{conturs}{}
\functionlistentry{}{Contur::Contur}{IPoint p}{393}{conturs}{}
\functionlistentry{}{Contur::Contur}{int x,int y}{394}{conturs}{}
\functionlistentry{int}{Contur::DirCode}{int i}{425}{conturs}{}
\functionlistentry{IPoint}{Contur::End}{}{413}{conturs}{}
\functionlistentry{int}{Contur::EndX}{}{416}{conturs}{}
\functionlistentry{int}{Contur::EndY}{}{417}{conturs}{}
\functionlistentry{Freeman}{Contur::getDirection}{int i}{420}{conturs}{}
\functionlistentry{const std::vector\textless {}Freeman\textgreater {}\&}{Contur::getDirections}{}{421}{conturs}{}
\functionlistentry{int}{Contur::getDirections}{std::vector\textless {}Freeman\textgreater {}\& fc}{422}{conturs}{}
\functionlistentry{int}{Contur::getPairs}{std::vector\textless {}IPoint\textgreater {} \&opl,std::vector\textless {}IPoint\textgreater {} \&upl}{423}{conturs}{}
\functionlistentry{int}{Contur::getPairs}{std::vector\textless {}IPoint\textgreater {} \&pl,std::vector\textless {}Freeman\textgreater {} \&fc}{424}{conturs}{}
\functionlistentry{IPoint}{Contur::getPoint}{int nr}{426}{conturs}{}
\functionlistentry{int}{Contur::getPoint}{int nr,int \&x,int \&y}{427}{conturs}{}
\functionlistentry{void}{Contur::getPoints}{vector<IPoint> \&pl,bool close=false}{428}{conturs}{}
\functionlistentry{int}{Contur::getRect}{int \&xi,int \&yi,int \&xa,int \&ya}{419}{conturs}{}
\functionlistentry{int}{Contur::InvDir}{}{406}{conturs}{}
\functionlistentry{int}{Contur::isClosed}{}{411}{conturs}{}
\functionlistentry{int}{Contur::isHole}{}{418}{conturs}{}
\functionlistentry{int}{Contur::isValid}{}{408}{conturs}{}
\functionlistentry{double}{Contur::Length}{}{410}{conturs}{}
\functionlistentry{int}{Contur::Number}{}{409}{conturs}{}
\functionlistentry{Contur \&}{Contur::operator =}{const Trafo \&}{407}{conturs}{}
\functionlistentry{int}{Contur::Reset}{}{395}{conturs}{}
\functionlistentry{int}{Contur::Reset}{IPoint p}{396}{conturs}{}
\functionlistentry{int}{Contur::Reset}{int x,int y}{397}{conturs}{}
\functionlistentry{int}{Contur::SetStart}{IPoint p}{398}{conturs}{}
\functionlistentry{int}{Contur::SetStart}{int x,int y}{399}{conturs}{}
\functionlistentry{IPoint}{Contur::Start}{}{412}{conturs}{}
\functionlistentry{int}{Contur::StartX}{}{414}{conturs}{}
\functionlistentry{int}{Contur::StartY}{}{415}{conturs}{}
\functionlistentry{}{conturFromPolygon}{const Matrix \&pl,Contur \&c}{463}{conturs}{}
\functionlistentry{int}{ConturList::Add}{const Contur \&c}{456}{conturs}{}
\functionlistentry{}{ConturList::ConturList}{}{453}{conturs}{}
\functionlistentry{}{ConturList::ConturList}{const ConturList\& cl}{454}{conturs}{}
\functionlistentry{int}{ConturList::Del}{int i}{457}{conturs}{}
\functionlistentry{Contur *}{ConturList::GetContur}{int i}{458}{conturs}{}
\functionlistentry{ConturList \&}{ConturList::operator=}{const ConturList\& cl}{455}{conturs}{}
\functionlistentry{IMatrix}{ConturPointlist}{const Contur \&c,int diff=1,bool close=true}{429}{conturs}{}
\functionlistentry{void}{ConvCartesPolar}{double x,double y,double \&rad,double \&arc}{1377}{numeric}{}
\functionlistentry{void}{ConvCartesPolar}{double p[2],double *rad,double *arc}{1378}{numeric}{}
\functionlistentry{RotQuaternion}{convertToRotQuaternion}{Quaternion\& in}{1513}{quaternions}{}
\functionlistentry{RotQuaternion}{convertToRotQuaternion}{Matrix\& in}{1514}{quaternions}{}
\functionlistentry{TrafoDualQuaternion}{convertToTrafoDualQuaternion}{const Matrix\& in}{1549}{quaternions}{}
\functionlistentry{vector$<$Point$>$}{ConvexHull}{const vector$<$Point$>$ \&pl}{284}{datastructures}{}
\functionlistentry{Matrix}{ConvexHull}{const Matrix \&pl}{285}{datastructures}{}
\functionlistentry{Contur}{ConvexHull}{const Contur \&c}{286}{datastructures}{}
\functionlistentry{int}{ConvImgDImg}{ImageD imgs,Image imgd,int modus=ADAPTIVE,int sign=UNSIGNED}{85}{Images}{}
\functionlistentry{int}{ConvImgImgD}{const Image \&imgs,ImageD imgd,int modus=RAW,int sign=UNSIGNED}{86}{Images}{}
\functionlistentry{int}{Convolution}{const Vector \&src1,const Vector \&src2,Vector \&dst}{1214}{signalTrafo}{}
\functionlistentry{int}{ConvolutionFImgD}{ImageD re1,ImageD im1, ImageD re2,ImageD im2,ImageD re3,ImageD im3}{1216}{signalTrafo}{}
\functionlistentry{int}{ConvolutionHImgD}{ImageD im1,ImageD im2,ImageD im3}{1217}{signalTrafo}{}
\functionlistentry{int}{ConvolutionImg}{const Image \&im1,const Image \&im2, Image \&dst,double factor=0.0,int mode=MD\_USE\_BIAS}{1218}{signalTrafo}{}
\functionlistentry{int}{ConvolutionImg}{const Image \&im1,const Image \&im2, ImageD dst, int mode=MD\_USE\_BIAS}{1219}{signalTrafo}{}
\functionlistentry{int}{ConvolutionImgD}{ImageD im1,ImageD im2,ImageD dst,int mode=MD\_USE\_BIAS}{1215}{signalTrafo}{}
\functionlistentry{int}{ConvPointHesse}{double p1[2],double p2[2],double *p,double *phi}{1381}{numeric}{}
\functionlistentry{Vector}{ConvPointHesse}{const Vector \&p1,const Vector \&p2}{1382}{numeric}{}
\functionlistentry{void}{ConvPolarCartes}{double rad,double arc,double \&x,double \&y}{1379}{numeric}{}
\functionlistentry{void}{ConvPolarCartes}{double rad,double arc,double p[2]}{1380}{numeric}{}
\functionlistentry{int}{ConvR3PointHesse}{double p1[3],double p2[3],double p3[3],double *p,double n[3]}{1404}{numeric}{}
\functionlistentry{int}{CopyImg}{const Image \&src,const Image \&dest}{1089}{processing}{}
\functionlistentry{int}{correctShading}{const Image \&img1,const Image \&img2, int ord=2}{1084}{processing}{}
\functionlistentry{int}{correctShading}{const Image \&img1,const Image \&img2, Function2dWithFitting \&fn}{1085}{processing}{}
\functionlistentry{Matrix}{Correlation}{const Statistics \&st}{871}{statistics}{}
\functionlistentry{Matrix}{Covariance}{const Statistics \&st}{870}{statistics}{}
\functionlistentry{static Image}{createImage}{const Image \&src, bool copy, const std::string \&title = ''''}{9}{Images}{}
\functionlistentry{Vector}{Cross}{const Vector \&v1,const Vector \&v2}{254}{datastructures}{}
\functionlistentry{int}{CrossCorrelationFImgD}{ImageD re1,ImageD im1, ImageD re2,ImageD im2,ImageD re3,ImageD im3}{1227}{signalTrafo}{}
\functionlistentry{int}{CrossCorrelationHImgD}{ImageD im1,ImageD im2,ImageD im3}{1228}{signalTrafo}{}
\functionlistentry{int}{CrossCorrelationImgD}{ImageD im1,ImageD im2,ImageD dst}{1226}{signalTrafo}{}
\functionlistentry{double*}{CrossProdVec}{double v1[3],double v2[3],double v3[3]}{1574}{obsolet}{}
\functionlistentry{double}{Cub}{double val}{1357}{numeric}{}
\functionlistentry{double}{CubRoot}{double val}{1358}{numeric}{}
\functionlistentry{int}{Cursor}{int mode,Image img,int x,int y}{95}{Visualisierung}{}
\functionlistentry{int}{cutShortBranches}{Forest \&f,const vector$<$Point$>$ \&pointlist,double minlen}{1309}{graph}{}
\functionlistentry{int}{cutShortBranches}{Forest \&f,const Matrix \&pointlist,double minlen}{1310}{graph}{}

\letterlabel{D}
\letterlabel{D}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}
\letterlabelend{D}
\functionlistentry{double}{Degree}{double arc}{1360}{numeric}{}
\functionlistentry{}{Delaunay::Delaunay}{vector\textless {}Point\textgreater  \&nodesp}{1313}{graph}{}
\functionlistentry{}{Delaunay::Delaunay}{const PolygonalCurve \&curv}{1314}{graph}{}
\functionlistentry{void}{Delaunay::draw}{const Image \&img, int edgeValue = 1, int fillValue = -1, double limit = -1}{1320}{graph}{}
\functionlistentry{void}{Delaunay::getEdges}{vector\textless {}LineSeg\textgreater  \&output, double limit = -1}{1317}{graph}{}
\functionlistentry{void}{Delaunay::getEdgesI}{vector\textless {}vector\textless {}int\textgreater \textgreater  \&output, double limit = -1}{1318}{graph}{}
\functionlistentry{void}{Delaunay::getRegion}{Region \&region, double limit = -1}{1319}{graph}{}
\functionlistentry{void}{Delaunay::getTriangles}{vector\textless {}Triangle\textgreater  \&output, double limit = -1}{1315}{graph}{}
\functionlistentry{void}{Delaunay::getTrianglesI}{vector\textless {}vector\textless {}int\textgreater \textgreater  \&output, double limit = -1}{1316}{graph}{}
\functionlistentry{void}{Delay}{double time}{1456}{genericTools}{}
\functionlistentry{int}{Derive2Func}{FuncD func, int dim,int i,double *x,double h,int mode,double *val}{1412}{numeric}{}
\functionlistentry{int}{DeriveFunc}{FuncD func,int dim,int i,double *x,double h,int mode,double *val}{1411}{numeric}{}
\functionlistentry{LineSeg}{DetectLine}{const vector<Point> \&pointlist}{933}{statistics}{}
\functionlistentry{LineSeg}{DetectLine}{const vector<Point> \&pointlist,int pairs}{934}{statistics}{}
\functionlistentry{LineSeg}{DetectLine}{const Matrix \&pointlist}{935}{statistics}{}
\functionlistentry{LineSeg}{DetectLine}{const Matrix \&pointlist,int pairs}{936}{statistics}{}
\functionlistentry{int}{DetectShift}{Image img1,Image img2, double \&dx,double \&dy,double \&val,double beta=0.1}{1255}{registration}{}
\functionlistentry{int}{DetectTrafo}{Image img1,Image img2,Trafo \&tr, double beta=0.1,int ct=3,int mode=DT\_NEARLY\_SHIFT}{1256}{registration}{}
\functionlistentry{double}{Determinant}{const Matrix \&m}{1121}{matrixAlgebra}{}
\functionlistentry{Segment}{DetermineSegment}{PointList pl, int pa, int pe, int type, Segment sl, int* ma, double* md}{1191}{fitting}{}
\functionlistentry{Contur}{Dijkstra}{const Image \&img,IPoint s,IPoint e}{1311}{graph}{}
\functionlistentry{Contur}{Dijkstra}{const Image \&img,IPoint s,Image \&e}{1312}{graph}{}
\functionlistentry{int}{DilateImg}{const Image \&src,int nx,int ny,Image \&dest}{373}{filter}{}
\functionlistentry{int}{DilateImg}{const Image \&src,Image \&dest,int nx=3, int ny=-1}{374}{filter}{}
\functionlistentry{int}{DilateImg}{const Image \&src,int neighb,int *mask,Image \&dest}{375}{filter}{}
\functionlistentry{int}{DilateImg}{const Image \&src,int nx,int ny,int *mask,Image \&dest}{376}{filter}{}
\functionlistentry{int}{DilateImg}{const Image \&src,const Imatrix \&mask,Image \&dest}{377}{filter}{}
\functionlistentry{int}{DilateImg}{const Image \&src,Image \&dest,const IMatrix \&mask}{378}{filter}{}
\functionlistentry{void}{Directory}{vector$<$string$>$ \&t,const string \&mask,int mode=DIR\_FILE $|$ DIR\_DIR}{1457}{genericTools}{}
\functionlistentry{double}{Distance}{const Histogram \&h1,const Histogram \&h2}{900}{statistics}{}
\functionlistentry{double}{Distance}{double x1,double y1,double x2,double y2}{1374}{numeric}{}
\functionlistentry{double}{Distance}{IPoint p1,IPoint p2}{1375}{numeric}{}
\functionlistentry{double}{Distance}{Point p1,Point p2}{1376}{numeric}{}
\functionlistentry{double}{Distance}{const Point3d \&p1,const Point3d \&p2}{1395}{numeric}{}
\functionlistentry{double}{Distance}{const Point3d \&p,const Line3d \&l}{1396}{numeric}{}
\functionlistentry{double}{Distance}{const Line3d \&l,const Point3d \&p}{1397}{numeric}{}
\functionlistentry{double}{Distance}{const Line3d \&l1,const Line3d \&l2}{1398}{numeric}{}
\functionlistentry{Matrix}{DistanceMatrix}{const Matrix \&feat1, const Matrix \&feat2, int mode=D\_EUKLID}{1242}{features}{}
\functionlistentry{Matrix}{DistanceMatrix}{const Matrix \&feat1, int mode=D\_EUKLID}{1243}{features}{}
\functionlistentry{Matrix}{DistanceMatrix}{const Matrix \&feat1, const Matrix \& feat2, const VectorDistance \&dist}{1244}{features}{}
\functionlistentry{Matrix}{DistanceMatrix}{const Matrix \&feat1, const VectorDistance \&dist}{1245}{features}{}
\functionlistentry{double}{Distortion0::D2}{void}{750}{geoTrafo}{}
\functionlistentry{}{Distortion0::Distortion0}{void}{728}{geoTrafo}{}
\functionlistentry{}{Distortion0::Distortion0}{double x0,double y0,double d2=0.0}{732}{geoTrafo}{}
\functionlistentry{}{Distortion0::Distortion0}{const Matrix \&mark,const Matrix \&orig,Trafo \&tr,const Vector \&ImageCenter}{736}{geoTrafo}{}
\functionlistentry{}{Distortion0::Distortion0}{const Matrix \&mark,const Matrix \&orig,const Vector \&ImageCenter}{737}{geoTrafo}{}
\functionlistentry{}{Distortion0::Distortion0}{const Matrix \&mark,const Matrix \&orig}{738}{geoTrafo}{}
\functionlistentry{double}{Distortion1::D2}{void}{751}{geoTrafo}{}
\functionlistentry{double}{Distortion1::D4}{void}{752}{geoTrafo}{}
\functionlistentry{}{Distortion1::Distortion1}{void}{729}{geoTrafo}{}
\functionlistentry{}{Distortion1::Distortion1}{double x0,double y0,double d2=0.0, double d4=0.0}{733}{geoTrafo}{}
\functionlistentry{}{Distortion1::Distortion1}{const Matrix \&mark,const Matrix \&orig,Trafo \&tr,const Vector \&ImageCenter}{739}{geoTrafo}{}
\functionlistentry{}{Distortion1::Distortion1}{const Matrix \&mark,const Matrix \&orig,const Vector \&ImageCenter}{740}{geoTrafo}{}
\functionlistentry{}{Distortion1::Distortion1}{const Matrix \&mark,const Matrix \&orig}{741}{geoTrafo}{}
\functionlistentry{double}{Distortion2::D2}{void}{753}{geoTrafo}{}
\functionlistentry{double}{Distortion2::D2}{void}{756}{geoTrafo}{}
\functionlistentry{double}{Distortion2::D3}{void}{754}{geoTrafo}{}
\functionlistentry{double}{Distortion2::D4}{void}{755}{geoTrafo}{}
\functionlistentry{double}{Distortion2::D4}{void}{757}{geoTrafo}{}
\functionlistentry{double}{Distortion2::D6}{void}{758}{geoTrafo}{}
\functionlistentry{}{Distortion2::Distortion2}{void}{730}{geoTrafo}{}
\functionlistentry{}{Distortion2::Distortion2}{double x0,double y0,double d2=0.0, double d3=0.0,double d4=0.0}{734}{geoTrafo}{}
\functionlistentry{}{Distortion2::Distortion2}{const Matrix \&mark,const Matrix \&orig,Trafo \&tr,const Vector \&ImageCenter}{742}{geoTrafo}{}
\functionlistentry{}{Distortion2::Distortion2}{const Matrix \&mark,const Matrix \&orig,const Vector \&ImageCenter}{743}{geoTrafo}{}
\functionlistentry{}{Distortion2::Distortion2}{const Matrix \&mark,const Matrix \&orig}{744}{geoTrafo}{}
\functionlistentry{}{Distortion3::Distortion3}{void}{731}{geoTrafo}{}
\functionlistentry{}{Distortion3::Distortion3}{double x0,double y0,double d2=0.0, double d4=0.0,double d6=0.0}{735}{geoTrafo}{}
\functionlistentry{}{Distortion3::Distortion3}{const Matrix \&mark,const Matrix \&orig,Trafo \&tr,const Vector \&ImageCenter}{745}{geoTrafo}{}
\functionlistentry{}{Distortion3::Distortion3}{const Matrix \&mark,const Matrix \&orig,const Vector \&ImageCenter}{746}{geoTrafo}{}
\functionlistentry{}{Distortion3::Distortion3}{const Matrix \&mark,const Matrix \&orig}{747}{geoTrafo}{}
\functionlistentry{int}{Distortion::Distort}{double \&x,double \&y}{759}{geoTrafo}{}
\functionlistentry{int}{Distortion::Distort}{double x,double y,double \&xd,double \&yd}{760}{geoTrafo}{}
\functionlistentry{Vector}{Distortion::Distort}{const Vector \&p}{761}{geoTrafo}{}
\functionlistentry{Point}{Distortion::Distort}{const Point \&p}{762}{geoTrafo}{}
\functionlistentry{int}{Distortion::Rect}{double \&x,double \&y}{763}{geoTrafo}{}
\functionlistentry{int}{Distortion::Rect}{double x,double y,double \&xr,double \&yr}{764}{geoTrafo}{}
\functionlistentry{Vector}{Distortion::Rect}{const Vector \&p}{765}{geoTrafo}{}
\functionlistentry{Point}{Distortion::Rect}{const Point \&p}{766}{geoTrafo}{}
\functionlistentry{Image}{Distortion::RectImg}{Image source,int mode=DEFAULT}{767}{geoTrafo}{}
\functionlistentry{Image}{Distortion::RectImg}{Image source,Image dest,int mode=DEFAULT}{768}{geoTrafo}{}
\functionlistentry{double}{Distortion::X0}{void}{748}{geoTrafo}{}
\functionlistentry{double}{Distortion::Y0}{void}{749}{geoTrafo}{}
\functionlistentry{double}{DistPointCircle}{double p[2],double par[3]}{1386}{numeric}{}
\functionlistentry{double}{DistPointEllipse}{double p[2],double par[5],double koord[2]}{1387}{numeric}{}
\functionlistentry{double}{DistPointLine}{double r[2],double p,double phi}{1384}{numeric}{}
\functionlistentry{double}{DistR3PointLine}{double p[3],double p0[3],double dir[3]}{1405}{numeric}{}
\functionlistentry{double}{DistR3PointPlane}{double p[3],double r,double n[3]}{1406}{numeric}{}
\functionlistentry{int}{DoBImg}{Image src,Image dest,int n1,int n2,int mode=SMD\_SHIFT}{345}{filter}{}
\functionlistentry{double}{Double}{const string \&s}{1421}{genericTools}{}
\functionlistentry{int}{Draw}{const Circle \&c,Image \&img,int val,int fval=-1}{623}{geoObject}{}
\functionlistentry{int}{Draw}{const CircleSeg \&c,Image \&img,int val,int fval=-1}{624}{geoObject}{}
\functionlistentry{int}{Draw}{const Ellipse \&c,Image \&img,int val,int fval=-1}{625}{geoObject}{}
\functionlistentry{int}{Draw}{const EllipseSeg \&c,Image \&img,int val,int fval=-1}{626}{geoObject}{}
\functionlistentry{int}{Draw}{const LineSeg \&c,Image \&img,int val}{627}{geoObject}{}
\functionlistentry{int}{Draw}{const Polygon \&c,Image \&img,int val,int fval=-1}{628}{geoObject}{}
\functionlistentry{int}{DrawCircle}{double par[3],int val1,int val2,int mode,Image img}{1336}{graphics}{}
\functionlistentry{int}{DrawCircleSegment}{double par[5],int val1,int val2,int mode,Image img}{1339}{graphics}{}
\functionlistentry{int}{DrawEllipse}{double par[5],int val1,int val2,int mode,Image img}{1337}{graphics}{}
\functionlistentry{int}{DrawEllipseSegment}{double *par[7],int val1,int val2,int mode,Image img}{1340}{graphics}{}
\functionlistentry{Image}{DrawPattern}{int dimx, int dimy}{801}{cameraModel}{}
\functionlistentry{void}{DrawPolygon}{PointList pl,int val,Image img}{1341}{graphics}{}
\functionlistentry{void}{DrawSuperEllipse}{double c, double tr[3][3], int val,Image img}{1338}{graphics}{}
\functionlistentry{}{DualQuaternion::DualQuaternion}{}{1524}{quaternions}{}
\functionlistentry{}{DualQuaternion::DualQuaternion}{Quaternion\& real, Quaternion\& dual}{1525}{quaternions}{}
\functionlistentry{}{DualQuaternion::DualQuaternion}{const DualQuaternion\& b}{1526}{quaternions}{}
\functionlistentry{DualQuaternion}{DualQuaternion::getConjugate}{}{1532}{quaternions}{}
\functionlistentry{Quaternion}{DualQuaternion::getDual}{}{1528}{quaternions}{}
\functionlistentry{DualQuaternion}{DualQuaternion::getInverse}{}{1534}{quaternions}{}
\functionlistentry{DualQuaternion}{DualQuaternion::getNegate}{}{1531}{quaternions}{}
\functionlistentry{DualQuaternion}{DualQuaternion::getQuasiNorm}{}{1535}{quaternions}{}
\functionlistentry{Quaternion}{DualQuaternion::getReal}{}{1527}{quaternions}{}
\functionlistentry{DualQuaternion}{DualQuaternion::getTilde}{}{1533}{quaternions}{}
\functionlistentry{bool}{DualQuaternion::isUnitDualQuaternion}{}{1536}{quaternions}{}
\functionlistentry{void}{DualQuaternion::setDual}{Quaternion\& dual}{1530}{quaternions}{}
\functionlistentry{void}{DualQuaternion::setReal}{Quaternion\& real}{1529}{quaternions}{}

\letterlabel{E}
\letterlabel{E}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}
\letterlabelend{E}
\functionlistentry{void}{edge}{int i,LineSeg \&l}{601}{geoObject}{}
\functionlistentry{void}{edge}{int i,LineSeg \&l}{620}{geoObject}{}
\functionlistentry{int}{EigenachsenSpektrumQFT}{QuatMatrix\& input, Image\& r, Image\& g, Image\& b, int mode=CENTER}{1554}{quaternions}{}
\functionlistentry{int}{Eigenvalue}{const Matrix \&a,Vector \&eval,Matrix \&evect}{1131}{matrixAlgebra}{}
\functionlistentry{int}{Eigenvalue}{const Matrix \&a,Matrix \&eval,Matrix \&evect}{1132}{matrixAlgebra}{}
\functionlistentry{int}{Eigenvalue}{double a,double b,double c, double \&lambda1,double \&lambda2,Point \&eigen1,Point \&eigen2}{1133}{matrixAlgebra}{}
\functionlistentry{int}{EigenwinkelSpektrumQFT}{QuatMatrix\& input, Image\& r, Image\& g, Image\& b, int mode=CENTER}{1553}{quaternions}{}
\functionlistentry{}{Ellipse::Ellipse}{}{532}{geoObject}{}
\functionlistentry{}{Ellipse::Ellipse}{const Ellipse \&c}{533}{geoObject}{}
\functionlistentry{}{Ellipse::Ellipse}{double xm,double ym,double r1,double r2,double phi}{534}{geoObject}{}
\functionlistentry{explicit}{Ellipse::Ellipse}{const Vector \&c}{535}{geoObject}{}
\functionlistentry{explicit}{Ellipse::Ellipse}{const double d[]}{536}{geoObject}{}
\functionlistentry{double}{Ellipse::getR1}{}{537}{geoObject}{}
\functionlistentry{double}{Ellipse::getR2}{}{539}{geoObject}{}
\functionlistentry{void}{Ellipse::setR1}{double val}{538}{geoObject}{}
\functionlistentry{void}{Ellipse::setR2}{double val}{540}{geoObject}{}
\functionlistentry{Contur}{EllipseContur}{double par[5]}{1344}{graphics}{}
\functionlistentry{}{EllipseSeg::EllipseSeg}{void}{541}{geoObject}{}
\functionlistentry{}{EllipseSeg::EllipseSeg}{const EllipseSeg \&c}{542}{geoObject}{}
\functionlistentry{}{EllipseSeg::EllipseSeg}{double xm,double ym,double r1,double r2,double phi,double phi1,double phi2}{543}{geoObject}{}
\functionlistentry{explicit}{EllipseSeg::EllipseSeg}{const Vector \&c}{544}{geoObject}{}
\functionlistentry{explicit}{EllipseSeg::EllipseSeg}{const double d[]}{545}{geoObject}{}
\functionlistentry{double}{EllipseSeg::Phi1}{void}{546}{geoObject}{}
\functionlistentry{double}{EllipseSeg::Phi2}{void}{548}{geoObject}{}
\functionlistentry{void}{EllipseSeg::setPhi1}{double val}{547}{geoObject}{}
\functionlistentry{void}{EllipseSeg::setPhi2}{double val}{549}{geoObject}{}
\functionlistentry{Contur}{EllipseSegmentContur}{double par[7]}{1346}{graphics}{}
\functionlistentry{int}{EquationSys}{MatrixStruct A,double *b,double *x}{1128}{matrixAlgebra}{}
\functionlistentry{int}{ErodeImg}{const Image \&src,int nx,int ny,Image \&dest}{367}{filter}{}
\functionlistentry{int}{ErodeImg}{const Image \&src,Image \&dest,int nx=3, int ny=-1}{368}{filter}{}
\functionlistentry{int}{ErodeImg}{const Image \&src,int neighb,int *mask,Image \&dest}{369}{filter}{}
\functionlistentry{int}{ErodeImg}{const Image \&src,int nx,int ny,int *mask,Image \&dest}{370}{filter}{}
\functionlistentry{int}{ErodeImg}{const Image \&src,const Imatrix \&mask,Image \&dest}{371}{filter}{}
\functionlistentry{int}{ErodeImg}{const Image \&src,Image \&dest,const IMatrix \&mask}{372}{filter}{}
\functionlistentry{TrafoDualQuaternion}{estimateTransformation}{const Matrix\& orig,const Matrix\& trans}{1550}{quaternions}{}

\letterlabel{F}
\letterlabel{F}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}
\letterlabelend{F}
\functionlistentry{int}{FeatureContur}{Contur c,double \&length,double \&area,double \&form,double \&conv}{430}{conturs}{}
\functionlistentry{int}{FeatureQuadrFunc}{double koeff[6],double par[5],int *type}{1392}{numeric}{}
\functionlistentry{int}{FillRegion}{Contur c,int val,Image img}{1348}{graphics}{}
\functionlistentry{int}{FindMax}{const Image \&img, int \&x, int \&y}{1072}{processing}{}
\functionlistentry{int}{FindMax}{const Image \&img, IPoint \&p}{1073}{processing}{}
\functionlistentry{int}{FindMax}{const Image \&img}{1074}{processing}{}
\functionlistentry{int}{FindMin}{const Image \&img, int \&x, int \&y}{1069}{processing}{}
\functionlistentry{int}{FindMin}{const Image \&img, IPoint \&p}{1070}{processing}{}
\functionlistentry{int}{FindMin}{const Image \&img}{1071}{processing}{}
\functionlistentry{int}{FitAffineTrans}{PointList pl1,PointList pl2,double tr[3][3]}{1600}{obsolet}{}
\functionlistentry{int}{FitCircle}{const Moments \&m,double \&x0,double \&y0,double \&radius}{854}{moments}{}
\functionlistentry{Circle}{FitCircle}{const Moments \&m}{855}{moments}{}
\functionlistentry{Circle}{FitCircle}{const vector\textless {}Point\textgreater  \&pl}{1171}{fitting}{}
\functionlistentry{Circle}{FitCircle}{const vector\textless {}Point\textgreater  \&pl,const vector\textless {}double\textgreater  \&weight}{1172}{fitting}{}
\functionlistentry{Circle}{FitCircle}{const vector\textless {}Point\textgreater  \&pl,int step}{1173}{fitting}{}
\functionlistentry{Circle}{FitCircle}{const vector\textless {}Point\textgreater  \&pl,vector\textless {}double\textgreater  \&weight,int step}{1174}{fitting}{}
\functionlistentry{Circle}{FitCircle}{const Matrix \&pl,int step=0}{1175}{fitting}{}
\functionlistentry{int}{FitCircle}{const Matrix \&pl,double \&xm,double \&ym,double \&rad,int step=0}{1176}{fitting}{}
\functionlistentry{int}{FitCircle}{const Matrix \&pl,double par[3],int step=0}{1177}{fitting}{}
\functionlistentry{int}{FitCircle}{PointList pl,int a1,int a2,int step,double par[3],double *mdist,int *madr}{1178}{fitting}{}
\functionlistentry{int}{FitCircleLinOpt}{PointList pl,int a1,int a2,int step,double par[3],double limit=1000000}{1179}{fitting}{}
\functionlistentry{int}{FitCircleMoments}{double moment[15],double \&x0,double \&y0,double \&radius}{1638}{obsolet}{}
\functionlistentry{Segment}{FitCircleSegment}{PointList pl,int a1,int a2,int step,double *mdist,int *madr}{1185}{fitting}{}
\functionlistentry{int}{FitCircularSegmentMoments}{double moment[15],double circle\_par[3],double line\_start[2],double line\_end[2]}{1639}{obsolet}{}
\functionlistentry{Ellipse}{FitEllipse}{const Moments \&m}{856}{moments}{}
\functionlistentry{Ellipse}{FitEllipse}{const Matrix \&pl,int step=0,int mode=1}{1180}{fitting}{}
\functionlistentry{int}{FitEllipse}{const Matrix \&pl,double par[5],int step=0,int mode=1}{1181}{fitting}{}
\functionlistentry{int}{FitEllipse}{PointList pl,int a1,int a2,int step,double par[5],double *mdist,int *madr,int mode=1}{1182}{fitting}{}
\functionlistentry{int}{FitEllipseLinOpt}{PointList pl,int a1,int a2,int step,double par[5],double limit}{1183}{fitting}{}
\functionlistentry{int}{FitEllipseMoments}{double moment[15],double ell\_par[5]}{1640}{obsolet}{}
\functionlistentry{Segment}{FitEllipseSegment}{PointList pl,int a1,int a2,int step,double *mdist,int *madr}{1186}{fitting}{}
\functionlistentry{int}{FitEllipticalSegmentMoments}{double moment[15],double ell\_par[5],double line\_start[2],double line\_end[2]}{1641}{obsolet}{}
\functionlistentry{Matrix}{FitEquilateralTriangle}{const Moments \&m}{841}{moments}{}
\functionlistentry{Matrix}{FitEquilateralTriangle}{const Moments \&m,double \&guetemass}{842}{moments}{}
\functionlistentry{double}{FitGradLine}{Image img, double lp[2][2],int dist, double *p, double *phi}{1195}{fitting}{}
\functionlistentry{double}{FitGrayLine}{Image img, double lp[2][2],int dist, double *p, double *phi}{1194}{fitting}{}
\functionlistentry{Matrix}{FitIsoscelesTriangle}{const Moments \&m}{843}{moments}{}
\functionlistentry{Matrix}{FitIsoscelesTriangle}{const Moments \&m,double \&guetemass}{844}{moments}{}
\functionlistentry{LineSeg}{FitLine}{const vector\textless {}Point\textgreater  \&pl}{1162}{fitting}{}
\functionlistentry{LineSeg}{FitLine}{const vector\textless {}Point\textgreater  \&pl,int step}{1163}{fitting}{}
\functionlistentry{LineSeg}{FitLine}{const vector\textless {}Point\textgreater  \&pl,const vector\textless {}double\textgreater  \&weight}{1164}{fitting}{}
\functionlistentry{LineSeg}{FitLine}{const vector\textless {}Point\textgreater  \&pl,vector\textless {}double\textgreater  \&weight,int step}{1165}{fitting}{}
\functionlistentry{LineSeg}{FitLine}{const Matrix \&pl,int step=0}{1166}{fitting}{}
\functionlistentry{int}{FitLine}{const Matrix \&pl,double \&r,double \&phi,int step=0}{1167}{fitting}{}
\functionlistentry{int}{FitLine}{const Matrix \&m,double par[2],int step=0}{1168}{fitting}{}
\functionlistentry{int}{FitLine}{PointList pl,int a1,int a2,int step,double par[2],double *mdist,int *madr}{1169}{fitting}{}
\functionlistentry{int}{FitLineLinOpt}{PointList pl,int a1,int a2,int step,double par[2],double limit=1000000}{1170}{fitting}{}
\functionlistentry{Segment}{FitLineSegment}{PointList pl,int a1,int a2,int step,double *mdist,int *madr}{1184}{fitting}{}
\functionlistentry{Matrix}{FitParallelogram}{const Moments \&m}{849}{moments}{}
\functionlistentry{Matrix}{FitParallelogram}{const Moments \&m,double \& guetemass}{850}{moments}{}
\functionlistentry{int}{FitParallelogramMoments}{double moment[15],double corner[4][2]}{1635}{obsolet}{}
\functionlistentry{int}{FitParallelogramMoments}{double moment[15],double corner[4][2], double \& guetemass}{1636}{obsolet}{}
\functionlistentry{Matrix}{FitPolygon}{const Moments \&m,const Matrix \&pl}{852}{moments}{}
\functionlistentry{Matrix}{FitPolygon}{const Moments \&m,const Matrix \&pl,double \&guetemass}{853}{moments}{}
\functionlistentry{Matrix}{FitPolygonContur}{const Matrix \&pl, const Contur \&c,int step=0}{283}{datastructures}{}
\functionlistentry{PointList}{FitPolygonContur}{Contur c,int mlng,double mdist}{1188}{fitting}{}
\functionlistentry{PointList}{FitPolygonPointList}{PointList pl,int closed,int mlng,double mdist}{1193}{fitting}{}
\functionlistentry{int}{FitProjectiveTrans}{PointList pl1,PointList pl2,double tr[3][3]}{1601}{obsolet}{}
\functionlistentry{Matrix}{FitQuadrangle}{const Moments \&m}{851}{moments}{}
\functionlistentry{int}{FitQuadrangleMoments}{double moment[15],double corner[4][2]}{1637}{obsolet}{}
\functionlistentry{Matrix}{FitRectangle}{const Moments \&m}{847}{moments}{}
\functionlistentry{Matrix}{FitRectangle}{const Moments \&m,double \&guetemass}{848}{moments}{}
\functionlistentry{int}{FitRectangleMoments}{double moment[15],double corner[4][2]}{1634}{obsolet}{}
\functionlistentry{Matrix}{FitSquare}{const Moments \&m}{845}{moments}{}
\functionlistentry{Matrix}{FitSquare}{const Moments \&m,double \& guetemass}{846}{moments}{}
\functionlistentry{int}{FitSuperEllipseMoments}{double moment[15],double \&c1,double \&f1,double tr1[3][3],double \&c2,double \&f2,double tr2[3][3]}{1642}{obsolet}{}
\functionlistentry{Matrix}{FitTriangle}{const Moments \&m}{840}{moments}{}
\functionlistentry{int}{FitTriangleMoments}{double moment[15],double corner[3][2]}{1633}{obsolet}{}
\functionlistentry{double}{FMod}{double val,double mod}{1369}{numeric}{}
\functionlistentry{int}{Forest::Depth}{int x}{1299}{graph}{}
\functionlistentry{int}{Forest::Father}{int x}{1297}{graph}{}
\functionlistentry{}{Forest::Forest}{int n=0}{1287}{graph}{}
\functionlistentry{int}{Forest::getNeighborCount}{int x}{1292}{graph}{}
\functionlistentry{int}{Forest::getRefCount}{int x}{1291}{graph}{}
\functionlistentry{bool}{Forest::isLeaf}{int x}{1295}{graph}{}
\functionlistentry{bool}{Forest::isRoot}{int x}{1294}{graph}{}
\functionlistentry{void}{Forest::makeRoot}{int x}{1296}{graph}{}
\functionlistentry{int}{Forest::nTree}{bool ignoreZeroLengthTrees=false}{1290}{graph}{}
\functionlistentry{int}{Forest::Reset}{int n}{1288}{graph}{}
\functionlistentry{int}{Forest::Root}{int x}{1298}{graph}{}
\functionlistentry{void}{Forest::setFather}{int x,int f=Forest::rootval}{1293}{graph}{}
\functionlistentry{int}{Forest::Size}{}{1289}{graph}{}
\functionlistentry{int}{Fourier}{const Vector \&re1,const Vector \&im1,int mode, Vector \&re2,Vector \&im2}{1197}{signalTrafo}{}
\functionlistentry{int}{Fourier}{Vector \&re,Vector \&im,int mode=NORMAL}{1198}{signalTrafo}{}
\functionlistentry{int}{Fourier}{const Matrix \&src,int mode,Matrix \&dst}{1199}{signalTrafo}{}
\functionlistentry{int}{Fourier}{Matrix \&m,int mode=NORMAL}{1200}{signalTrafo}{}
\functionlistentry{void}{FourierImgD}{ImageD re1,ImageD im1,int mode,ImageD re2,ImageD im2,int dir=XY}{1203}{signalTrafo}{}
\functionlistentry{int}{FourierMPImgD}{ImageD mag,ImageD phase,ImageD re,ImageD im}{1211}{signalTrafo}{}
\functionlistentry{int}{FreeImg}{Image \&img}{12}{Images}{}
\functionlistentry{int}{FreeImg}{ColorImage \&img}{24}{Images}{}
\functionlistentry{int}{FreeImgD}{ImageD img}{87}{Images}{}
\functionlistentry{}{Freeman::Freeman}{}{464}{conturs}{}
\functionlistentry{}{Freeman::Freeman}{int dir}{465}{conturs}{}
\functionlistentry{}{Freeman::Freeman}{const Freeman \&sec}{466}{conturs}{}
\functionlistentry{int}{Freeman::Int}{}{467}{conturs}{}
\functionlistentry{void}{Freeman::move}{int x,int y,int \&xn,int \&yn}{468}{conturs}{}
\functionlistentry{void}{Freeman::move}{int \&x,int \&y}{469}{conturs}{}
\functionlistentry{void}{Freeman::move}{IPoint p1,IPoint \&p2}{470}{conturs}{}
\functionlistentry{void}{Freeman::move}{IPoint \&p}{471}{conturs}{}
\functionlistentry{IPoint}{Freeman::step}{IPoint \&p}{472}{conturs}{}
\functionlistentry{int}{FreeMatrix}{MatrixStruct mat}{1587}{obsolet}{}
\functionlistentry{}{FreePeakList}{PeakList pl}{1263}{registration}{}
\functionlistentry{double}{Func2d::operator()}{double x, double y}{1033}{functions}{}
\functionlistentry{double}{Func2d::operator()}{Point p}{1034}{functions}{}
\functionlistentry{void}{Function2d::getCoefficient}{vector\textless {}double\textgreater  \&c}{1024}{functions}{}
\functionlistentry{double}{Function2d::operator()}{double x,doubel y}{1022}{functions}{}
\functionlistentry{double}{Function2d::operator()}{Point p}{1023}{functions}{}
\functionlistentry{int}{Function2d::setCoefficient}{const vector\textless {}double\textgreater  \&para,int idx=0}{1025}{functions}{}
\functionlistentry{}{Function2dDistortion::Function2dDistortion}{Function2d \&funcp, Distortion \&tr}{1062}{functions}{}
\functionlistentry{}{Function2dModifier::Function2dModifier}{Function2d \&funcp}{1057}{functions}{}
\functionlistentry{}{Function2dParameterShift::Function2dParameterShift}{Function2d \&funcp, double sx, double sy}{1058}{functions}{}
\functionlistentry{}{Function2dParameterTransform::Function2dParameterTransform}{Function2d \&funcp, const Trafo \&tr}{1059}{functions}{}
\functionlistentry{Trafo \&}{Function2dParameterTransform::Tr}{}{1060}{functions}{}
\functionlistentry{const Trafo \&}{Function2dParameterTransform::Tr}{}{1061}{functions}{}
\functionlistentry{}{Function2dValueTransform::Function2dValueTransform}{Function2d \&funcp, double a1, double a0}{1063}{functions}{}
\functionlistentry{int}{Function2dWithFitting::Fit}{const Matrix \&m}{1030}{functions}{}
\functionlistentry{int}{Function2dWithFitting::Fit}{Image img}{1031}{functions}{}
\functionlistentry{int}{Function2dWithFitting::Fit}{ImageD img}{1032}{functions}{}
\functionlistentry{int}{Function2dWithFitting::FitFinish}{}{1029}{functions}{}
\functionlistentry{int}{Function2dWithFitting::FitInit}{}{1026}{functions}{}
\functionlistentry{int}{Function2dWithFitting::FitVal}{double x, double y, double g, double w=1.0}{1027}{functions}{}
\functionlistentry{int}{Function2dWithFitting::FitVal}{const Point \&p, double g, double w=1.0}{1028}{functions}{}
\functionlistentry{void}{Function::getCoefficient}{vector\textless {}double\textgreater  \&c}{993}{functions}{}
\functionlistentry{double}{Function::operator()}{double x}{992}{functions}{}
\functionlistentry{int}{Function::setCoefficient}{const vector\textless {}double\textgreater  \&para,int idx=0}{994}{functions}{}
\functionlistentry{int}{FunctionWithFitting::Fit}{const Matrix \&m}{998}{functions}{}
\functionlistentry{int}{FunctionWithFitting::FitFinish}{}{997}{functions}{}
\functionlistentry{void}{FunctionWithFitting::FitInit}{void}{995}{functions}{}
\functionlistentry{void}{FunctionWithFitting::FitValue}{double x, double g, double w=1.0}{996}{functions}{}
\functionlistentry{double}{FunctionWithFitting::operator()}{double x}{999}{functions}{}

\letterlabel{G}
\letterlabel{G}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}
\letterlabelend{G}
\functionlistentry{double}{GammaFunction}{double x}{1373}{numeric}{}
\functionlistentry{void}{Gaussfit::Finish}{}{1157}{fitting}{}
\functionlistentry{void}{GaussFit::Fit}{const Matrix \&xn,const Vector \&yn}{1158}{fitting}{}
\functionlistentry{}{GaussFit::GaussFit}{int n=0}{1153}{fitting}{}
\functionlistentry{void}{GaussFit::getResult}{Vector \&v}{1159}{fitting}{}
\functionlistentry{void}{GaussFit::getResult}{vector\textless {}double\textgreater  \&v}{1160}{fitting}{}
\functionlistentry{void}{GaussFit::Init}{int n=0}{1154}{fitting}{}
\functionlistentry{void}{GaussFit::Value}{const Vector \&x,double y,double w=1.0}{1155}{fitting}{}
\functionlistentry{void}{GaussFit::Value}{vector\textless {}double\textgreater  \&x,double y,double w=1.0}{1156}{fitting}{}
\functionlistentry{double}{GaussFit::Variance}{}{1161}{fitting}{}
\functionlistentry{int}{GaussImg}{const Image \&src,Image \&dest,int neighb,double sigma}{352}{filter}{}
\functionlistentry{int}{GaussImg}{const Image \&src,ImageD dest,int neighb,double sigma}{353}{filter}{}
\functionlistentry{int}{GaussImg}{ImageD src,ImageD dest,int neighb,double sigma}{354}{filter}{}
\functionlistentry{double}{GaussRandom}{double sigma}{862}{statistics}{}
\functionlistentry{double}{GeoObject3d::Distance}{double dx,double dy,double dz}{646}{geoObject3d}{}
\functionlistentry{double}{GeoObject3d::Distance}{const Vector3d \&ob}{647}{geoObject3d}{}
\functionlistentry{}{GeoObject3d::GeoObject3d}{void}{630}{geoObject3d}{}
\functionlistentry{}{GeoObject3d::GeoObject3d}{const GeoObject3d \&p}{631}{geoObject3d}{}
\functionlistentry{}{GeoObject3d::GeoObject3d}{const Vector3d \&p}{632}{geoObject3d}{}
\functionlistentry{}{GeoObject3d::GeoObject3d}{double xp,double yp,double zp}{633}{geoObject3d}{}
\functionlistentry{explicit}{GeoObject3d::GeoObject3d}{const Vector \&v}{634}{geoObject3d}{}
\functionlistentry{explicit}{GeoObject3d::GeoObject3d}{double p[]}{635}{geoObject3d}{}
\functionlistentry{Vector3d \&}{GeoObject3d::Pos}{}{643}{geoObject3d}{}
\functionlistentry{void}{GeoObject3d::set}{const Vector \&v}{642}{geoObject3d}{}
\functionlistentry{void}{GeoObject3d::setX}{double x}{639}{geoObject3d}{}
\functionlistentry{void}{GeoObject3d::setY}{double y}{640}{geoObject3d}{}
\functionlistentry{void}{GeoObject3d::setZ}{double z}{641}{geoObject3d}{}
\functionlistentry{void}{GeoObject3d::Shift}{double dx,double dy,double dz}{644}{geoObject3d}{}
\functionlistentry{void}{GeoObject3d::Shift}{const Vector3d \&v}{645}{geoObject3d}{}
\functionlistentry{double}{GeoObject3d::Volume}{}{648}{geoObject3d}{}
\functionlistentry{double}{GeoObject3d::X}{void}{636}{geoObject3d}{}
\functionlistentry{double}{GeoObject3d::Y}{void}{637}{geoObject3d}{}
\functionlistentry{double}{GeoObject3d::Z}{void}{638}{geoObject3d}{}
\functionlistentry{double}{GeoObject::Distance}{double x,double y}{507}{geoObject}{}
\functionlistentry{double}{GeoObject::Distance}{IPoint p}{508}{geoObject}{}
\functionlistentry{double}{GeoObject::Distance}{Point p}{509}{geoObject}{}
\functionlistentry{double}{GeoObject::Distance}{const GeoObject \&obj}{510}{geoObject}{}
\functionlistentry{}{GeoObject::GeoObject}{}{497}{geoObject}{}
\functionlistentry{}{GeoObject::GeoObject}{const GeoObject \&c}{498}{geoObject}{}
\functionlistentry{}{GeoObject::GeoObject}{double xm,double ym}{499}{geoObject}{}
\functionlistentry{explicit}{GeoObject::GeoObject}{Point m}{500}{geoObject}{}
\functionlistentry{explicit}{GeoObject::GeoObject}{IPoint m}{501}{geoObject}{}
\functionlistentry{explicit}{GeoObject::GeoObject}{const Vector \&v}{502}{geoObject}{}
\functionlistentry{Point}{GeoObject::getPos}{}{503}{geoObject}{}
\functionlistentry{bool}{GeoObject::Inside}{double xp,double yp}{511}{geoObject}{}
\functionlistentry{bool}{GeoObject::Inside}{IPoint p}{512}{geoObject}{}
\functionlistentry{bool}{GeoObject::Inside}{Point p}{513}{geoObject}{}
\functionlistentry{void}{GeoObject::setPos}{Point x}{504}{geoObject}{}
\functionlistentry{void}{GeoObject::Shift}{double dx,double dy}{505}{geoObject}{}
\functionlistentry{void}{GeoObject::Shift}{Point p}{506}{geoObject}{}
\functionlistentry{void}{GetAlphaCursor}{int *x,int *y}{1434}{genericTools}{}
\functionlistentry{int}{GetChar}{void}{1440}{genericTools}{}
\functionlistentry{int}{getClosestCorner}{Point p}{605}{geoObject}{}
\functionlistentry{int}{getClosestEdge}{Point p}{606}{geoObject}{}
\functionlistentry{Contur}{GetContur}{int ps[2],int (*cls)(int,int,void*),void *par,int lng}{442}{conturs}{}
\functionlistentry{int}{GetError}{void}{1561}{errorHandling}{}
\functionlistentry{int}{GetGrayLimits}{const Image \&img,int \&min,int \&max, int mode=GV\_QUANTILE, double quantile = 0.01}{1075}{processing}{}
\functionlistentry{int}{GetGrayLimits}{const Hist \& h, int\& min, int\& max, int mode=GV\_QUANTILE, double quantile = 0.01 }{1076}{processing}{}
\functionlistentry{double}{GetInterpolVal}{Image img,double x,double y}{69}{Images}{}
\functionlistentry{bool}{GetInterpolVal}{Image img,double x,double y,double \&val}{70}{Images}{}
\functionlistentry{int}{GetKey}{void}{1441}{genericTools}{}
\functionlistentry{MatrixStruct}{GetStatisticCor}{Statistic st,MatrixStruct cor}{1611}{obsolet}{}
\functionlistentry{MatrixStruct}{GetStatisticCov}{Statistic st,MatrixStruct cov}{1610}{obsolet}{}
\functionlistentry{int}{GetStatisticDim}{Statistic st,int *dim}{1607}{obsolet}{}
\functionlistentry{int}{GetStatisticMean}{Statistic st,double *mean}{1609}{obsolet}{}
\functionlistentry{int}{GetStatisticWeight}{Statistic st,double *sweight}{1608}{obsolet}{}
\functionlistentry{int}{GetVal}{const Image \&img,int x,int y}{65}{Images}{}
\functionlistentry{int}{GetVal}{const Image \&img,double x,double y,mode=DEFAULT}{66}{Images}{}
\functionlistentry{int}{GetVal}{const Image img,const IPoint \&p}{68}{Images}{}
\functionlistentry{double}{GetValD}{ImageD img,int x,int y}{81}{Images}{}
\functionlistentry{double}{GetValue}{ImageD img,IPoint p}{83}{Images}{}
\functionlistentry{int}{GradDirImg}{const Image \&src,Image \&dest}{359}{filter}{}
\functionlistentry{int}{GradImg}{const Image \&src,int norm,Image \&dest}{358}{filter}{}
\functionlistentry{int}{GradThreshold}{Image img}{445}{conturs}{}
\functionlistentry{int}{GradXImg}{Image src,int norm,Image dest}{346}{filter}{}
\functionlistentry{int}{GradYImg}{Image src,int norm,Image dest}{347}{filter}{}
\functionlistentry{void}{GraphIter}{Image Original, Image WSImg, Image \&GrwImg, int Threshold}{1147}{segmentation}{}
\functionlistentry{int}{GrayNormalize}{const Image \&src,const Image \& dest, int mode=GV\_QUANTILE, double quantile = 0.01}{1081}{processing}{}
\functionlistentry{int}{GrayNormalize}{const Image \&src, int mode=GV\_QUANTILE, double quantile = 0.01}{1082}{processing}{}
\functionlistentry{int}{GrayTransform}{const Image \&src, const Image \&dest, double a1, double a0}{1077}{processing}{}
\functionlistentry{int}{GrayTransform}{const Image \&src, double a1, double a0}{1078}{processing}{}
\functionlistentry{int}{GrayTransformLimits}{const Image \&src, const Image \& dest, int min, int max}{1079}{processing}{}
\functionlistentry{int}{GrayTransformLimits}{const Image \&img, int min, int max}{1080}{processing}{}

\letterlabel{H}
\letterlabel{H}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}
\letterlabelend{H}
\functionlistentry{int}{HaarImg}{Image imgs,int depth,int mode,Image imgs}{1232}{signalTrafo}{}
\functionlistentry{int}{Hartley}{const Vector \&src,const Vector \&dst}{1201}{signalTrafo}{}
\functionlistentry{int}{Hartley}{Vector \&src}{1202}{signalTrafo}{}
\functionlistentry{int}{HartleyImgD}{ImageD src,ImageD dest,int dir=XY}{1204}{signalTrafo}{}
\functionlistentry{int}{HartleyMPImgD}{ImageD mag,ImageD phase,ImageD dst}{1212}{signalTrafo}{}
\functionlistentry{int}{HesseLine}{double p,double phi,int val,Image img}{1334}{graphics}{}
\functionlistentry{int}{HesseLine}{const Vector \&p,int val,Image img}{1335}{graphics}{}
\functionlistentry{int}{Hist::Add}{double val}{908}{statistics}{}
\functionlistentry{int}{Hist::Count}{int index}{909}{statistics}{}
\functionlistentry{}{Hist::Hist}{}{903}{statistics}{}
\functionlistentry{}{Hist::Hist}{const Hist \&h}{904}{statistics}{}
\functionlistentry{}{Hist::Hist}{int knumber,double diff=1.0,double lower=-0.5}{905}{statistics}{}
\functionlistentry{int}{Hist::Limits}{double \&min,double \&max}{911}{statistics}{}
\functionlistentry{int}{Hist::Limits}{double \&min,double \&max,double quant}{912}{statistics}{}
\functionlistentry{double}{Hist::Rel}{int index}{910}{statistics}{}
\functionlistentry{int}{Hist::Reset}{}{906}{statistics}{}
\functionlistentry{int}{Hist::Reset}{int knumber,double diff=1.0,double lower=-0.5}{907}{statistics}{}
\functionlistentry{int}{Hist::Statistic}{int \&nbr,double \&mean,double \&dispers}{914}{statistics}{}
\functionlistentry{int}{Hist::Vis}{int val,Image img}{916}{statistics}{}
\functionlistentry{Hist}{HistImg}{Image img,int diff=1,int clw=1}{913}{statistics}{}
\functionlistentry{int}{Histogram::addValue}{int val,int count = 1}{887}{statistics}{}
\functionlistentry{int}{Histogram::getCount}{int nr}{888}{statistics}{}
\functionlistentry{vector\textless {}int\textgreater }{Histogram::getCount}{}{890}{statistics}{}
\functionlistentry{void}{Histogram::getCount}{vector\textless {}int\textgreater  \&v}{891}{statistics}{}
\functionlistentry{int}{Histogram::getLimits}{int \&min, int \&max}{895}{statistics}{}
\functionlistentry{int}{Histogram::getLimits}{int \&min, int \&max, double quantil}{896}{statistics}{}
\functionlistentry{double}{Histogram::getRelative}{int nr}{892}{statistics}{}
\functionlistentry{vector\textless {}double\textgreater }{Histogram::getRelative}{}{893}{statistics}{}
\functionlistentry{void}{Histogram::getRelative}{vector\textless {}double\textgreater  \&v}{894}{statistics}{}
\functionlistentry{}{Histogram::Histogram}{}{880}{statistics}{}
\functionlistentry{}{Histogram::Histogram}{int knumber}{881}{statistics}{}
\functionlistentry{}{Histogram::Histogram}{const Image \&img,int diff=1}{882}{statistics}{}
\functionlistentry{int}{Histogram::isValid}{}{885}{statistics}{}
\functionlistentry{int}{Histogram::nClasses}{}{886}{statistics}{}
\functionlistentry{int}{Histogram::operator []}{int nr}{889}{statistics}{}
\functionlistentry{int}{Histogram::reset}{}{883}{statistics}{}
\functionlistentry{int}{Histogram::reset}{int knumber}{884}{statistics}{}
\functionlistentry{int}{Histogram::Statistic}{int \&sum}{897}{statistics}{}
\functionlistentry{int}{Histogram::Statistic}{int \&sum,double \&xm,double \&xs}{898}{statistics}{}
\functionlistentry{int}{Histogram::Statistic}{int \&sum,double \&xm,double \&xs,double \&skew}{899}{statistics}{}
\functionlistentry{int}{Histogram::Vis}{int val,const Image \&img}{901}{statistics}{}
\functionlistentry{int}{HistogramEqualization}{const Image \&img1,const Image \&img2}{1083}{processing}{}
\functionlistentry{int}{HsiToColorImage}{const Image \&hue, const Image \&saturation, const Image \&intensity, const ColorImage \&dst}{1111}{processing}{}
\functionlistentry{void}{HsiToRgb}{double h, double s, double i, ColorValue \&dst, int maxval = 255}{303}{datastructures}{}
\functionlistentry{void}{HsiToRgb}{double h, double s, double i, double \&r, double \&g, double \&b}{307}{datastructures}{}
\functionlistentry{int}{Hungarian}{const Matrix \&cost,IMatrix \&reference\_pairs, double \&min\_cost}{1266}{registration}{}
\functionlistentry{int}{Hungarian}{const Matrix \&cost,IMatrix \&reference\_pairs, int mode=0}{1267}{registration}{}

\letterlabel{I}
\letterlabel{I}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}
\letterlabelend{I}
\functionlistentry{}{IfFailed}{function}{1564}{errorHandling}{}
\functionlistentry{void*}{Image-$>$getDataPointer}{}{72}{Images}{}
\functionlistentry{int}{Image-$>$ImageType}{}{71}{Images}{}
\functionlistentry{}{Image3d}{int xs, int ys, int zs, int maxval = 255, double xscale = 1.0, double yscale = 1.0, double zscale = 1.0}{73}{Images}{}
\functionlistentry{}{Image3d}{const std::string \&filemask, double xscale = 1.0, double yscale = 1.0, double zscale = 1.0}{74}{Images}{}
\functionlistentry{}{Image3d}{const Image3d \&src, bool copydata = true}{75}{Images}{}
\functionlistentry{}{Image3d}{const Image3d \&src, Window3d w}{76}{Images}{}
\functionlistentry{void}{Image::copy}{const Image \&src}{7}{Images}{}
\functionlistentry{void}{Image::create}{int xsize,int ysize,int maxval,const string \&title=''''}{5}{Images}{}
\functionlistentry{void}{Image::create}{const Image \&img,const string \&title=''''}{6}{Images}{}
\functionlistentry{static Image}{Image::createImage}{int sizeX, int sizeY, int maxValue, const std::string \&title = ''''}{8}{Images}{}
\functionlistentry{int}{Image::getIntensity}{int x,int y}{42}{Images}{}
\functionlistentry{int}{Image::getIntensity}{IPoint p}{43}{Images}{}
\functionlistentry{int}{Image::getIntensityUnchecked}{int x,int y}{44}{Images}{}
\functionlistentry{int}{Image::getIntensityUnchecked}{IPoint p}{45}{Images}{}
\functionlistentry{int}{Image::getPixel}{int x,int y}{34}{Images}{}
\functionlistentry{int}{Image::getPixel}{IPoint p}{35}{Images}{}
\functionlistentry{int}{Image::getPixelUnchecked}{int x,int y}{38}{Images}{}
\functionlistentry{int}{Image::getPixelUnchecked}{IPoint p}{39}{Images}{}
\functionlistentry{}{Image::Image}{}{3}{Images}{}
\functionlistentry{}{Image::Image}{const Image \&img}{4}{Images}{}
\functionlistentry{}{Image::Image}{const Image \&img,const Window \&w,const string \&title=''''}{30}{Images}{}
\functionlistentry{bool}{Image::inside}{const IPoint p}{58}{Images}{}
\functionlistentry{bool}{Image::inside}{int x,int y}{59}{Images}{}
\functionlistentry{bool}{Image::inside}{const Window \&w}{60}{Images}{}
\functionlistentry{bool}{Image::isValid}{}{13}{Images}{}
\functionlistentry{Image}{Image::operator()}{const Window \&w}{31}{Images}{}
\functionlistentry{int}{Image::setIntensity}{int x,int y,int value}{54}{Images}{}
\functionlistentry{int}{Image::setIntensity}{IPoint p,int value}{55}{Images}{}
\functionlistentry{int}{Image::setIntensityUnchecked}{int x,int y,int value}{56}{Images}{}
\functionlistentry{int}{Image::setIntensityUnchecked}{IPoint p,int value}{57}{Images}{}
\functionlistentry{void}{Image::setPixel}{int x,int y,int value}{46}{Images}{}
\functionlistentry{void}{Image::setPixel}{IPoint p,int value}{47}{Images}{}
\functionlistentry{void}{Image::setPixelUnchecked}{int x,int y,int value}{50}{Images}{}
\functionlistentry{void}{Image::setPixelUnchecked}{IPoint p,int value}{51}{Images}{}
\functionlistentry{}{ImageDFunction::ImageDFunction}{const ImageD \&imgp, int mode = INTERPOL}{1065}{functions}{}
\functionlistentry{}{ImageFunction::ImageFunction}{const Image \&imgp, int mode = INTERPOL}{1064}{functions}{}
\functionlistentry{PeakList}{ImgPeakList}{Image img,Image mark,int panz=0,int mingrw=0, int zykl=FALSE, int noise=0,int feat=IPL\_NOFEAT,int gnull=0}{1261}{registration}{}
\functionlistentry{int}{InfImgFile}{const string \&filename, int \&xsize, int \&ysize, int \&maxval,int \&nr}{117}{imageio}{}
\functionlistentry{int}{InfImgFile}{const string \&filename, int \&xsize, int \&ysize, int \&maxval}{118}{imageio}{}
\functionlistentry{int}{InfVis}{int code}{99}{Visualisierung}{}
\functionlistentry{Statistic}{InitStatistic}{int dim}{1605}{obsolet}{}
\functionlistentry{int}{InitTrans}{double tr[3][3]}{1595}{obsolet}{}
\functionlistentry{int}{Input}{const char *prompt}{1444}{genericTools}{}
\functionlistentry{int}{Input}{const char *prompt,int defvalue}{1445}{genericTools}{}
\functionlistentry{int}{Input}{const string \&prompt}{1446}{genericTools}{}
\functionlistentry{int}{Input}{const string \&prompt,int defvalue}{1447}{genericTools}{}
\functionlistentry{double}{InputD}{const char *prompt}{1448}{genericTools}{}
\functionlistentry{double}{InputD}{const char *prompt,double defvalue}{1449}{genericTools}{}
\functionlistentry{double}{InputD}{const string \&prompt}{1450}{genericTools}{}
\functionlistentry{double}{InputD}{const string \&prompt,double defvalue}{1451}{genericTools}{}
\functionlistentry{void}{InputS}{const char *p,char *s}{1452}{genericTools}{}
\functionlistentry{string}{InputS}{const string \&p}{1453}{genericTools}{}
\functionlistentry{int}{InputString}{char *Str,int Control,int *Ptr,int *scroll}{1454}{genericTools}{}
\functionlistentry{bool}{InsidePolygon}{const Matrix \&pl,const Point \&p}{280}{datastructures}{}
\functionlistentry{int}{Integer}{const string\& s}{1420}{genericTools}{}
\functionlistentry{int}{IntegrateFunc}{FuncD func,double s1,double s2,double *prec,double *val}{1413}{numeric}{}
\functionlistentry{int}{IntersecLine}{double p1,double phi1,double p2,double phi2,double p[2]}{1388}{numeric}{}
\functionlistentry{int}{Intersection}{const Line3d \&l1,const Line3d \&l2,Point3d \&p,double \&dist,Vector \&res}{1399}{numeric}{}
\functionlistentry{int}{Intersection}{const Line3d \&l1,const Line3d \&l2,Point3d \&p,double \&dist}{1400}{numeric}{}
\functionlistentry{int}{Intersection}{const Line3d \&l1,const Line3d \&l2,Point3d \&p}{1401}{numeric}{}
\functionlistentry{int}{Intersection}{const Line3d \&l,const Sphere \&s,Point3d \&p1,Point3d \&p2}{1402}{numeric}{}
\functionlistentry{int}{InvarFivePoint2d}{double p[5][2],double *i1,double *i2}{1394}{numeric}{}
\functionlistentry{int}{InvarFivePoint3d}{double p[5][3],double *i1,double *i2}{1403}{numeric}{}
\functionlistentry{int}{InvConvolution}{const Vector \&src1,const Vector \&src2,double beta,Vector \&dst}{1220}{signalTrafo}{}
\functionlistentry{int}{InvConvolutionFImgD}{ImageD re1,ImageD im1, ImageD re2,ImageD im2,ImageD re3,ImageD im3,double beta}{1222}{signalTrafo}{}
\functionlistentry{int}{InvConvolutionHImgD}{ImageD im1,ImageD im2,ImageD im3}{1223}{signalTrafo}{}
\functionlistentry{int}{InvConvolutionImg}{const Image \&im1,const Image \&im2, Image \&dst, double factor=0.0,double beta=0.000001,int mode=MD\_USE\_BIAS}{1224}{signalTrafo}{}
\functionlistentry{int}{InvConvolutionImg}{const Image \&im1,const Image \&im2, ImageD dst, double beta=0.000001,int mode=MD\_USE\_BIAS}{1225}{signalTrafo}{}
\functionlistentry{int}{InvConvolutionImgD}{ImageD im1,ImageD im2,ImageD dst,double beta=0.000001,int mode=MD\_USE\_BIAS}{1221}{signalTrafo}{}
\functionlistentry{Freeman}{Inverse}{}{473}{conturs}{}
\functionlistentry{Matrix}{Inverse}{const Matrix \&m}{1117}{matrixAlgebra}{}
\functionlistentry{int}{InvertImg}{const Image \&img, const Image \&dest}{1095}{processing}{}
\functionlistentry{int}{InvertImg}{const Image \&img}{1096}{processing}{}
\functionlistentry{MatrixStruct}{InvertMat}{MatrixStruct A,MatrixStruct B}{1593}{obsolet}{}
\functionlistentry{int}{InvertTrans}{double tr[3][3]}{1599}{obsolet}{}
\functionlistentry{int}{InvRadonImg}{const Image \&radon,Image \&res,int fmax=-1}{1235}{signalTrafo}{}
\functionlistentry{bool}{IsImg}{const Image \&img}{14}{Images}{}
\functionlistentry{bool}{IsImg}{const ColorImage \&img}{26}{Images}{}
\functionlistentry{int}{IsMatrix}{MatrixStruct mat}{1588}{obsolet}{}
\functionlistentry{int}{isPolygon}{const Matrix \& pl}{279}{datastructures}{}
\functionlistentry{bool}{IsPositivDefinit}{const Matrix \&m}{1120}{matrixAlgebra}{}

\letterlabel{K}
\letterlabel{K}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}
\letterlabelend{K}
\functionlistentry{void}{KDTree::create}{const vector\textless {}T\textgreater  \& s}{1280}{graph}{}
\functionlistentry{void}{KDTree::findKNearest}{const vector\textless {}double\textgreater  \& v, int k,vector\textless {}const T*\textgreater  \&neighbors, vector\textless {}double\textgreater  \&distances}{1283}{graph}{}
\functionlistentry{void}{KDTree::findKNearest}{const T \&v,int k,vector\textless {}const T*\textgreater  \&neighbors,vector\textless {}double\textgreater  \& distances}{1284}{graph}{}
\functionlistentry{T*}{KDTree::findNearest}{const vector\textless {}double\textgreater  \& v}{1281}{graph}{}
\functionlistentry{T*}{KDTree::findNearest}{const T \&s}{1282}{graph}{}
\functionlistentry{}{KDTree::KDTree}{}{1279}{graph}{}
\functionlistentry{void}{KDTree::read}{istream \&is}{1286}{graph}{}
\functionlistentry{void}{KDTree::write}{ostream \&os}{1285}{graph}{}
\functionlistentry{Matrix}{KLT}{const Matrix \&m}{876}{statistics}{}
\functionlistentry{Matrix}{KLT}{const Matrix \&m,Vector \&r}{877}{statistics}{}
\functionlistentry{Matrix}{KLT}{const Statistics \&st}{878}{statistics}{}
\functionlistentry{Matrix}{KLT}{const Statistics \&st,Vector \&r}{879}{statistics}{}

\letterlabel{L}
\letterlabel{L}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}
\letterlabelend{L}
\functionlistentry{int}{LabToColorImage}{const Image \&lImg, const Image \&aImg, const Image \&bImg, const ColorImage \&src}{1113}{processing}{}
\functionlistentry{void}{LabToRgb}{double l, double a, double b, ColorValue \&dst, int maxval = 255}{306}{datastructures}{}
\functionlistentry{void}{LabToRgb}{double l, double a, double b, double \&rr, double \&gg, double \&bb}{316}{datastructures}{}
\functionlistentry{void}{LabToXyz}{double l, double a, double b, double \&x, double \&y, double \&z}{314}{datastructures}{}
\functionlistentry{int}{LaplaceImg}{Image src,int norm,Image dest}{351}{filter}{}
\functionlistentry{int}{LaplaceXImg}{Image src,int norm,Image dest}{349}{filter}{}
\functionlistentry{int}{LaplaceYImg}{Image src,int norm,Image dest}{350}{filter}{}
\functionlistentry{double}{LengthVec}{double v[3]}{1568}{obsolet}{}
\functionlistentry{double}{LengthVecRn}{double *v,int dim}{1578}{obsolet}{}
\functionlistentry{int}{limited}{int val,int min,int max}{1354}{numeric}{}
\functionlistentry{int}{limited}{int val,Image img}{1355}{numeric}{}
\functionlistentry{int}{Line}{int x1,int y1,int x2,int y2,int val,int mode,Image img}{1328}{graphics}{}
\functionlistentry{int}{Line}{int x1,int y1,int x2,int y2,int val,Image img}{1329}{graphics}{}
\functionlistentry{int}{Line}{const IVector \&p1,const IVector \&p2,int val,int mode,Image img}{1330}{graphics}{}
\functionlistentry{int}{Line}{const IVector \&p1,const IVector \&p2,int val,Image img}{1331}{graphics}{}
\functionlistentry{int}{Line}{const Point \&p1,const Point \&p2,int val,int mode,Image img}{1332}{graphics}{}
\functionlistentry{int}{Line}{const Point \&p1,const Point \&p2,int val,Image img}{1333}{graphics}{}
\functionlistentry{Vector3d \&}{Line3d::DP}{}{676}{geoObject3d}{}
\functionlistentry{double}{Line3d::DX}{}{673}{geoObject3d}{}
\functionlistentry{double}{Line3d::DY}{}{674}{geoObject3d}{}
\functionlistentry{double}{Line3d::DZ}{}{675}{geoObject3d}{}
\functionlistentry{}{Line3d::Line3d}{}{659}{geoObject3d}{}
\functionlistentry{}{Line3d::Line3d}{double xp,double yp,double zp,double x2p,double y2p,double z2p}{660}{geoObject3d}{}
\functionlistentry{}{Line3d::Line3d}{const Point3d \&p1,const Point3d \&p2}{661}{geoObject3d}{}
\functionlistentry{}{Line3d::Line3d}{const Line3d \&p}{662}{geoObject3d}{}
\functionlistentry{explicit}{Line3d::Line3d}{const Vector \&v}{663}{geoObject3d}{}
\functionlistentry{explicit}{Line3d::Line3d}{double d[]}{664}{geoObject3d}{}
\functionlistentry{Vector3d}{Line3d::operator()}{double p}{677}{geoObject3d}{}
\functionlistentry{Vector3d \&}{Line3d::P1}{}{668}{geoObject3d}{}
\functionlistentry{Vector3d}{Line3d::P2}{}{672}{geoObject3d}{}
\functionlistentry{double}{Line3d::Volume}{}{678}{geoObject3d}{}
\functionlistentry{double}{Line3d::X1}{}{665}{geoObject3d}{}
\functionlistentry{double}{Line3d::X2}{}{669}{geoObject3d}{}
\functionlistentry{double}{Line3d::Y1}{}{666}{geoObject3d}{}
\functionlistentry{double}{Line3d::Y2}{}{670}{geoObject3d}{}
\functionlistentry{double}{Line3d::Z1}{}{667}{geoObject3d}{}
\functionlistentry{double}{Line3d::Z2}{}{671}{geoObject3d}{}
\functionlistentry{int}{LinearOptimization}{int rows,int columns,double **matrix,double *rside,double *costfunction,double *solution,double \&costs}{1139}{matrixAlgebra}{}
\functionlistentry{Contur}{LineContur}{Contur c,int p1[2][,int p2[2]]}{1342}{graphics}{}
\functionlistentry{double}{LineSeg::Angle}{const LineSeg \&sec}{570}{geoObject}{}
\functionlistentry{void}{LineSeg::CalcHesse}{double \&p,double \&phi}{566}{geoObject}{}
\functionlistentry{Point}{LineSeg::ClosestPoint}{Point p}{573}{geoObject}{}
\functionlistentry{Point}{LineSeg::ClosestPoint}{Point p,double \&my}{574}{geoObject}{}
\functionlistentry{double}{LineSeg::Distance}{Point p}{575}{geoObject}{}
\functionlistentry{Point}{LineSeg::getP1}{}{558}{geoObject}{}
\functionlistentry{Point}{LineSeg::getP2}{}{559}{geoObject}{}
\functionlistentry{bool}{LineSeg::Intersection}{const LineSeg \&second}{576}{geoObject}{}
\functionlistentry{bool}{LineSeg::Intersection}{const LineSeg \&second,Point \&ip}{577}{geoObject}{}
\functionlistentry{bool}{LineSeg::Intersection}{const LineSeg \&second,Point \&ip,double \&my1,double \&my2}{578}{geoObject}{}
\functionlistentry{bool}{LineSeg::LeftOf}{Point p}{572}{geoObject}{}
\functionlistentry{double}{LineSeg::LimitedMy}{double my}{565}{geoObject}{}
\functionlistentry{}{LineSeg::LineSeg}{}{550}{geoObject}{}
\functionlistentry{}{LineSeg::LineSeg}{Point p1,Point p2,int type=LineSeg::segment}{551}{geoObject}{}
\functionlistentry{}{LineSeg::LineSeg}{IPoint p1,IPoint p2,int type=LineSeg::segment}{552}{geoObject}{}
\functionlistentry{}{LineSeg::LineSeg}{const LineSeg \&p}{553}{geoObject}{}
\functionlistentry{}{LineSeg::LineSeg}{double x1,double y1,double x2,double y2,int type=LineSeg::segment}{554}{geoObject}{}
\functionlistentry{}{LineSeg::LineSeg}{double p,double phi}{555}{geoObject}{}
\functionlistentry{explicit}{LineSeg::LineSeg}{const Vector \&v,int type=LineSeg::segment}{556}{geoObject}{}
\functionlistentry{explicit}{LineSeg::LineSeg}{double d[],int type=LineSeg::segment}{557}{geoObject}{}
\functionlistentry{Point}{LineSeg::Normal}{}{579}{geoObject}{}
\functionlistentry{double}{LineSeg::OrientationAngle}{}{569}{geoObject}{}
\functionlistentry{double}{LineSeg::P}{}{567}{geoObject}{}
\functionlistentry{double}{LineSeg::Phi}{}{568}{geoObject}{}
\functionlistentry{Point}{LineSeg::RelPoint}{double my}{564}{geoObject}{}
\functionlistentry{bool}{LineSeg::RightOf}{Point p}{571}{geoObject}{}
\functionlistentry{void}{LineSeg::setP1}{Point p}{560}{geoObject}{}
\functionlistentry{void}{LineSeg::setP2}{Point p}{561}{geoObject}{}
\functionlistentry{void}{LineSeg::setType}{int type}{563}{geoObject}{}
\functionlistentry{int}{LineSeg::Type}{}{562}{geoObject}{}
\functionlistentry{Segment}{LineSegContur}{Contur c,int mlng,double mdist}{1187}{fitting}{}
\functionlistentry{Segment}{LineSegPointList}{PointList pl,int closed,int mlng,double mdist}{1192}{fitting}{}
\functionlistentry{int}{LMDif}{Vector \&variable,int optnumber,LMFunc *func,int funcdim,int \&inumber,int maxiter=MAX\_INT}{1140}{matrixAlgebra}{}
\functionlistentry{int}{LMDif}{Vector \&variable,int optnumber,LMFunc *func,int funcdim}{1141}{matrixAlgebra}{}
\functionlistentry{int}{LMDif}{Vector \&variable,IVector optvar, LMFunc *func,int funcdim,int \&inumber,int maxiter=MAX\_INT}{1142}{matrixAlgebra}{}
\functionlistentry{int}{LMDif}{Vector \&variable,IVector optvar,LMFunc *func,int funcdim}{1143}{matrixAlgebra}{}
\functionlistentry{int}{LMDif}{const vector\textless {}double*\textgreater  \&ov,const LMFunctor \&fn, int maxiter=MAX\_INT}{1144}{matrixAlgebra}{}
\functionlistentry{int}{LocalSeg}{Image source,Image oimg,int neighb,int level}{443}{conturs}{}
\functionlistentry{int}{LocalSeg}{Image source,Image oimg,int neighb,int level1,int level2}{444}{conturs}{}
\functionlistentry{int}{LogImgD}{ImageD src,ImageD dest}{1103}{processing}{}
\functionlistentry{int}{LogPolarC}{ImageD src,ImageD dest,double x,double y,double \&r,double \&phi,double r1=1,double r2=0,int sym=2}{1109}{processing}{}
\functionlistentry{int}{LogPolarImg}{const Image \&src, const Image \&dest,double r1=1,double r2=0,int sym=2}{1108}{processing}{}
\functionlistentry{int}{LogPolarImgD}{ImageD src,ImageD dest,double r1=1,double r2=0,int sym=2}{1107}{processing}{}
\functionlistentry{string}{lowercase}{const string \&s}{1422}{genericTools}{}
\functionlistentry{int}{LSIFilter::Filter}{const Image \&src,Image \&dst,int offset}{330}{filter}{}
\functionlistentry{int}{LSIFilter::Filter}{const Image \&src,ImageD dst}{331}{filter}{}
\functionlistentry{int}{LSIFilter::Filter}{ImageD src,ImageD dst}{332}{filter}{}
\functionlistentry{double}{LSIFilter::getMask}{int x,int y}{323}{filter}{}
\functionlistentry{}{LSIFilter::LSIFilter}{}{318}{filter}{}
\functionlistentry{}{LSIFilter::LSIFilter}{const LSIFilter \&f}{319}{filter}{}
\functionlistentry{}{LSIFilter::LSIFilter}{const Matrix \&m}{320}{filter}{}
\functionlistentry{}{LSIFilter::LSIFilter}{const IMatrix \&m,int norm}{321}{filter}{}
\functionlistentry{}{LSIFilter::LSIFilter}{int *m,int norm}{322}{filter}{}
\functionlistentry{void}{LSIFilter::NegateMask}{}{324}{filter}{}
\functionlistentry{double}{LSIFilter::proposeOffset}{const Image \&img}{325}{filter}{}
\functionlistentry{int}{LSIImg}{const Image \&src,Image \&dst,const LSIFilter \&f,int offset}{333}{filter}{}
\functionlistentry{int}{LSIImg}{Image src,int nx,int ny,int *mask,int norm,int offset,Image dest}{334}{filter}{}
\functionlistentry{int}{LSIImg}{Image src,int nx,int ny,double *mask,int offset,Image dest}{335}{filter}{}
\functionlistentry{int}{LSIImg}{Image src,const Matrix \&mask,int offset,Image dest}{336}{filter}{}
\functionlistentry{int}{LSIImg}{Image src,const IMatrix \&mask,int norm,int offset,Image dest}{337}{filter}{}
\functionlistentry{int}{LUDecomposition}{const Matrix \&a,Matrix \&L,Matrix \&U}{1124}{matrixAlgebra}{}
\functionlistentry{int}{LUDecompositionPacked}{const Matrix \&a,Matrix \&LU,IVector \&indx,bool pivot=true}{1125}{matrixAlgebra}{}
\functionlistentry{Vector}{LUSolve}{const Matrix \&LU,const IVector \&indx,const Vector \&i}{1126}{matrixAlgebra}{}

\letterlabel{M}
\letterlabel{M}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}
\letterlabelend{M}
\functionlistentry{Contur}{MakeContur}{}{604}{geoObject}{}
\functionlistentry{int}{MarkContur}{Contur c,int val,Image img}{1347}{graphics}{}
\functionlistentry{int}{Marker}{int mode, int x,int y,int val,int size,Image img}{1322}{graphics}{}
\functionlistentry{int}{Marker}{int mode, const IVector \&p,int val,int size,Image img}{1323}{graphics}{}
\functionlistentry{int}{Marker}{int mode, const Point \&p,int val,int size,Image img}{1324}{graphics}{}
\functionlistentry{Trafo}{MatchObject}{(const Contur \&cont1,const Contur \&cont2,int tmode,double \&eval,int mmode=MM\_SQUARE,int anz=0)}{1269}{registration}{}
\functionlistentry{Trafo}{MatchObject}{(const Contur \&cont1,const Contur \&cont2,int tmode=TRM\_AFFINE)}{1270}{registration}{}
\functionlistentry{Trafo}{MatchObject}{(const Contur \&cont1,const Matrix \&pl2,int tmode,double \&eval,int mmode=MM\_SQUARE,int anz=0)}{1271}{registration}{}
\functionlistentry{Trafo}{MatchObject}{(const Contur \&cont1,const Matrix \&pl2,int tmode=TRM\_AFFINE)}{1272}{registration}{}
\functionlistentry{Trafo}{MatchObject}{(const Matrix \&pl1,const Matrix \&pl2,int tmode,double \&eval,int mmode=MM\_SQUARE,int anz=0)}{1273}{registration}{}
\functionlistentry{Trafo}{MatchObject}{(const Matrix \&pl1,const Matrix \&pl2,int tmode=TRM\_AFFINE)}{1274}{registration}{}
\functionlistentry{Trafo}{MatchObject}{(const Matrix \&pl1,const Contur \&cont2,int tmode,double \&eval,int mmode=MM\_SQUARE,int anz=0)}{1275}{registration}{}
\functionlistentry{Trafo}{MatchObject}{(const Matrix \&pl1,const Contur \&cont2,int tmode=TRM\_AFFINE)}{1276}{registration}{}
\functionlistentry{Trafo}{MatchPointlists}{const Matrix \&p1,const Matrix \&p2,int mode=TRM\_PROJECTIVE}{1247}{registration}{}
\functionlistentry{Trafo}{MatchPointlists}{const Matrix \&p1,const Matrix \&p2, int mode,const Vector \&w}{1248}{registration}{}
\functionlistentry{Trafo}{MatchPointlists}{const vector\textless {}Point\textgreater  \&pl1, const vector\textless {}Point\textgreater  \&pl2, int mode = TRM\_PROJECTIVE}{1249}{registration}{}
\functionlistentry{Trafo}{MatchPointlists}{const vector\textless {}Point\textgreater  \&pl1, const vector\textless {}Point\textgreater  \&pl2, int mode = TRM\_PROJECTIVE, const vector\textless {}double\textgreater  \&weight}{1250}{registration}{}
\functionlistentry{Trafo}{MatchPointlists}{PointList pl1,PointList pl2,int mode}{1251}{registration}{}
\functionlistentry{Trafo}{MatchPointlistsLinOpt}{const Matrix \&p1,const Matrix \&p2,int mode=TRM\_AFFINE}{1252}{registration}{}
\functionlistentry{Trafo}{MatchPointlistsLinOpt}{const Matrix \&p1,const Matrix \&p2,int mode,const Vector \&w,double limit=1000000.0}{1253}{registration}{}
\functionlistentry{int}{MatchPointlistsLinOpt}{PointList pl1,PointList pl2,double tr[][3],int mode=TRM\_AFFINE,double limit=1000000.0}{1254}{registration}{}
\functionlistentry{MatrixStruct}{Mateigen}{MatrixStruct A,double *eval,MatrixStruct evect}{1137}{matrixAlgebra}{}
\functionlistentry{int}{Matrix::AddDyadicProd}{const Vector \& v,const Vector \& w,double factor}{276}{datastructures}{}
\functionlistentry{int}{Matrix::AddDyadicProd}{const Vector \& v, double factor}{277}{datastructures}{}
\functionlistentry{int}{Matrix::cols}{}{265}{datastructures}{}
\functionlistentry{int}{Matrix::DeleteCol}{int n}{271}{datastructures}{}
\functionlistentry{int}{Matrix::DeleteCol}{int n1,int n2}{272}{datastructures}{}
\functionlistentry{int}{Matrix::DeleteRow}{int n}{269}{datastructures}{}
\functionlistentry{int}{Matrix::DeleteRow}{int n1,int n2}{270}{datastructures}{}
\functionlistentry{void}{Matrix::ExchangeCol}{int i1,int i2}{268}{datastructures}{}
\functionlistentry{void}{Matrix::ExchangeRow}{int i1,int i2}{267}{datastructures}{}
\functionlistentry{}{Matrix::Matrix}{}{255}{datastructures}{}
\functionlistentry{}{Matrix::Matrix}{const int rows,const int cols,int initmode=0}{256}{datastructures}{}
\functionlistentry{explicit}{Matrix::Matrix}{const int rows,const int cols,double *init}{257}{datastructures}{}
\functionlistentry{}{Matrix::Matrix}{const Matrix\& m}{258}{datastructures}{}
\functionlistentry{}{Matrix::Matrix}{const IMatrix\& im}{259}{datastructures}{}
\functionlistentry{explicit}{Matrix::Matrix}{const Image\& m,int mode=RAW,int sign=UNSIGNED}{260}{datastructures}{}
\functionlistentry{explicit}{Matrix::Matrix}{const ImageD \& m}{261}{datastructures}{}
\functionlistentry{double}{Matrix::MaxVal}{}{273}{datastructures}{}
\functionlistentry{Matrix}{Matrix::MulTrans}{const Matrix \&m2}{262}{datastructures}{}
\functionlistentry{Vector}{Matrix::MulTrans}{const Vector \&v}{263}{datastructures}{}
\functionlistentry{int}{Matrix::rows}{}{264}{datastructures}{}
\functionlistentry{int}{Matrix::Sort}{int col=0,bool asc=true}{278}{datastructures}{}
\functionlistentry{void}{Matrix::SumCols}{Vector \&sum}{275}{datastructures}{}
\functionlistentry{void}{Matrix::SumRows}{Vector \&sum}{274}{datastructures}{}
\functionlistentry{int}{Max}{int val1,int val2}{1363}{numeric}{}
\functionlistentry{double}{MaxD}{double val1,double val2}{1365}{numeric}{}
\functionlistentry{int}{MaxImg}{const Image \&img1,const Image \&img2,const Image \&dest,int mode=MD\_NORMALIZE}{1093}{processing}{}
\functionlistentry{Vector}{Mean}{const Statistics \&st}{868}{statistics}{}
\functionlistentry{int}{MeanImg}{Image src,Image dest}{348}{filter}{}
\functionlistentry{int}{MedianImg}{const Image \&img,int size,Image \&dest}{386}{filter}{}
\functionlistentry{int}{Menu}{const vector$<$string$>$ \&t,int x1=-1,int y1=-1,int x2=-1,int y2=-1, bool restore=false,const string \&title=''''}{1458}{genericTools}{}
\functionlistentry{int}{Menu}{const vector$<$string$>$ \&t,const vector$<$int$>$ \&menuId, int x1=2,int y1=2,int x2=30,int y2=22, bool restore=false,const string \&title=''''}{1459}{genericTools}{}
\functionlistentry{void}{Message}{char *name, char *msg, int code}{1557}{errorHandling}{}
\functionlistentry{int}{MexicanHatImg}{const Image \&src,Image \&dest,double sigma,int neighb=0}{355}{filter}{}
\functionlistentry{int}{MexicanHatImg}{const Image \&src,ImageD dest,double sigma,int neighb=0}{356}{filter}{}
\functionlistentry{int}{MexicanHatImg}{ImageD src,ImageD dest,double sigma,int neighb=0}{357}{filter}{}
\functionlistentry{int}{Min}{int val1,int val2}{1364}{numeric}{}
\functionlistentry{double}{MinD}{double val1,double val2}{1366}{numeric}{}
\functionlistentry{int}{MinImg}{const Image \&img1,const Image \&img2,const Image \&dest,int mode=MD\_NORMALIZE}{1094}{processing}{}
\functionlistentry{int}{MinMaxImg}{const Image \&src,int nx, int ny,Image \&minimg, Image \&maximg}{383}{filter}{}
\functionlistentry{double}{MinTree::getCluster}{Forest \&f, int nCluster}{1305}{graph}{}
\functionlistentry{double}{MinTree::getForest}{Forest \&f, double maxlen}{1304}{graph}{}
\functionlistentry{double}{MinTree::getTree}{Forest \&f}{1303}{graph}{}
\functionlistentry{}{MinTree::MinTree}{const vector\textless {}Point\textgreater  \&pointlist}{1300}{graph}{}
\functionlistentry{}{MinTree::MinTree}{const vector\textless {}vector\textless {}double\textgreater  \textgreater  \&nodelist, const VectorDistance \&vd = EuclideanVectorDistance()}{1301}{graph}{}
\functionlistentry{}{MinTree::MinTree}{const Matrix \&distances}{1302}{graph}{}
\functionlistentry{LSIFilter}{mkDirDoBFilter}{int n,double dir,double len,double width}{328}{filter}{}
\functionlistentry{LSIFilter}{mkDirEdgeFilter}{int n,double dir,double rad}{329}{filter}{}
\functionlistentry{LSIFilter}{mkDirSmearFilter}{int n,double dir,double len,double width}{327}{filter}{}
\functionlistentry{LSIFilter}{mkPolynomFilter}{int n,int grad,int i,int j}{326}{filter}{}
\functionlistentry{int}{Mod}{int val,int mod}{1368}{numeric}{}
\functionlistentry{ImageD}{MomentImg}{Image imgs,int p,int q,int n,ImageD imgd}{1233}{signalTrafo}{}
\functionlistentry{int}{MomentPolygon}{PointList p,double m[15],double s[2]}{1614}{obsolet}{}
\functionlistentry{int}{MomentPolygon}{const Matrix \&p,double m[15],double s[2]}{1615}{obsolet}{}
\functionlistentry{int}{MomentRegion}{Contur c, double m[15], double s[2]}{1617}{obsolet}{}
\functionlistentry{Vector}{Moments::AffineAlgebraicInvariants}{}{821}{moments}{}
\functionlistentry{Vector}{Moments::AffineHuInvariants}{}{823}{moments}{}
\functionlistentry{Moments}{Moments::AffineTransform}{const Trafo \&tr}{820}{moments}{}
\functionlistentry{Moments}{Moments::CentralMoments}{}{813}{moments}{}
\functionlistentry{void}{Moments::getCentroid}{double \&xc,double \&yc}{812}{moments}{}
\functionlistentry{Vector}{Moments::HuInvariants}{}{822}{moments}{}
\functionlistentry{double *}{Moments::Mom}{}{810}{moments}{}
\functionlistentry{}{Moments::Moments}{}{803}{moments}{}
\functionlistentry{}{Moments::Moments}{double m[15]}{804}{moments}{}
\functionlistentry{}{Moments::Moments}{const Region \&r}{805}{moments}{}
\functionlistentry{}{Moments::Moments}{const Contur \&c}{806}{moments}{}
\functionlistentry{}{Moments::Moments}{const Matrix \&p}{807}{moments}{}
\functionlistentry{}{Moments::Moments}{PointList p}{808}{moments}{}
\functionlistentry{}{Moments::Moments}{PointList p,int a1,int a2}{809}{moments}{}
\functionlistentry{Moments}{Moments::Normalize}{Trafo \&tr,nmode mode=Moments::standard}{837}{moments}{}
\functionlistentry{Moments}{Moments::Normalize}{nmode mode=Moments::standard}{838}{moments}{}
\functionlistentry{Moments}{Moments::NormalizeRotation}{}{834}{moments}{}
\functionlistentry{Moments}{Moments::NormalizeRotation}{double \&phi}{835}{moments}{}
\functionlistentry{Moments}{Moments::NormalizeRotation}{double \&c,double \&s}{836}{moments}{}
\functionlistentry{Moments}{Moments::NormalizeScaling}{scalemode mode=anisotropic}{831}{moments}{}
\functionlistentry{Moments}{Moments::NormalizeScaling}{double \&alpha}{832}{moments}{}
\functionlistentry{Moments}{Moments::NormalizeScaling}{double \&alpha,double \&beta}{833}{moments}{}
\functionlistentry{Moments}{Moments::NormalizeSign}{}{824}{moments}{}
\functionlistentry{Moments}{Moments::NormalizeTranslation}{}{825}{moments}{}
\functionlistentry{Moments}{Moments::NormalizeTranslation}{double \&x,double \&y}{826}{moments}{}
\functionlistentry{Moments}{Moments::NormalizeXShearing}{}{827}{moments}{}
\functionlistentry{Moments}{Moments::NormalizeXShearing}{double \&beta}{828}{moments}{}
\functionlistentry{Moments}{Moments::NormalizeYShearing}{}{829}{moments}{}
\functionlistentry{Moments}{Moments::NormalizeYShearing}{double \&beta}{830}{moments}{}
\functionlistentry{Moments}{Moments::Rotate}{double phi}{815}{moments}{}
\functionlistentry{Moments}{Moments::Scale}{double a}{818}{moments}{}
\functionlistentry{Moments}{Moments::Scale}{double a,double b}{819}{moments}{}
\functionlistentry{Moments}{Moments::Translate}{double dx,double dy}{814}{moments}{}
\functionlistentry{Moments}{Moments::XShear}{double s}{816}{moments}{}
\functionlistentry{Moments}{Moments::YShear}{double s}{817}{moments}{}
\functionlistentry{int}{Mouse}{Image img,int *x,int *y}{100}{Visualisierung}{}
\functionlistentry{int}{Mouse}{Image img,int \&x,int \&y}{101}{Visualisierung}{}
\functionlistentry{int}{MoveImgD}{ImageD src,ImageD dest}{1100}{processing}{}
\functionlistentry{MatrixStruct}{MoveMat}{MatrixStruct m1,MatrixStruct m2}{1589}{obsolet}{}
\functionlistentry{double*}{MoveVec}{double v1[3],double v2[3]}{1567}{obsolet}{}
\functionlistentry{double*}{MoveVecRn}{double *v1,int dim,double *v2}{1577}{obsolet}{}
\functionlistentry{int}{MPSpectrumFImgD}{ImageD re,ImageD im,ImageD mag,ImageD phase}{1208}{signalTrafo}{}
\functionlistentry{int}{MPSpectrumHImgD}{ImageD sp,ImageD mag,ImageD phase}{1209}{signalTrafo}{}
\functionlistentry{int}{MPSpectrumImgD}{ImageD im,ImageD mag,ImageD phase}{1210}{signalTrafo}{}
\functionlistentry{int}{MulDiv}{int val1,int val2,int val3}{1367}{numeric}{}
\functionlistentry{int}{MulImgD}{ImageD img1,ImageD img2,ImageD dest}{1102}{processing}{}
\functionlistentry{MatrixStruct}{MulMat}{MatrixStruct m1,MatrixStruct m2,MatrixStruct m3}{1591}{obsolet}{}
\functionlistentry{int}{MulMatVec}{MatrixStruct A,double *b,double *x}{1592}{obsolet}{}

\letterlabel{N}
\letterlabel{N}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}
\letterlabelend{N}
\functionlistentry{}{Neighbor4Walker::Neighbor4Walker}{IPoint p}{191}{datastructures}{}
\functionlistentry{}{Neighbor8Walker::Neighbor8Walker}{IPoint p}{192}{datastructures}{}
\functionlistentry{Image}{NewImg}{int xsize,int ysize,int maxval,const string \&title=''''}{10}{Images}{}
\functionlistentry{Image}{NewImg}{const Image \&img,int copy=false,const string \&title=''''}{11}{Images}{}
\functionlistentry{ColorImage}{NewImg}{int xsize,int ysize,int maxval,const string \&title=''''}{22}{Images}{}
\functionlistentry{ColorImage}{NewImg}{const ColorImage \&img,int copy=false,const string \&title=''''}{23}{Images}{}
\functionlistentry{ImageD}{NewImgD}{int xsize,int ysize,double minval=0.0,double maxval=0.0}{77}{Images}{}
\functionlistentry{ImageD}{NewImgD}{ImageD img,bool copy=false}{78}{Images}{}
\functionlistentry{ImageD}{NewImgD}{const Image \&img,bool copy=false}{79}{Images}{}
\functionlistentry{MatrixStruct}{NewMatrix}{int typ,int rows,int columns}{1586}{obsolet}{}
\functionlistentry{PeakList}{NewPeakList}{}{1262}{registration}{}
\functionlistentry{int}{NonLinEquSys}{FuncD *func,int dim,int *step,double *mse,double *x}{1130}{matrixAlgebra}{}
\functionlistentry{int}{NormalEquationSys}{MatrixStruct A,double *b,double *x}{1129}{matrixAlgebra}{}
\functionlistentry{Vector}{Normalize}{const Vector \&v}{253}{datastructures}{}
\functionlistentry{int}{NormalizeMoments}{const double m1[15],double m2[15]}{1625}{obsolet}{}
\functionlistentry{double*}{NormVec}{double v1[3],double v2[3]}{1571}{obsolet}{}
\functionlistentry{double*}{NormVecRn}{double *v1,int dim,double *v2}{1581}{obsolet}{}
\functionlistentry{string}{NumberString}{int i,unsigned int width=0}{1415}{genericTools}{}
\functionlistentry{string}{NumberString}{unsigned int i,unsigned int width=0}{1416}{genericTools}{}
\functionlistentry{string}{NumberString}{long int i,unsigned int width=0}{1417}{genericTools}{}
\functionlistentry{string}{NumberString}{long long int i,unsigned int width=0}{1418}{genericTools}{}
\functionlistentry{string}{NumberString}{double f,unsigned int width=0,unsigned int prec=0}{1419}{genericTools}{}

\letterlabel{O}
\letterlabel{O}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}
\letterlabelend{O}
\functionlistentry{void}{OffMessage}{void}{1558}{errorHandling}{}
\functionlistentry{void}{OnMessage}{void}{1559}{errorHandling}{}
\functionlistentry{void}{OpenAlpha}{unsigned char *windowname}{1427}{genericTools}{}
\functionlistentry{int}{OpeningImg}{const Image \&src,Image \&dest,int nx=3, int ny=-1}{379}{filter}{}
\functionlistentry{int}{OpeningImg}{const Image \&src,Image \&dest,const IMatrix \&mask}{380}{filter}{}
\functionlistentry{double \&}{operator ()}{int xi,int yi}{811}{moments}{}
\functionlistentry{Trafo}{operator *}{const Trafo \&,const Trafo \&}{687}{geoTrafo}{}
\functionlistentry{Vector}{operator *}{const Trafo \&,const Vector \&}{688}{geoTrafo}{}
\functionlistentry{ostream \&}{operator <<}{ostream \&s,const Statistics \&t}{874}{statistics}{}
\functionlistentry{istream \&}{operator >>}{istream \&s,Statistics \&st}{875}{statistics}{}
\functionlistentry{Contur}{operator+}{const Contur \&c1,const Contur \&c2}{404}{conturs}{}
\functionlistentry{Camera \&}{operator=}{const Camera \&c}{773}{cameraModel}{}
\functionlistentry{double}{Orientation}{const Moments \&m}{857}{moments}{}
\functionlistentry{int}{OrientationMoments}{double moment[15],double \&angle}{1277}{registration}{}
\functionlistentry{int}{OrientedDoBImg}{const Image \&src,const Image \&dir, Image \&dest,int fsize=11,int flength=10,int fwidth=1}{365}{filter}{}
\functionlistentry{int}{OrientedEdgeImg}{const Image \&src,const Image \&dir, Image \&dest,int fsize=11,int rad=10}{366}{filter}{}
\functionlistentry{int}{OrientedSmearImg}{const Image \&src,const Image \&dir, Image \&dest,int fsize=11,int flength=10,int fwidth=1}{364}{filter}{}

\letterlabel{P}
\letterlabel{P}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}
\letterlabelend{P}
\functionlistentry{int}{ParamQuadrFunc}{double par[5],int type,double koeff[6]}{1393}{numeric}{}
\functionlistentry{int*}{Peak1D}{double* values,int anz,int\& panz,int zykl,int noise}{1259}{registration}{}
\functionlistentry{IVector}{Peak1D}{const Vector\& vec,int panz,int zykl,int noise}{1260}{registration}{}
\functionlistentry{double}{PeakValuation}{Image img,Image mark,double\& x0,double\& y0, int mode=PN\_CONVOLUTION,int gnull=0,int zykl=TRUE}{1258}{registration}{}
\functionlistentry{int}{PhasenSpektrumQFT}{QuatMatrix\& input, Image\& alpha, Image\& beta, Image\& delta, int mode=CENTER}{1555}{quaternions}{}
\functionlistentry{Point}{Point::normalized}{}{173}{datastructures}{}
\functionlistentry{bool}{Point::operator !=}{const Point \&p}{160}{datastructures}{}
\functionlistentry{Point}{Point::operator *}{double f}{165}{datastructures}{}
\functionlistentry{double}{Point::operator *}{Point second}{167}{datastructures}{}
\functionlistentry{Point}{Point::operator *=}{double f}{166}{datastructures}{}
\functionlistentry{Point}{Point::operator +}{const Point \&p}{161}{datastructures}{}
\functionlistentry{Point}{Point::operator +=}{const Point \&p}{162}{datastructures}{}
\functionlistentry{Point}{Point::operator -}{const Point \&p}{163}{datastructures}{}
\functionlistentry{Point}{Point::operator -=}{const Point \&p}{164}{datastructures}{}
\functionlistentry{Point}{Point::operator /}{double d}{168}{datastructures}{}
\functionlistentry{Point}{Point::operator /=}{double d}{169}{datastructures}{}
\functionlistentry{bool}{Point::operator ==}{const Point \&p}{159}{datastructures}{}
\functionlistentry{double}{Point::phi}{}{172}{datastructures}{}
\functionlistentry{}{Point::Point}{}{152}{datastructures}{}
\functionlistentry{}{Point::Point}{double x, double y}{153}{datastructures}{}
\functionlistentry{explicit}{Point::Point}{const Vector \&v}{154}{datastructures}{}
\functionlistentry{explicit}{Point::Point}{const IVector \&v}{155}{datastructures}{}
\functionlistentry{explicit}{Point::Point}{double d[]}{156}{datastructures}{}
\functionlistentry{double}{Point::r}{}{171}{datastructures}{}
\functionlistentry{int}{Point::Shift}{double dx,double dy}{170}{datastructures}{}
\functionlistentry{double}{Point::X}{}{157}{datastructures}{}
\functionlistentry{double}{Point::Y}{}{158}{datastructures}{}
\functionlistentry{bool}{pointInside}{double x,double y,const Contur \&c}{459}{conturs}{}
\functionlistentry{bool}{pointInside}{const Point \&p,const Contur \&c}{460}{conturs}{}
\functionlistentry{bool}{pointInside}{double x,double y,const Matrix \&pl}{461}{conturs}{}
\functionlistentry{bool}{pointInside}{const Point \&p,const Matrix \&pl}{462}{conturs}{}
\functionlistentry{int}{PointListMoment}{PointList pl,int a1,int a2,double m[15],double s[2]}{1616}{obsolet}{}
\functionlistentry{}{PointListWalker::PointListWalker}{}{185}{datastructures}{}
\functionlistentry{}{PointListWalker::PointListWalker}{IPoint p}{186}{datastructures}{}
\functionlistentry{}{PointListWalker::PointListWalker}{const vector\textless {}IPoint\textgreater  \&pl,int idx = 0}{187}{datastructures}{}
\functionlistentry{}{PointListWalker::PointListWalker}{const Contur \&c}{188}{datastructures}{}
\functionlistentry{void}{PointListWalker::setPointList}{const vector\textless {}IPoint\textgreater  \&v,int idx = 0}{189}{datastructures}{}
\functionlistentry{void}{PointListWalker::setStartIndex}{int idx = 0}{190}{datastructures}{}
\functionlistentry{int}{PolarC}{ImageD src,ImageD dest,double x,double y,double \&r,double \&phi,double r1=1,double r2=0,int sm=2}{1106}{processing}{}
\functionlistentry{int}{PolarImg}{const Image \&src,const Image \&dest,double r1=1,double r2=0,int sym=2}{1105}{processing}{}
\functionlistentry{int}{PolarImgD}{ImageD src,ImageD dest,double r1=1,double r2=0,int sym=2}{1104}{processing}{}
\functionlistentry{LineSeg}{Polygon::edge}{int i}{619}{geoObject}{}
\functionlistentry{const Point \&}{Polygon::operator[]}{int i}{618}{geoObject}{}
\functionlistentry{}{Polygon::Polygon}{}{611}{geoObject}{}
\functionlistentry{}{Polygon::Polygon}{const Polygon \&p}{612}{geoObject}{}
\functionlistentry{}{Polygon::Polygon}{Point p}{613}{geoObject}{}
\functionlistentry{explicit}{Polygon::Polygon}{const Matrix \&m}{614}{geoObject}{}
\functionlistentry{}{Polygon::Polygon}{const vector<Point> \&pl}{615}{geoObject}{}
\functionlistentry{explicit}{Polygon::Polygon}{const Contur \&c}{616}{geoObject}{}
\functionlistentry{void}{Polygon::Reset}{}{621}{geoObject}{}
\functionlistentry{void}{Polygon::Reset}{Point p}{622}{geoObject}{}
\functionlistentry{int}{Polygon::size}{}{617}{geoObject}{}
\functionlistentry{LineSeg}{PolygonalCurve::edge}{int i}{600}{geoObject}{}
\functionlistentry{bool}{PolygonalCurve::isClosed()}{}{598}{geoObject}{}
\functionlistentry{const Point \&}{PolygonalCurve::operator[]}{int i}{599}{geoObject}{}
\functionlistentry{}{PolygonalCurve::PolygonalCurve}{bool closed=false}{591}{geoObject}{}
\functionlistentry{}{PolygonalCurve::PolygonalCurve}{const PolygonalCurve \&p}{592}{geoObject}{}
\functionlistentry{}{PolygonalCurve::PolygonalCurve}{Point p,bool closed=false}{593}{geoObject}{}
\functionlistentry{explicit}{PolygonalCurve::PolygonalCurve}{const Matrix \&m, bool closed=false}{594}{geoObject}{}
\functionlistentry{}{PolygonalCurve::PolygonalCurve}{const vector<Point> \&pl,bool closed=false}{595}{geoObject}{}
\functionlistentry{explicit}{PolygonalCurve::PolygonalCurve}{const Contur \&c, bool closed=false}{596}{geoObject}{}
\functionlistentry{PolygonalCurve}{PolygonalCurve::ReducedToPrecision}{double prec,int mode=1}{609}{geoObject}{}
\functionlistentry{void}{PolygonalCurve::ReducedToPrecision}{double prec,PolygonalCurve \&res,int mode=1}{610}{geoObject}{}
\functionlistentry{void}{PolygonalCurve::Reset}{}{602}{geoObject}{}
\functionlistentry{void}{PolygonalCurve::Reset}{Point p}{603}{geoObject}{}
\functionlistentry{int}{PolygonalCurve::size}{}{597}{geoObject}{}
\functionlistentry{int}{Polynom1o::getCoefficient}{double \&a0, double \&a1}{1011}{functions}{}
\functionlistentry{}{Polynom1o::Polynom1o}{void}{1006}{functions}{}
\functionlistentry{}{Polynom1o::Polynom1o}{double a0, double a1}{1007}{functions}{}
\functionlistentry{}{Polynom1o::Polynom1o}{const vector\textless {}double\textgreater  \&v}{1008}{functions}{}
\functionlistentry{}{Polynom1o::Polynom1o}{const Polynom1o \&f}{1009}{functions}{}
\functionlistentry{int}{Polynom1o::setCoefficient}{double a0, double a1}{1010}{functions}{}
\functionlistentry{void}{Polynom2d1o::getCoefficient}{double \&a00, double \&a10, double \&a01}{1046}{functions}{}
\functionlistentry{}{Polynom2d1o::Polynom2d1o}{void}{1041}{functions}{}
\functionlistentry{}{Polynom2d1o::Polynom2d1o}{double a00, double a10, double a01}{1042}{functions}{}
\functionlistentry{}{Polynom2d1o::Polynom2d1o}{const vector\textless {}double\textgreater  \&v}{1043}{functions}{}
\functionlistentry{}{Polynom2d1o::Polynom2d1o}{const Polynom2d1o \&f}{1044}{functions}{}
\functionlistentry{void}{Polynom2d1o::setCoefficient}{double a00, double a10, double a01}{1045}{functions}{}
\functionlistentry{void}{Polynom2d2o::getCoefficient}{double \&a00, double \&a10, double \&a01, double \&a20, double \&a11, double \&a02}{1052}{functions}{}
\functionlistentry{}{Polynom2d2o::Polynom2d2o}{void}{1047}{functions}{}
\functionlistentry{}{Polynom2d2o::Polynom2d2o}{double a00, double a10, double a01, double a20, double a11, double a02}{1048}{functions}{}
\functionlistentry{}{Polynom2d2o::Polynom2d2o}{const vector\textless {}double\textgreater  \&v}{1049}{functions}{}
\functionlistentry{}{Polynom2d2o::Polynom2d2o}{const Polynom2d2o \&f}{1050}{functions}{}
\functionlistentry{void}{Polynom2d2o::setCoefficient}{double a00, double a10, double a01, double a20, double a11, double a02}{1051}{functions}{}
\functionlistentry{}{Polynom2d::Polynom2d}{void}{1053}{functions}{}
\functionlistentry{}{Polynom2d::Polynom2d}{int ord}{1054}{functions}{}
\functionlistentry{}{Polynom2d::Polynom2d}{const vector\textless {}double\textgreater  \&v}{1055}{functions}{}
\functionlistentry{}{Polynom2d::Polynom2d}{const Polynom2d \&f}{1056}{functions}{}
\functionlistentry{int}{Polynom2o::getCoefficient}{double \&a0, double \&a1, double \&a2}{1017}{functions}{}
\functionlistentry{}{Polynom2o::Polynom2o}{void}{1012}{functions}{}
\functionlistentry{}{Polynom2o::Polynom2o}{double a0, double a1, double a2}{1013}{functions}{}
\functionlistentry{}{Polynom2o::Polynom2o}{const Vector \&v}{1014}{functions}{}
\functionlistentry{}{Polynom2o::Polynom2o}{const Polynom2o \&f}{1015}{functions}{}
\functionlistentry{int}{Polynom2o::setCoefficient}{double a0, double a1, double a2}{1016}{functions}{}
\functionlistentry{}{Polynom::Polynom}{void}{1018}{functions}{}
\functionlistentry{}{Polynom::Polynom}{int ord}{1019}{functions}{}
\functionlistentry{}{Polynom::Polynom}{const vector\textless {}double\textgreater  \&v}{1020}{functions}{}
\functionlistentry{}{Polynom::Polynom}{const Polynom \&f}{1021}{functions}{}
\functionlistentry{int}{PolyNormMoments}{double m[21],double maf[21],double atr[3][3]}{1629}{obsolet}{}
\functionlistentry{void}{PopAlpha}{void}{1431}{genericTools}{}
\functionlistentry{int}{PowerSpectrumFImgD}{ImageD re,ImageD im,ImageD imgd,int mode=MD\_POWER}{1205}{signalTrafo}{}
\functionlistentry{int}{PowerSpectrumHImgD}{ImageD src,ImageD imgd,int mode=MD\_POWER}{1206}{signalTrafo}{}
\functionlistentry{int}{PowerSpectrumImgD}{ImageD imgs,ImageD imgd,int mode=MD\_POWER}{1207}{signalTrafo}{}
\functionlistentry{int}{PowerSpektrumQFT}{QuatMatrix\& input, Image\& output,int type=POWER, int mode=CENTER}{1552}{quaternions}{}
\functionlistentry{int}{PreprocessImg}{(Image imgs,Image imgd)}{1257}{registration}{}
\functionlistentry{int}{Print}{const string \&s}{1443}{genericTools}{}
\functionlistentry{int}{Printf}{const char *format,...}{1442}{genericTools}{}
\functionlistentry{int}{PrintHist}{const Hist \& h}{915}{statistics}{}
\functionlistentry{int}{PrintHistogram}{const Histogram \& h}{902}{statistics}{}
\functionlistentry{void}{PrintVecRn}{char *str,double *v,int dim}{1585}{obsolet}{}
\functionlistentry{void}{PushAlpha}{void}{1430}{genericTools}{}
\functionlistentry{int}{Put}{Statistics \&st,const Vector \&val,double weight=1.0}{867}{statistics}{}
\functionlistentry{int}{PutChar}{int c}{1439}{genericTools}{}
\functionlistentry{int}{PutStatistic}{Statistic st,double v[dim],double weight}{1606}{obsolet}{}
\functionlistentry{void}{PutVal}{Image \&img,int x,int y,int val}{64}{Images}{}
\functionlistentry{void}{PutVal}{Image \& img,const IPoint \&p,int val}{67}{Images}{}
\functionlistentry{void}{PutValD}{ImageD img,int x,int y,double val}{80}{Images}{}
\functionlistentry{void}{PutValue}{ImageD img,IPoint p,double val}{82}{Images}{}

\letterlabel{Q}
\letterlabel{Q}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}
\letterlabelend{Q}
\functionlistentry{Quaternion}{qexp}{Quaternion\& x}{1488}{quaternions}{}
\functionlistentry{Quaternion}{qexp}{RotQuaternion\& x}{1512}{quaternions}{}
\functionlistentry{int}{QFourier}{QuatMatrix\& input, QuatMatrix\& output,int option=NORMAL}{1551}{quaternions}{}
\functionlistentry{int}{QRDecomposition}{const Matrix \&A,Matrix \&Q,Matrix \&R}{1136}{matrixAlgebra}{}
\functionlistentry{}{QuadraticFormVectorDistance::QuadraticFormVectorDistance}{const Matrix \&a}{1241}{features}{}
\functionlistentry{Quaternion}{Quaternion::getConjugate}{}{1478}{quaternions}{}
\functionlistentry{Quaternion}{Quaternion::getEigenachse}{}{1485}{quaternions}{}
\functionlistentry{double}{Quaternion::getEigenwinkel}{}{1484}{quaternions}{}
\functionlistentry{double}{Quaternion::getI}{}{1468}{quaternions}{}
\functionlistentry{vector3d}{Quaternion::getImaginary}{}{1471}{quaternions}{}
\functionlistentry{Quaternion}{Quaternion::getInverse}{}{1479}{quaternions}{}
\functionlistentry{double}{Quaternion::getJ}{}{1469}{quaternions}{}
\functionlistentry{double}{Quaternion::getK}{}{1470}{quaternions}{}
\functionlistentry{Quaternion}{Quaternion::getNegate}{}{1477}{quaternions}{}
\functionlistentry{double}{Quaternion::getNorm}{}{1482}{quaternions}{}
\functionlistentry{Quaternion}{Quaternion::getNormalize}{}{1480}{quaternions}{}
\functionlistentry{vector3d}{Quaternion::getPhases}{}{1486}{quaternions}{}
\functionlistentry{double}{Quaternion::getReal}{}{1467}{quaternions}{}
\functionlistentry{Quaternion}{Quaternion::getSquare}{}{1481}{quaternions}{}
\functionlistentry{double}{Quaternion::getSquareNorm}{}{1483}{quaternions}{}
\functionlistentry{bool}{Quaternion::isUnitQuaternion}{}{1487}{quaternions}{}
\functionlistentry{}{Quaternion::Quaternion}{}{1463}{quaternions}{}
\functionlistentry{}{Quaternion::Quaternion}{double real, double i, double j, double k}{1464}{quaternions}{}
\functionlistentry{}{Quaternion::Quaternion}{double real, Vector3d\& imaginary}{1465}{quaternions}{}
\functionlistentry{}{Quaternion::Quaternion}{const Quaternion\& b}{1466}{quaternions}{}
\functionlistentry{void}{Quaternion::setI}{double i}{1473}{quaternions}{}
\functionlistentry{void}{Quaternion::setImaginary}{vector3d\& imaginary}{1476}{quaternions}{}
\functionlistentry{void}{Quaternion::setJ}{double j}{1474}{quaternions}{}
\functionlistentry{void}{Quaternion::setK}{double k}{1475}{quaternions}{}
\functionlistentry{void}{Quaternion::setReal}{double real}{1472}{quaternions}{}
\functionlistentry{unsigned int}{QuatMatrix::getColumns}{}{1519}{quaternions}{}
\functionlistentry{unsigned int}{QuatMatrix::getRows}{}{1518}{quaternions}{}
\functionlistentry{}{QuatMatrix::QuatMatrix}{}{1515}{quaternions}{}
\functionlistentry{}{QuatMatrix::QuatMatrix}{unsigned int rows, unsigned int columns}{1516}{quaternions}{}
\functionlistentry{}{QuatMatrix::QuatMatrix}{const QuatMatrix\& qm}{1517}{quaternions}{}
\functionlistentry{unsigned int}{QuatVector::getDimension}{}{1523}{quaternions}{}
\functionlistentry{}{QuatVector::QuatVector}{}{1520}{quaternions}{}
\functionlistentry{}{QuatVector::QuatVector}{unsigned int dimension}{1521}{quaternions}{}
\functionlistentry{}{QuatVector::QuatVector}{const QuatVector\& qv}{1522}{quaternions}{}

\letterlabel{R}
\letterlabel{R}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}
\letterlabelend{R}
\functionlistentry{int}{RadonImg}{const Image \&src,Image \&radon}{1234}{signalTrafo}{}
\functionlistentry{int}{Random}{int val}{860}{statistics}{}
\functionlistentry{double}{RandomD}{}{861}{statistics}{}
\functionlistentry{void}{Randomize}{}{859}{statistics}{}
\functionlistentry{int}{RankImg}{const Image \&src,int neighb,int rank,Image \&dest}{384}{filter}{}
\functionlistentry{int}{RankImg}{const Image \&src,int nx,int ny,int rank,Image \&dest}{385}{filter}{}
\functionlistentry{Line3d}{Ray}{const Point \&bp}{788}{cameraModel}{}
\functionlistentry{Line3d}{Ray}{double u,double v}{789}{cameraModel}{}
\functionlistentry{Line3d}{Ray}{const Vector \&bp}{790}{cameraModel}{}
\functionlistentry{int}{Read}{Statistics \&st,const string \&fn}{873}{statistics}{}
\functionlistentry{int}{ReadColorImageCache$<$T$>$::FrameNumber}{}{137}{imageio}{}
\functionlistentry{int}{ReadColorImageCache$<$T$>$::getError}{}{139}{imageio}{}
\functionlistentry{bool}{ReadColorImageCache$<$T$>$::Read}{const ColorImage \&img,int frame}{134}{imageio}{}
\functionlistentry{bool}{ReadColorImageCache$<$T$>$::Read}{const Image \&imgr,const Image \&imgg,const Image \&imgb,int frame}{135}{imageio}{}
\functionlistentry{}{ReadColorImageCache$<$T$>$::ReadColorImageCache}{T \&tr,int xsize,int ysize,int maxval,int csize}{132}{imageio}{}
\functionlistentry{int}{ReadImageCache$<$T$>$::FrameNumber}{}{136}{imageio}{}
\functionlistentry{int}{ReadImageCache$<$T$>$::getError}{}{138}{imageio}{}
\functionlistentry{bool}{ReadImageCache$<$T$>$::Read}{const Image \&img,int frame=ReadImagCache$<$T$>$::next}{133}{imageio}{}
\functionlistentry{}{ReadImageCache$<$T$>$::ReadImageCache}{T \&tr,int xsize,int ysize,int maxval,int csize}{131}{imageio}{}
\functionlistentry{Image}{ReadImg}{const string \&filename,Image \&img,int flag=IB\_SCALE}{113}{imageio}{}
\functionlistentry{int}{ReadImg}{const string \&file,Image \&imgr,Image \&imgg,Image \&imgb, int flag=IB\_SCALE}{115}{imageio}{}
\functionlistentry{Statistic}{ReadStatistic}{char *file}{1613}{obsolet}{}
\functionlistentry{PolygonalCurve}{Reduced}{int nr, int mode=1}{607}{geoObject}{}
\functionlistentry{void}{Reduced}{int nr, PolygonalCurve \&p, int mode=1}{608}{geoObject}{}
\functionlistentry{Matrix}{ReducePolygon}{const Matrix \&pl,int n}{281}{datastructures}{}
\functionlistentry{Matrix}{ReducePolygon}{const Contur \&c,int n}{282}{datastructures}{}
\functionlistentry{double}{ReferenceCosts}{const Matrix \&costs,const IMatrix \&pairs}{1265}{registration}{}
\functionlistentry{void}{Region::add}{int x,int y}{477}{conturs}{}
\functionlistentry{void}{Region::add}{const IPoint \&p}{478}{conturs}{}
\functionlistentry{void}{Region::add}{const Point \&p}{479}{conturs}{}
\functionlistentry{void}{Region::add}{int x1,int y1,int x2,int y2}{480}{conturs}{}
\functionlistentry{void}{Region::add}{const Window \&w}{481}{conturs}{}
\functionlistentry{void}{Region::add}{const Region \&r}{482}{conturs}{}
\functionlistentry{int}{Region::CalcMoments}{Moments \&m}{494}{conturs}{}
\functionlistentry{void}{Region::del}{int x,int y}{485}{conturs}{}
\functionlistentry{void}{Region::del}{const Point \&p}{486}{conturs}{}
\functionlistentry{void}{Region::del}{const IPoint \&p}{487}{conturs}{}
\functionlistentry{void}{Region::del}{int x1,int y1,int x2,int y2}{488}{conturs}{}
\functionlistentry{void}{Region::del}{const Region \&r}{489}{conturs}{}
\functionlistentry{int}{Region::getArea}{}{493}{conturs}{}
\functionlistentry{void}{Region::getPoints}{vector\textless {}IPoint\textgreater  \&points}{495}{conturs}{}
\functionlistentry{bool}{Region::inside}{int x,int y}{491}{conturs}{}
\functionlistentry{bool}{Region::isEmpty}{void}{492}{conturs}{}
\functionlistentry{Region}{Region::operator +}{const Region \&r1,const Region \&r2}{484}{conturs}{}
\functionlistentry{const Region \&}{Region::operator +=}{const Region \&r2}{483}{conturs}{}
\functionlistentry{Region}{Region::operator -}{const Region \&r1,const Region \&r2}{490}{conturs}{}
\functionlistentry{}{Region::Region}{}{474}{conturs}{}
\functionlistentry{}{Region::Region}{const Region \&r}{475}{conturs}{}
\functionlistentry{}{Region::Region}{const Contur \&c}{476}{conturs}{}
\functionlistentry{Region}{RegionGrow}{int x,int y,const Image \&orig,int maxsize=INT\_MAX,int refvalue=-1}{1148}{segmentation}{}
\functionlistentry{int}{RegionGrow}{int x,int y,const Image \&orig,Image \&mark,int val=1,int maxsize=INT\_MAX,int refvalue=-1}{1149}{segmentation}{}
\functionlistentry{Region}{RegionGrowGrw}{int x,int y,const Image \&orig,double stdmax=3.0,int maxSize=INT\_MAX}{1150}{segmentation}{}
\functionlistentry{int}{RegionGrowGrw}{int x,int y,const Image \&orig,Image \&mark,int val=1,double stdmax=3.0,int maxSize=INT\_MAX}{1151}{segmentation}{}
\functionlistentry{}{RegionWalker::RegionWalker}{const Region \&region}{193}{datastructures}{}
\functionlistentry{}{RegionWalker::RegionWalker}{const Contur \&contur}{194}{datastructures}{}
\functionlistentry{int}{RelaxImg}{const Image \&src,Image \&dest,int neighb=3}{388}{filter}{}
\functionlistentry{int}{RenormImg}{const Image \&img,const Image \&dest}{1097}{processing}{}
\functionlistentry{void}{Resize}{int n}{238}{datastructures}{}
\functionlistentry{}{ReturnErrorIfFailed}{function}{1563}{errorHandling}{}
\functionlistentry{}{ReturnNullIfFailed}{function}{1562}{errorHandling}{}
\functionlistentry{void}{RgbToHsi}{const ColorValue \&src, int maxval, double \&h, double \&s, double \&i}{295}{datastructures}{}
\functionlistentry{void}{RgbToHsi}{const ColorValue \&src, double \&h, double \&s, double \&i}{296}{datastructures}{}
\functionlistentry{void}{RgbToHsi}{double r, double g, double b, double \&h, double \&s, double \&i}{308}{datastructures}{}
\functionlistentry{void}{RgbToLab}{const ColorValue \&src, int maxval, double \&x, double \&y, double \&z}{301}{datastructures}{}
\functionlistentry{void}{RgbToLab}{const ColorValue \&src, double \&x, double \&y, double \&z}{302}{datastructures}{}
\functionlistentry{void}{RgbToLab}{double r, double g, double b, double \&x, double \&y, double \&z}{315}{datastructures}{}
\functionlistentry{void}{RgbToXyz}{const ColorValue \&src, int maxval, double \&x, double \&y, double \&z}{299}{datastructures}{}
\functionlistentry{void}{RgbToXyz}{const ColorValue \&src, double \&x, double \&y, double \&z}{300}{datastructures}{}
\functionlistentry{void}{RgbToXyz}{double r, double g, double b, double \&x, double \&y, double \&z}{311}{datastructures}{}
\functionlistentry{void}{RgbToYuv}{const ColorValue \&src, int maxval, double \&h, double \&s, double \&i}{297}{datastructures}{}
\functionlistentry{void}{RgbToYuv}{const ColorValue \&src, double \&h, double \&s, double \&i}{298}{datastructures}{}
\functionlistentry{void}{RgbToYuv}{double r, double g, double b, double \&h, double \&s, double \&i}{310}{datastructures}{}
\functionlistentry{int}{RidgeThreshold}{Image img}{450}{conturs}{}
\functionlistentry{int}{Root2}{double p1,p0,Complex *cptr1,*cptr2}{1407}{numeric}{}
\functionlistentry{int}{Root3}{double p2,p1,p0,Complex c[3]}{1408}{numeric}{}
\functionlistentry{int}{Root4}{double p3,p2,p1,p0,Complex c[4]}{1409}{numeric}{}
\functionlistentry{int}{RotateMoments}{const double m1[15],double c,double s, double m2[15]}{1623}{obsolet}{}
\functionlistentry{RotQuaternion}{RotQuaternion::getConjugate}{}{1503}{quaternions}{}
\functionlistentry{RotQuaternion}{RotQuaternion::getEigenachse}{}{1509}{quaternions}{}
\functionlistentry{double}{RotQuaternion::getEigenwinkel}{}{1508}{quaternions}{}
\functionlistentry{double}{RotQuaternion::getI}{}{1494}{quaternions}{}
\functionlistentry{vector3d}{RotQuaternion::getImaginary}{}{1497}{quaternions}{}
\functionlistentry{RotQuaternion}{RotQuaternion::getInverse}{}{1504}{quaternions}{}
\functionlistentry{double}{RotQuaternion::getJ}{}{1495}{quaternions}{}
\functionlistentry{double}{RotQuaternion::getK}{}{1496}{quaternions}{}
\functionlistentry{RotQuaternion}{RotQuaternion::getNegate}{}{1502}{quaternions}{}
\functionlistentry{double}{RotQuaternion::getNorm}{}{1506}{quaternions}{}
\functionlistentry{vector3d}{RotQuaternion::getPhases}{}{1510}{quaternions}{}
\functionlistentry{double}{RotQuaternion::getReal}{}{1493}{quaternions}{}
\functionlistentry{double}{RotQuaternion::getRotationAngle}{}{1498}{quaternions}{}
\functionlistentry{vector3d}{RotQuaternion::getRotationAxis}{}{1499}{quaternions}{}
\functionlistentry{Matrix}{RotQuaternion::getRotationMatrix}{}{1511}{quaternions}{}
\functionlistentry{RotQuaternion}{RotQuaternion::getSquare}{}{1505}{quaternions}{}
\functionlistentry{double}{RotQuaternion::getSquareNorm}{}{1507}{quaternions}{}
\functionlistentry{}{RotQuaternion::RotQuaternion}{}{1489}{quaternions}{}
\functionlistentry{}{RotQuaternion::RotQuaternion}{double angle, double x, double y, double z}{1490}{quaternions}{}
\functionlistentry{}{RotQuaternion::RotQuaternion}{double angle, vector3d\& axis}{1491}{quaternions}{}
\functionlistentry{}{RotQuaternion::RotQuaternion}{const RotQuaternion\& b) { Es wird eine Kopie der Rotationsquaternion b erzeugt. (Kopier-Konstruktor} }{1492}{quaternions}{}
\functionlistentry{void}{RotQuaternion::setRotationAngle}{double angle}{1500}{quaternions}{}
\functionlistentry{void}{RotQuaternion::setRotationAxis}{vector3d\& axis}{1501}{quaternions}{}
\functionlistentry{int}{RotTrans}{double x0, double y0, double phi, double tr[3][3]}{1597}{obsolet}{}
\functionlistentry{void}{RotTransPoint}{double p1[2],double centre[2],double arc,double p2[2]}{1383}{numeric}{}
\functionlistentry{double}{RoughnessContur}{Contur c, int diff}{431}{conturs}{}
\functionlistentry{double}{Round}{double val}{1370}{numeric}{}
\functionlistentry{int}{RoundInt}{double val}{1371}{numeric}{}
\functionlistentry{void}{RoundInt}{double val,int \&i}{1372}{numeric}{}

\letterlabel{S}
\letterlabel{S}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}
\letterlabelend{S}
\functionlistentry{int}{ScaleMoments}{const double m1[15],double a,double b, double m2[15]}{1622}{obsolet}{}
\functionlistentry{int}{ScaleTrans}{double x0, double y0, double a, double b, double tr[3][3]}{1598}{obsolet}{}
\functionlistentry{double*}{ScaleVec}{double v1[3],double fac,double v2[3]}{1572}{obsolet}{}
\functionlistentry{double*}{ScaleVecRn}{double *v1,int dim,double fac,double *v2}{1582}{obsolet}{}
\functionlistentry{double}{ScalProdVec}{double v1[3],double v2[3]}{1573}{obsolet}{}
\functionlistentry{double}{ScalProdVecRn}{double *v1,double *v2,int dim}{1583}{obsolet}{}
\functionlistentry{int}{ScanImg}{int ch,Image \&pi,int interactive=TRUE}{148}{imageio}{}
\functionlistentry{int}{ScanImg}{int ch,Image \&pr,Image \&pg,Image \&pb,int interactive=TRUE}{149}{imageio}{}
\functionlistentry{int}{ScanInfo}{int ch,int \&xm,int \&ym,int \&maxval,int \&channels, int \&flags,string \&descr}{150}{imageio}{}
\functionlistentry{void}{ScanWindow}{int ch,int x1,int y1,int x2,int y2}{147}{imageio}{}
\functionlistentry{int}{SearchCircStart}{Image iv,Image io,int c[2],int r,int pgl,int ps[2]}{447}{conturs}{}
\functionlistentry{int}{SearchCStart}{Image iv,Image io,Contur c,int *ptr,int pgl,int ps[2]}{448}{conturs}{}
\functionlistentry{int}{SearchGradStart}{Image iv,Image io,int thr,int diff,int ps[2],int mode}{446}{conturs}{}
\functionlistentry{int}{SearchRidgeStart}{Image imgv,Image imgo,int thr,int diff,int ps[2],int mode}{451}{conturs}{}
\functionlistentry{int}{SearchStart}{Image iv,Image io,object\_rc (*cls)(),int thr,int diff,int ps[2],int mode=HORZ}{438}{conturs}{}
\functionlistentry{int}{SearchStart}{Image iv,Image io,int (*cls)(),int thr,int diff,IPoint \&ps,int mode=HORZ}{439}{conturs}{}
\functionlistentry{Segment}{SegmentPointList}{PointList pl, int mode}{1189}{fitting}{}
\functionlistentry{Segment}{SegmentPointList}{PointList pl, int mode, [double maxdev]}{1190}{fitting}{}
\functionlistentry{Contur}{SelContur}{Image img,int force\_close=FALSE}{1352}{graphics}{}
\functionlistentry{int}{SelectWindow}{const Image \&img,int mode}{111}{Visualisierung}{}
\functionlistentry{bool}{SelFile}{const string \&mask,string \&filename,string \&dirname,int mode=DIR\_FILE,const string \&title='''', int x1=-1,int y1=-1,int x2=-1,int y2=-1}{1460}{genericTools}{}
\functionlistentry{bool}{SelFile}{const string \&mask, string \&filename}{1461}{genericTools}{}
\functionlistentry{LineSeg}{SelLine}{Image img}{1349}{graphics}{}
\functionlistentry{int}{SelLine}{Image img,IPoint \&p1,IPoint p2}{1350}{graphics}{}
\functionlistentry{int}{SelLine}{Image img,int p0[2],int p[2]}{1351}{graphics}{}
\functionlistentry{int}{SelPoint}{int mode,const Image \&img,int p[2]}{102}{Visualisierung}{}
\functionlistentry{IPoint}{SelPoint}{int mode,const Image \&img}{103}{Visualisierung}{}
\functionlistentry{IPoint}{SelPoint}{int mode,const Image \&img,int \&rc}{104}{Visualisierung}{}
\functionlistentry{Point}{SelPoint}{const Image \&img,int \&rc}{105}{Visualisierung}{}
\functionlistentry{Point}{SelPoint}{const Image \&img}{106}{Visualisierung}{}
\functionlistentry{IVector}{SelVector}{int mode,const Image \&img,int \&rc}{107}{Visualisierung}{}
\functionlistentry{IVector}{SelVector}{int mode,const Image \&img}{108}{Visualisierung}{}
\functionlistentry{IVector}{SelVector}{const Image \&img,int \&rc}{109}{Visualisierung}{}
\functionlistentry{IVector}{SelVector}{const Image \&img}{110}{Visualisierung}{}
\functionlistentry{void}{SetAlphaCursor}{int x,int y}{1433}{genericTools}{}
\functionlistentry{void}{SetAttribute}{int fg,int bg,int inv,int high}{1438}{genericTools}{}
\functionlistentry{int}{SetGreyColor}{int val,int red,int green,int blue}{96}{Visualisierung}{}
\functionlistentry{int}{SetGreyLUT}{int val1,int val2}{97}{Visualisierung}{}
\functionlistentry{int}{setImg}{const Image \&img,int val}{1087}{processing}{}
\functionlistentry{int}{setImg}{const Image \&img,const Function2d \& fn}{1088}{processing}{}
\functionlistentry{int}{SetImgD}{ImageD img,double val}{1099}{processing}{}
\functionlistentry{void}{SetOk}{void}{1560}{errorHandling}{}
\functionlistentry{int}{SetOverlayColor}{int val,int red,int green,int blue}{98}{Visualisierung}{}
\functionlistentry{int}{ShiftTrans}{double x0, double y0, double tr[3][3]}{1596}{obsolet}{}
\functionlistentry{int}{Show}{int mode,Image img,const string \& title=''''}{89}{Visualisierung}{}
\functionlistentry{int}{Show}{int mode,Image img1,Image img2,const string \& title=''''}{90}{Visualisierung}{}
\functionlistentry{int}{Show}{int mode,Image img1,Image img2,Image img3,const string \&title=''''}{91}{Visualisierung}{}
\functionlistentry{int}{Show}{const ColorImage \& img, int mode=ON}{92}{Visualisierung}{}
\functionlistentry{int}{Sign}{int val}{1361}{numeric}{}
\functionlistentry{double}{SignD}{double val}{1362}{numeric}{}
\functionlistentry{int}{SingularValueDcmp}{const Matrix \&A,Matrix \&U,Matrix \&S,Matrix \&V}{1134}{matrixAlgebra}{}
\functionlistentry{int}{SingularValueDcmp}{const Matrix \&A,Matrix \&U,Vector \&S,Matrix \&V}{1135}{matrixAlgebra}{}
\functionlistentry{int}{SingularValueDcmp}{MatrixStruct A,MatrixStruct *U,MatrixStruct *S,MatrixStruct *V}{1138}{matrixAlgebra}{}
\functionlistentry{int}{SkelettImg}{const Image \&src,const Image \&dest,int lvl=1}{389}{filter}{}
\functionlistentry{int}{SmearImg}{const Image \&src,Image \&dest,int n=3}{338}{filter}{}
\functionlistentry{int}{SmearImg}{const Image \&src,Image \&dest,int nx,int ny}{339}{filter}{}
\functionlistentry{int}{SmearImg}{const Image \&img,int n}{340}{filter}{}
\functionlistentry{int}{SmearImgD}{ImageD src,ImageD dest,int nx,int ny}{341}{filter}{}
\functionlistentry{int}{SmearImgD}{ImageD src,ImageD dest,int n}{342}{filter}{}
\functionlistentry{bool}{Solve2}{double a1,double b1,double i1,double a2,double b2,double i2,double \&x1,double \&x2}{1127}{matrixAlgebra}{}
\functionlistentry{Vector}{SolveLinEqu}{const Matrix \&M,const Vector \&i}{1123}{matrixAlgebra}{}
\functionlistentry{MatrixStruct}{SortMatrix}{MatrixStruct A,int col,int mode}{1594}{obsolet}{}
\functionlistentry{double}{SpatProdVec}{double v1[3],double v2[3],double v3[3]}{1575}{obsolet}{}
\functionlistentry{double}{Sphere::R}{}{656}{geoObject3d}{}
\functionlistentry{void}{Sphere::setR}{double vr}{657}{geoObject3d}{}
\functionlistentry{}{Sphere::Sphere}{}{649}{geoObject3d}{}
\functionlistentry{}{Sphere::Sphere}{double xp,double yp,double zp,double rp}{650}{geoObject3d}{}
\functionlistentry{}{Sphere::Sphere}{const Vector3d \&p,double rp}{651}{geoObject3d}{}
\functionlistentry{}{Sphere::Sphere}{const Point3d \&p,double rp}{652}{geoObject3d}{}
\functionlistentry{}{Sphere::Sphere}{const Sphere \&p}{653}{geoObject3d}{}
\functionlistentry{explicit}{Sphere::Sphere}{const Vector \&v}{654}{geoObject3d}{}
\functionlistentry{explicit}{Sphere::Sphere}{double d[]}{655}{geoObject3d}{}
\functionlistentry{double}{Sphere::Volume}{}{658}{geoObject3d}{}
\functionlistentry{string}{Split}{string \&text,const string \&del,int erase=true, int need\_del=false}{1424}{genericTools}{}
\functionlistentry{string}{SplitFilename}{const string \&fullname,string \&path,string \&basename,string \&ext}{1425}{genericTools}{}
\functionlistentry{string}{SplitFilename}{const string \&fullname,string \&path,string \&filename}{1426}{genericTools}{}
\functionlistentry{vector$<$vector$<$int$>$ $>$}{SplitToBranches}{Forest f}{1308}{graph}{}
\functionlistentry{double}{Sqr}{double val}{1356}{numeric}{}
\functionlistentry{int}{Statistics::Init}{}{865}{statistics}{}
\functionlistentry{int}{Statistics::Init}{int dim}{866}{statistics}{}
\functionlistentry{}{Statistics::Statistics}{}{863}{statistics}{}
\functionlistentry{}{Statistics::Statistics}{int dim}{864}{statistics}{}
\functionlistentry{int}{SubImg}{const Image \&img1,const Image \&img2,int smode,const Image \&dest,int mode=MD\_NORMALIZE}{1091}{processing}{}
\functionlistentry{int}{SubImg}{const Image \&img1,const Image \&img2,const Image \&dest,int smode=SMD\_ABSOLUTE,int mode=MD\_NORMALIZE}{1092}{processing}{}
\functionlistentry{int}{SubRankImg}{const Image \&src,int neighb,int rank,Image \&dest}{387}{filter}{}
\functionlistentry{double*}{SubVec}{double v1[3],double v2[3],double v3[3]}{1570}{obsolet}{}
\functionlistentry{double*}{SubVecRn}{double *v1,double *v2,int dim,double *v3}{1580}{obsolet}{}

\letterlabel{T}
\letterlabel{T}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}
\letterlabelend{T}
\functionlistentry{int}{TangentCircle}{double p[2],double par[3],double p1[2],double p2[2]}{1389}{numeric}{}
\functionlistentry{int}{Text}{const string \&s,IPoint p,int val,int exp,Image \& img}{1325}{graphics}{}
\functionlistentry{int}{Text}{const string \&s,int x,int y,int val,int exp,Image \& img}{1326}{graphics}{}
\functionlistentry{int}{Text}{const char *s,int x,int y,int val,int exp,Image \& img}{1327}{graphics}{}
\functionlistentry{double}{TimeD}{int mode=TM\_WORLD}{1455}{genericTools}{}
\functionlistentry{int}{TimeWarp}{const Matrix \&cost,IMatrix \&reference\_pairs, int mode=TW\_NORMAL}{1268}{registration}{}
\functionlistentry{int}{Trafo::DimD}{void}{690}{geoTrafo}{}
\functionlistentry{int}{Trafo::DimS}{void}{689}{geoTrafo}{}
\functionlistentry{int}{Trafo::Flip}{int axis}{704}{geoTrafo}{}
\functionlistentry{Matrix}{Trafo::Init}{void}{692}{geoTrafo}{}
\functionlistentry{Trafo}{Trafo::Inverse}{}{694}{geoTrafo}{}
\functionlistentry{int}{Trafo::Invert}{}{693}{geoTrafo}{}
\functionlistentry{double \&}{Trafo::operator ()}{int x,int y}{686}{geoTrafo}{}
\functionlistentry{Trafo \&}{Trafo::operator =}{const Trafo \&}{684}{geoTrafo}{}
\functionlistentry{Trafo \&}{Trafo::operator =}{const Matrix \&}{685}{geoTrafo}{}
\functionlistentry{int}{Trafo::Projective}{void}{713}{geoTrafo}{}
\functionlistentry{int}{Trafo::Rotate}{double x0,double y0,double phi}{699}{geoTrafo}{}
\functionlistentry{int}{Trafo::Rotate}{vector3d point,vector3d dir,double phi}{700}{geoTrafo}{}
\functionlistentry{int}{Trafo::RotateX}{double phi}{701}{geoTrafo}{}
\functionlistentry{int}{Trafo::RotateY}{double phi}{702}{geoTrafo}{}
\functionlistentry{int}{Trafo::RotateZ}{double phi}{703}{geoTrafo}{}
\functionlistentry{int}{Trafo::Scale}{double x0, double y0, double f}{707}{geoTrafo}{}
\functionlistentry{int}{Trafo::Scale}{double x0, double y0, double fx,double fy}{708}{geoTrafo}{}
\functionlistentry{int}{Trafo::Scale}{vector3d v, double f}{709}{geoTrafo}{}
\functionlistentry{int}{Trafo::Scale}{vector3d v, double fx,double fy,double fz}{710}{geoTrafo}{}
\functionlistentry{int}{Trafo::Scale}{Vector v, double f}{711}{geoTrafo}{}
\functionlistentry{int}{Trafo::Scale}{Vector v, Vector f}{712}{geoTrafo}{}
\functionlistentry{int}{Trafo::ShearX}{double dxy}{705}{geoTrafo}{}
\functionlistentry{int}{Trafo::ShearY}{double dyx}{706}{geoTrafo}{}
\functionlistentry{int}{Trafo::Shift}{double x0,double y0}{695}{geoTrafo}{}
\functionlistentry{int}{Trafo::Shift}{double x0,double y0,double y0}{696}{geoTrafo}{}
\functionlistentry{int}{Trafo::Shift}{vector3d v}{697}{geoTrafo}{}
\functionlistentry{int}{Trafo::Shift}{Vector v}{698}{geoTrafo}{}
\functionlistentry{Matrix}{Trafo::Tmatrix}{void}{691}{geoTrafo}{}
\functionlistentry{}{Trafo::Trafo}{void}{680}{geoTrafo}{}
\functionlistentry{}{Trafo::Trafo}{const Trafo \&}{681}{geoTrafo}{}
\functionlistentry{}{Trafo::Trafo}{const Matrix \&}{682}{geoTrafo}{}
\functionlistentry{}{Trafo::Trafo}{int dims,int dimd}{683}{geoTrafo}{}
\functionlistentry{TrafoDualQuaternion}{TrafoDualQuaternion::getConjugate}{}{1545}{quaternions}{}
\functionlistentry{Quaternion}{TrafoDualQuaternion::getDual}{}{1541}{quaternions}{}
\functionlistentry{TrafoDualQuaternion}{TrafoDualQuaternion::getInverse}{}{1547}{quaternions}{}
\functionlistentry{TrafoDualQuaternion}{TrafoDualQuaternion::getNegate}{}{1544}{quaternions}{}
\functionlistentry{Quaternion}{TrafoDualQuaternion::getReal}{}{1540}{quaternions}{}
\functionlistentry{TrafoDualQuaternion}{TrafoDualQuaternion::getTilde}{}{1546}{quaternions}{}
\functionlistentry{Matrix}{TrafoDualQuaternion::getTransformationMatrix}{}{1548}{quaternions}{}
\functionlistentry{void}{TrafoDualQuaternion::setDual}{vector3d\& trans}{1543}{quaternions}{}
\functionlistentry{void}{TrafoDualQuaternion::setRotation}{RotQuaternion\& rot}{1542}{quaternions}{}
\functionlistentry{}{TrafoDualQuaternion::TrafoDualQuaternion}{}{1537}{quaternions}{}
\functionlistentry{}{TrafoDualQuaternion::TrafoDualQuaternion}{RotQuaternion\& rot, vector3d\& trans}{1538}{quaternions}{}
\functionlistentry{}{TrafoDualQuaternion::TrafoDualQuaternion}{const TrafoDualQuaternion\& b}{1539}{quaternions}{}
\functionlistentry{Contur}{TransContur}{Contur c,double tr[3][3]}{1604}{obsolet}{}
\functionlistentry{int}{Transform}{const Trafo \&,double \&x,double \&y}{714}{geoTrafo}{}
\functionlistentry{int}{Transform}{const Trafo \&,Point \&p}{715}{geoTrafo}{}
\functionlistentry{int}{Transform}{const Trafo \&,double x,double y,double \&xt,double \&yt}{716}{geoTrafo}{}
\functionlistentry{int}{Transform}{const Trafo \&,Point p1,Point \&p2}{717}{geoTrafo}{}
\functionlistentry{int}{Transform}{const Trafo \&,double \&x,double \&y,double \&z)}{720}{geoTrafo}{}
\functionlistentry{int}{Transform}{const Trafo \&,double x,double y,double z,double \&xt,double \&yt,double \&zt}{721}{geoTrafo}{}
\functionlistentry{int}{Transform}{const Trafo \&,double x,double y,double z,double \&xt,double \&yt}{722}{geoTrafo}{}
\functionlistentry{Contur}{Transform}{const Trafo \& tr,const Contur \& c}{725}{geoTrafo}{}
\functionlistentry{int}{Transform}{const Trafo \&,const Image \&simg,Image \&dimg,int mode=DEFAULT}{726}{geoTrafo}{}
\functionlistentry{int}{Transform}{const Trafo \&,const Image \&simg,Image \&dimg,int mode, Image \&mark,int val=1}{727}{geoTrafo}{}
\functionlistentry{int}{TransformAndRound}{const Trafo \&,int \&x,int \&y}{718}{geoTrafo}{}
\functionlistentry{int}{TransformAndRound}{const Trafo \&,int x,int y,int \&xt,int \&yt}{719}{geoTrafo}{}
\functionlistentry{int}{TransformList}{const Trafo \&tr,Matrix \&m}{723}{geoTrafo}{}
\functionlistentry{int}{TransformList}{const Trafo \&tr,const Matrix \&m,Matrix \&m2}{724}{geoTrafo}{}
\functionlistentry{int}{TransImg}{Image imgs,double tr[3][3],int mode,Image imgd}{1603}{obsolet}{}
\functionlistentry{int}{TranslateMoments}{const double m1[15],double x,double y,double m2[15]}{1618}{obsolet}{}
\functionlistentry{MatrixStruct}{TranspMat}{MatrixStruct m1,MatrixStruct m2}{1590}{obsolet}{}
\functionlistentry{double*}{TransPoint}{double p1[2],double tr[3][3],double p2[2]}{1602}{obsolet}{}
\functionlistentry{void}{Triangle2Region}{const Triangle \&t, Region \&r}{590}{geoObject}{}
\functionlistentry{Point}{Triangle::getCCCenter}{}{587}{geoObject}{}
\functionlistentry{double}{Triangle::getCCRadius}{}{588}{geoObject}{}
\functionlistentry{Point}{Triangle::getCorner}{int i}{583}{geoObject}{}
\functionlistentry{bool}{Triangle::isInsideCC}{Point point}{589}{geoObject}{}
\functionlistentry{bool}{Triangle::isValid}{}{582}{geoObject}{}
\functionlistentry{const Point \&}{Triangle::P1}{}{584}{geoObject}{}
\functionlistentry{const Point \&}{Triangle::P2}{}{585}{geoObject}{}
\functionlistentry{const Point \&}{Triangle::P3}{}{586}{geoObject}{}
\functionlistentry{}{Triangle::Triangle}{}{580}{geoObject}{}
\functionlistentry{}{Triangle::Triangle}{Point p1, Point p2, Point p3}{581}{geoObject}{}

\letterlabel{U}
\letterlabel{U}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}
\letterlabelend{U}
\functionlistentry{int}{UpdateLimitImgD}{ImageD img}{84}{Images}{}
\functionlistentry{string}{uppercase}{const string \&s}{1423}{genericTools}{}

\letterlabel{V}
\letterlabel{V}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}
\letterlabelend{V}
\functionlistentry{void}{Vector3d::Normalize}{}{203}{datastructures}{}
\functionlistentry{Vector3d}{Vector3d::Normalized}{}{202}{datastructures}{}
\functionlistentry{Vector}{Vector3d::operator Vector}{}{201}{datastructures}{}
\functionlistentry{}{Vector3d::Vector3d}{}{195}{datastructures}{}
\functionlistentry{}{Vector3d::Vector3d}{const Vector3d \&p}{196}{datastructures}{}
\functionlistentry{}{Vector3d::Vector3d}{double xp,double yp,double zp}{197}{datastructures}{}
\functionlistentry{explicit}{Vector3d::Vector3d}{const Vector \&v}{198}{datastructures}{}
\functionlistentry{explicit}{Vector3d::Vector3d}{const IVector \&v}{199}{datastructures}{}
\functionlistentry{explicit}{Vector3d::Vector3d}{double p[]}{200}{datastructures}{}
\functionlistentry{void}{Vector::Append}{double val}{245}{datastructures}{}
\functionlistentry{void}{Vector::Append}{const Vector \&v}{246}{datastructures}{}
\functionlistentry{double \&}{Vector::at}{int idx}{233}{datastructures}{}
\functionlistentry{void}{Vector::Delete}{int i1,int i2}{248}{datastructures}{}
\functionlistentry{void}{Vector::Delete}{int i}{249}{datastructures}{}
\functionlistentry{bool}{Vector::empty}{}{236}{datastructures}{}
\functionlistentry{void}{Vector::Exchange}{int i1,int i2}{247}{datastructures}{}
\functionlistentry{double}{Vector::Length}{}{250}{datastructures}{}
\functionlistentry{void}{Vector::Normalize}{}{251}{datastructures}{}
\functionlistentry{void}{Vector::Set}{double val}{239}{datastructures}{}
\functionlistentry{void}{Vector::SetV}{double d1}{240}{datastructures}{}
\functionlistentry{void}{Vector::SetV}{double d1,double d2}{241}{datastructures}{}
\functionlistentry{void}{Vector::SetV}{double d1,double d2,double d3}{242}{datastructures}{}
\functionlistentry{void}{Vector::SetV}{double d1,double d2,double d3,double d4}{243}{datastructures}{}
\functionlistentry{void}{Vector::SetV}{double d1,double d2,double d3,double d4,double d5}{244}{datastructures}{}
\functionlistentry{int}{Vector::Size}{}{234}{datastructures}{}
\functionlistentry{unsigned int}{Vector::size}{}{235}{datastructures}{}
\functionlistentry{void}{Vector::Sort}{int order=0}{252}{datastructures}{}
\functionlistentry{}{Vector::Vector}{}{224}{datastructures}{}
\functionlistentry{}{Vector::Vector}{int n}{225}{datastructures}{}
\functionlistentry{}{Vector::Vector}{int n,double *data}{226}{datastructures}{}
\functionlistentry{}{Vector::Vector}{const Vector \&v}{227}{datastructures}{}
\functionlistentry{explicit}{Vector::Vector}{const vector<double> \&v}{228}{datastructures}{}
\functionlistentry{}{Vector::Vector}{double d1,double d2}{229}{datastructures}{}
\functionlistentry{}{Vector::Vector}{double d1,double d2,double d3}{230}{datastructures}{}
\functionlistentry{}{Vector::Vector}{double d1,double d2,double d3,double d4}{231}{datastructures}{}
\functionlistentry{}{Vector::Vector}{double d1,double d2,double d3,double d4,double d5}{232}{datastructures}{}
\functionlistentry{double}{VectorDistance::Distance}{const vector$<$double$>$ \&x,const vector$<$double$>$ \&x}{1237}{features}{}
\functionlistentry{double}{VectorDistance::Distance}{const Vector \&x,const Vector \&y}{1238}{features}{}
\functionlistentry{double}{VectorDistance::operator()}{const vector$<$double$>$ \&x,const vector$<$double$>$ \&y}{1239}{features}{}
\functionlistentry{double}{VectorDistance::operator()}{const Vector \&x,const Vector \&y}{1240}{features}{}
\functionlistentry{void}{VideoFile::getPara}{int \&xs,int \&ys,int \&mv,int \&fps}{122}{imageio}{}
\functionlistentry{int}{VideoFile::open}{const string \&fn,ios\_base::openmode mode = ios\_base::in}{121}{imageio}{}
\functionlistentry{bool}{VideoFile::Read}{Image \&img,int ch=3}{125}{imageio}{}
\functionlistentry{bool}{VideoFile::Read}{Image \&ir,Image \&ig,Image \&ib}{126}{imageio}{}
\functionlistentry{bool}{VideoFile::Read}{ColorImage \&irgb}{127}{imageio}{}
\functionlistentry{void}{VideoFile::setCPara}{const string \&p}{124}{imageio}{}
\functionlistentry{void}{VideoFile::setPara}{int xs,int ys,int mv,int fps,int bitrate=0}{123}{imageio}{}
\functionlistentry{}{VideoFile::VideoFile}{}{119}{imageio}{}
\functionlistentry{}{VideoFile::VideoFile}{const string \&fn,ios\_base::openmode mode = ios\_base::in}{120}{imageio}{}
\functionlistentry{bool}{VideoFile::Write}{const Image \&img}{128}{imageio}{}
\functionlistentry{bool}{VideoFile::Write}{const Image \&ir,const Image \&ig,const Image \&ib}{129}{imageio}{}
\functionlistentry{bool}{VideoFile::Write}{const ImageRGB \&irgb}{130}{imageio}{}
\functionlistentry{int}{VideoFileCached::FrameNumber}{}{145}{imageio}{}
\functionlistentry{int}{VideoFileCached::getError}{}{146}{imageio}{}
\functionlistentry{void}{VideoFileCached::getPara}{int \&xs,int \&ys,int \&mv,int \&fps}{141}{imageio}{}
\functionlistentry{bool}{VideoFileCached::Read}{Image \&ir,Image \&ig,Image \&ib,int frame=VideoFileCached::next}{142}{imageio}{}
\functionlistentry{bool}{VideoFileCached::Read}{ColorImage \&img,int frame=VideoFileCached::next}{143}{imageio}{}
\functionlistentry{bool}{VideoFileCached::Read}{ImageRGB \&img,int frame=VideoFileCached::next}{144}{imageio}{}
\functionlistentry{}{VideoFileCached::VideoFileCached}{const string \&fn,int buffersize}{140}{imageio}{}

\letterlabel{W}
\letterlabel{W}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}
\letterlabelend{W}
\functionlistentry{void}{Walker::init}{}{178}{datastructures}{}
\functionlistentry{void}{Walker::moveTo}{IPoint p}{177}{datastructures}{}
\functionlistentry{void}{Walker::next}{}{179}{datastructures}{}
\functionlistentry{void}{Walker::next}{int steps}{180}{datastructures}{}
\functionlistentry{bool}{Walker::ready}{}{181}{datastructures}{}
\functionlistentry{}{Walker::Walker}{}{174}{datastructures}{}
\functionlistentry{}{Walker::Walker}{IPoint p}{175}{datastructures}{}
\functionlistentry{}{Walker::Walker}{int x, int y}{176}{datastructures}{}
\functionlistentry{double}{Weight}{const Statistics \&st}{869}{statistics}{}
\functionlistentry{int}{WhiteningFImgD}{ImageD re1,ImageD im1,ImageD re2,ImageD im2,double beta=0}{1230}{signalTrafo}{}
\functionlistentry{int}{WhiteningHImgD}{ImageD imgs,ImageD imgd,double beta=0}{1231}{signalTrafo}{}
\functionlistentry{int}{WhiteningImgD}{ImageD img1,ImageD img2,double beta=0}{1229}{signalTrafo}{}
\functionlistentry{int}{Window::GetBottom}{}{214}{datastructures}{}
\functionlistentry{int}{Window::GetLeft}{}{208}{datastructures}{}
\functionlistentry{int}{Window::GetRight}{}{210}{datastructures}{}
\functionlistentry{IPoint}{Window::getSize}{}{218}{datastructures}{}
\functionlistentry{int}{Window::GetTop}{}{212}{datastructures}{}
\functionlistentry{int}{Window::Height}{}{207}{datastructures}{}
\functionlistentry{bool}{Window::Inside}{const IPoint \&p}{219}{datastructures}{}
\functionlistentry{bool}{Window::Inside}{int x,int y}{220}{datastructures}{}
\functionlistentry{bool}{Window::operator !=}{const Window \&w}{222}{datastructures}{}
\functionlistentry{bool}{Window::operator ==}{const Window \&w}{221}{datastructures}{}
\functionlistentry{const IPoint \&}{Window::P1}{}{216}{datastructures}{}
\functionlistentry{const IPoint \&}{Window::P2}{}{217}{datastructures}{}
\functionlistentry{int}{Window::Shift}{int dx,int dy}{223}{datastructures}{}
\functionlistentry{int}{Window::Width}{}{206}{datastructures}{}
\functionlistentry{}{Window::Window}{}{204}{datastructures}{}
\functionlistentry{}{Window::Window}{int x1,int y1,int x2,int y2}{205}{datastructures}{}
\functionlistentry{int}{Window::XA}{}{211}{datastructures}{}
\functionlistentry{int}{Window::XI}{}{209}{datastructures}{}
\functionlistentry{int}{Window::YA}{}{215}{datastructures}{}
\functionlistentry{int}{Window::Yi}{}{213}{datastructures}{}
\functionlistentry{}{WindowWalker::WindowWalker}{const Window \&w}{182}{datastructures}{}
\functionlistentry{}{WindowWalker::WindowWalker}{const Image \&img center}{183}{datastructures}{}
\functionlistentry{}{WindowWalker::WindowWalker}{IPoint center, int sizex, int sizey = -1}{184}{datastructures}{}
\functionlistentry{int}{Write}{const Statistics \&st,const string \&fn}{872}{statistics}{}
\functionlistentry{int}{WriteImg}{const Image \&img,const string \&filename}{114}{imageio}{}
\functionlistentry{int}{WriteImg}{const Image \&ir,const Image \&ig,const Image \&ib,const string \&filename}{116}{imageio}{}
\functionlistentry{int}{WriteStatistic}{Statistic st,char *file}{1612}{obsolet}{}
\functionlistentry{int}{WST}{Image in, Image WSImg, int mode=1}{1146}{segmentation}{}

\letterlabel{X}
\letterlabel{X}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}
\letterlabelend{X}
\functionlistentry{int}{XShearMoments}{const double m[15],double a,double ms[15]}{1620}{obsolet}{}
\functionlistentry{void}{XyzToLab}{double x, double y, double z, double \&l, double \&a, double \&b}{313}{datastructures}{}
\functionlistentry{void}{XyzToRgb}{double x, double y, double z, ColorValue \&dst, int maxval = 255}{305}{datastructures}{}
\functionlistentry{void}{XyzToRgb}{double x, double y, double z, double \&r, double \&g, double \&b}{312}{datastructures}{}

\letterlabel{Y}
\letterlabel{Y}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}
\letterlabelend{Y}
\functionlistentry{int}{YShearMoments}{const double m1[15],double b,double m2[15]}{1621}{obsolet}{}
\functionlistentry{int}{YuvToColorImage}{const Image \&y, const Image \&u, const Image \&v, const ColorImage \&dst}{1115}{processing}{}
\functionlistentry{void}{YuvToRgb}{double y, double u, double v, ColorValue \&dst, int maxval = 255}{304}{datastructures}{}
\functionlistentry{void}{YuvToRgb}{double y, double u, double v, double \&r, double \&g, double \&b}{309}{datastructures}{}

\letterlabel{Z}
\letterlabel{Z}
\letterref{A}
\letterref{B}
\letterref{C}
\letterref{D}
\letterref{E}
\letterref{F}
\letterref{G}
\letterref{H}
\letterref{I}
\letterref{K}
\letterref{L}
\letterref{M}
\letterref{N}
\letterref{O}
\letterref{P}
\letterref{Q}
\letterref{R}
\letterref{S}
\letterref{T}
\letterref{U}
\letterref{V}
\letterref{W}
\letterref{X}
\letterref{Y}
\letterref{Z}
\letterlabelend{Z}
\functionlistentry{int}{Zoom}{Image img,int val,int x,int y}{93}{Visualisierung}{}
\functionlistentry{int}{Zoom}{Image img}{94}{Visualisierung}{}
