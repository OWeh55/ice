#include <image.h>

/*AppGen:Global*/

/*AppGen
 prog: Test of shift detection methodes
 %% Beschreibung Parameter
 % symbolischerName, Art, Typ,   Variablenname, Erkl√§rung, Default-Wert
 %% Optionen
 %
 opt: X, xsize, int, xSize, Image size x, 1111
 opt: Y, ysize, int, ySize, Image size y, 888
 opt: f, file, string, filename, Use image file, ""
 opt: x, deltax, double, deltaX, Offset x, 4.7
 opt: y, deltay, double, deltaY, Offset y, -2.3
 opt: v, verbose, void, verbose, Many messages, false
 opt: h, help, usage, help, Hilfe
AppGen*/

Image createImage(int sx, int sy, double dx, double dy, vector<int> freqs)
{
  ImageD imgd;
  imgd.create(sx, sy);
  imgd.set(0);
  for (int f : freqs)
    {
      double omegax = f * 2 * M_PI / sx;
      double omegay = f * 2 * M_PI / sy;
      double ax = 1.0 + drand48() * 0.3;
      double ay = 1.0 + drand48() * 0.3;
      for (int x = 0; x < sx; x++)
        for (int y = 0; y < sy; y++)
          {
            double val = sin((x - dx) * omegax) * ax + sin((y - dy) * omegay) * ay;
            imgd.setPixel(x, y, val + imgd.getPixel(x, y));
          }
    }
  Image res;
  res.create(sx, sy, 255);
  ConvImgDImg(imgd, res, ADAPTIVE);
  return res;
}

/*AppGen:Main*/
int main(int argc, char* argv[])
{
  /*AppGen:MainEnd*/
  Image i1, i2;
  if (filename.empty())
    {
      vector<int> freqs{1, 3, 11, 15, 17, 21, 25, 29, 35, 40, 45, 50, 55, 222, 333, 444};
      i1 = createImage(xSize, ySize, 0, 0, freqs);
      i2 = createImage(xSize, ySize, deltaX, deltaY, freqs);
    }
  else
    {
      i1.read(filename);
      xSize = i1.xsize;
      ySize = i1.ysize;
      i2.create(xSize, ySize, i1.maxval);
      for (int y = 0; y < ySize; y++)
        for (int x = 0; x < xSize; x++)
          {
            double xf = FMod(x - deltaX, xSize);
            double yf = FMod(y - deltaY, ySize);
            i2.setPixel(x, y, i1.getPixelInterpol(xf, yf));
          }
    }

  Show(GRAY, i1, "original");
  Show(GRAY, i2, "shifted");

  ImageD psf;
  psf.create(xSize, ySize);

  InvConvolution(i1, i2, psf, 0.00001);
  psf.adaptLimits();
  Show(GRAY, psf, "psf");

  double ex, ey;
  double val = detectShift(i1, i2, ex, ey);
  cout << "detected shift: " << ex << "," << ey << endl;
  cout << "quality: " << val << endl;

  GetChar();

  Trafo tr;
  detectTrafo(i1, i2, tr);
  cout << "Trafo: " << tr.getMatrix() << endl;

  GetChar();
  return 1;
}
